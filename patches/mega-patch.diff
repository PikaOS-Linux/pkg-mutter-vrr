diff '--color=auto' -uraN a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
--- a/clutter/clutter/clutter-frame-clock.c	2023-09-16 23:51:03.000000000 +0300
+++ b/clutter/clutter/clutter-frame-clock.c	2023-10-12 20:59:22.640500163 +0300
@@ -37,6 +37,8 @@
 
 #define SYNC_DELAY_FALLBACK_FRACTION 0.875
 
+#define MINIMUM_REFRESH_RATE 30
+
 typedef struct _ClutterFrameListener
 {
   const ClutterFrameListenerIface *iface;
@@ -54,6 +56,7 @@
 {
   CLUTTER_FRAME_CLOCK_STATE_INIT,
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
+  CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
   CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
@@ -65,6 +68,8 @@
 
   float refresh_rate;
   int64_t refresh_interval_us;
+  int64_t minimum_refresh_interval_us;
+
   ClutterFrameListener listener;
 
   GSource *source;
@@ -72,6 +77,8 @@
   int64_t frame_count;
 
   ClutterFrameClockState state;
+  ClutterFrameClockMode mode;
+
   int64_t last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
   int64_t last_presentation_time_us;
@@ -375,6 +382,7 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -395,6 +403,7 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -597,6 +606,39 @@
   *out_min_render_time_allowed_us = min_render_time_allowed_us;
 }
 
+static void
+calculate_next_idle_timeout_us (ClutterFrameClock *frame_clock,
+                                int64_t           *out_next_update_time_us)
+{
+  int64_t now_us;
+  int64_t last_presentation_time_us;
+  int64_t next_presentation_time_us;
+  int64_t timeout_interval_us;
+
+  now_us = g_get_monotonic_time ();
+
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
+
+  timeout_interval_us = frame_clock->minimum_refresh_interval_us;
+
+  if (last_presentation_time_us == 0)
+    {
+      *out_next_update_time_us =
+        frame_clock->last_dispatch_time_us ?
+        ((frame_clock->last_dispatch_time_us -
+          frame_clock->last_dispatch_lateness_us) + timeout_interval_us) :
+        now_us;
+      return;
+    }
+
+  next_presentation_time_us = last_presentation_time_us + timeout_interval_us;
+
+  while (next_presentation_time_us < now_us)
+    next_presentation_time_us += timeout_interval_us;
+
+  *out_next_update_time_us = next_presentation_time_us;
+}
+
 void
 clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
 {
@@ -609,6 +651,7 @@
         case CLUTTER_FRAME_CLOCK_STATE_INIT:
         case CLUTTER_FRAME_CLOCK_STATE_IDLE:
           break;
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
         case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
           frame_clock->pending_reschedule = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
@@ -650,6 +693,7 @@
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
       next_update_time_us = g_get_monotonic_time ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -682,15 +726,12 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
       next_update_time_us = g_get_monotonic_time ();
-      break;
+      g_source_set_ready_time (frame_clock->source, next_update_time_us);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      return;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      calculate_next_update_time_us (frame_clock,
-                                     &next_update_time_us,
-                                     &frame_clock->next_presentation_time_us,
-                                     &frame_clock->min_render_time_allowed_us);
-      frame_clock->is_next_presentation_time_valid =
-        (frame_clock->next_presentation_time_us != 0);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -699,11 +740,56 @@
       return;
     }
 
+  switch (frame_clock->mode)
+    {
+    case CLUTTER_FRAME_CLOCK_MODE_FIXED:
+      calculate_next_update_time_us (frame_clock,
+                                     &next_update_time_us,
+                                     &frame_clock->next_presentation_time_us,
+                                     &frame_clock->min_render_time_allowed_us);
+      frame_clock->is_next_presentation_time_valid =
+            (frame_clock->next_presentation_time_us != 0);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      break;
+    case CLUTTER_FRAME_CLOCK_MODE_VARIABLE:
+      calculate_next_idle_timeout_us (frame_clock,
+                                      &next_update_time_us);
+      frame_clock->is_next_presentation_time_valid = FALSE;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT;
+      break;
+    }
+
   g_warn_if_fail (next_update_time_us != -1);
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+}
+
+void
+clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                              ClutterFrameClockMode  mode)
+{
+  if (frame_clock->mode == mode)
+    return;
+
+  frame_clock->mode = mode;
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+      frame_clock->pending_reschedule = TRUE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      break;
+    }
+
+  maybe_reschedule_update (frame_clock);
 }
 
 static void
@@ -794,6 +880,7 @@
       g_warn_if_reached ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -918,6 +1005,10 @@
   init_frame_clock_source (frame_clock);
 
   clutter_frame_clock_set_refresh_rate (frame_clock, refresh_rate);
+
+  frame_clock->minimum_refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / MINIMUM_REFRESH_RATE);
+
   frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
@@ -951,6 +1042,7 @@
 clutter_frame_clock_init (ClutterFrameClock *frame_clock)
 {
   frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_INIT;
+  frame_clock->mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
 }
 
 static void
diff '--color=auto' -uraN a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
--- a/clutter/clutter/clutter-frame-clock.h	2023-09-16 23:51:03.000000000 +0300
+++ b/clutter/clutter/clutter-frame-clock.h	2023-10-12 20:59:22.667167163 +0300
@@ -54,6 +54,12 @@
                                 gpointer           user_data);
 } ClutterFrameListenerIface;
 
+typedef enum _ClutterFrameClockMode
+{
+  CLUTTER_FRAME_CLOCK_MODE_FIXED,
+  CLUTTER_FRAME_CLOCK_MODE_VARIABLE,
+} ClutterFrameClockMode;
+
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
                                              int64_t                          vblank_duration_us,
@@ -64,6 +70,10 @@
 void clutter_frame_clock_destroy (ClutterFrameClock *frame_clock);
 
 CLUTTER_EXPORT
+void clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                                   ClutterFrameClockMode  mode);
+
+CLUTTER_EXPORT
 void clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                            ClutterFrameInfo  *frame_info);
 
diff '--color=auto' -uraN a/cogl/cogl/winsys/cogl-onscreen-glx.c b/cogl/cogl/winsys/cogl-onscreen-glx.c
--- a/cogl/cogl/winsys/cogl-onscreen-glx.c	2023-09-16 23:51:03.000000000 +0300
+++ b/cogl/cogl/winsys/cogl-onscreen-glx.c	2023-10-12 20:59:22.717167787 +0300
@@ -540,6 +540,8 @@
   GLXDrawable drawable;
   unsigned int age = 0;
 
+  return 0;
+
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_BUFFER_AGE))
     return 0;
 
diff '--color=auto' -uraN a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml	2023-09-16 23:51:03.000000000 +0300
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml	2023-10-12 20:59:22.707167662 +0300
@@ -343,6 +343,10 @@
 	    - "is-underscanning" (b): whether underscanning is enabled
 				      (absence of this means underscanning
 				      not being supported)
+	    - "is-vrr-allowed" (b): whether variable refresh rate is allowed
+	                            (absence of this means variable refresh
+	                            rate not being supported)
+
 	    - "max-screen-size" (ii): the maximum size a screen may have
 				      (absence of this means unlimited screen
 				      size)
@@ -413,6 +417,11 @@
 			     using the logical monitor scale.
 	    * 2 : physical - the dimension of a logical monitor is derived from
 			     the monitor modes associated with it.
+	    * 3 : logical with ui scaling - the dimension of a logical monitor
+			     is derived from the monitor modes associated with it,
+			     then scaled using the logical monitor scale that is also
+			     scaled by the global UI scaling (computed using the maximum
+			     ceiled scaling value across the displays).
 	* "supports-changing-layout-mode" (b): True if the layout mode can be
 					       changed. Absence of this means the
 					       layout mode cannot be changed.
@@ -461,6 +470,9 @@
 	        - "enable_underscanning" (b): enable monitor underscanning;
 					      may only be set when underscanning
 					      is supported (see GetCurrentState).
+	        - "allow_vrr" (b): whether to allow variable refresh rate; may
+	                           only be set when variable refresh rate is
+	                           supported (see GetCurrentState).
 
 	@properties may effect the global monitor configuration state. Possible
 	properties are:
diff '--color=auto' -uraN a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml.orig b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml.orig
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml.orig	2023-10-12 20:59:22.667167163 +0300
@@ -0,0 +1,500 @@
+<!DOCTYPE node PUBLIC
+'-//freedesktop//DTD D-BUS Object Introspection 1.0//EN'
+'http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd'>
+<node>
+  <!--
+      org.gnome.Mutter.DisplayConfig:
+      @short_description: display configuration interface
+
+      This interface is used by mutter and gnome-settings-daemon
+      to apply multiple monitor configuration.
+  -->
+
+  <interface name="org.gnome.Mutter.DisplayConfig">
+
+    <!--
+        GetResources:
+	@serial: configuration serial
+	@crtcs: available CRTCs
+	@outputs: available outputs
+	@modes: available modes
+	@max_screen_width:
+	@max_screen_height:
+
+        Retrieves the current layout of the hardware.
+
+        @serial is an unique identifier representing the current state
+        of the screen. It must be passed back to ApplyConfiguration()
+	and will be increased for every configuration change (so that
+	mutter can detect that the new configuration is based on old
+	state).
+
+	A CRTC (CRT controller) is a logical monitor, ie a portion
+	of the compositor coordinate space. It might correspond
+	to multiple monitors, when in clone mode, but not that
+	it is possible to implement clone mode also by setting different
+	CRTCs to the same coordinates.
+
+	The number of CRTCs represent the maximum number of monitors
+	that can be set to expand and it is a HW constraint; if more
+	monitors are connected,	then necessarily some will clone. This
+	is complementary to the concept of the encoder (not exposed in
+	the API), which groups outputs that necessarily will show the
+	same image (again a HW constraint).
+
+	A CRTC is represented by a DBus structure with the following
+	layout:
+	* u ID: the ID in the API of this CRTC
+	* x winsys_id: the low-level ID of this CRTC (which might
+	               be a XID, a KMS handle or something entirely
+		       different)
+	* i x, y, width, height: the geometry of this CRTC
+	                         (might be invalid if the CRTC is not in
+				 use)
+	* i current_mode: the current mode of the CRTC, or -1 if this
+	                  CRTC is not used
+			  Note: the size of the mode will always correspond
+			  to the width and height of the CRTC
+	* u current_transform: the current transform (espressed according
+	                       to the wayland protocol)
+	* au transforms: all possible transforms
+	* a{sv} properties: other high-level properties that affect this
+	                    CRTC; they are not necessarily reflected in
+			    the hardware.
+			    No property is specified in this version of the API.
+
+        Note: all geometry information refers to the untransformed
+	display.
+
+	An output represents a physical screen, connected somewhere to
+	the computer. Floating connectors are not exposed in the API.
+	An output is a DBus struct with the following fields:
+	* u ID: the ID in the API
+	* x winsys_id: the low-level ID of this output (XID or KMS handle)
+	* i current_crtc: the CRTC that is currently driving this output,
+	                  or -1 if the output is disabled
+	* au possible_crtcs: all CRTCs that can control this output
+	* s name: the name of the connector to which the output is attached
+	          (like VGA1 or HDMI)
+	* au modes: valid modes for this output
+	* au clones: valid clones for this output, ie other outputs that
+	             can be assigned the same CRTC as this one; if you
+	             want to mirror two outputs that don't have each other
+	             in the clone list, you must configure two different
+	             CRTCs for the same geometry
+	* a{sv} properties: other high-level properties that affect this
+	                    output; they are not necessarily reflected in
+			    the hardware.
+			    Known properties:
+                            - "vendor" (s): (readonly) the human readable name
+                                            of the manufacturer
+                            - "product" (s): (readonly) the human readable name
+                                             of the display model
+                            - "serial" (s): (readonly) the serial number of this
+                                            particular hardware part
+			    - "display-name" (s): (readonly) a human readable name
+			                          of this output, to be shown in the UI
+	                    - "backlight" (i): (readonly, use the specific interface)
+                                               the backlight value as a percentage
+                                               (-1 if not supported)
+			    - "primary" (b): whether this output is primary
+			                     or not
+			    - "presentation" (b): whether this output is
+			                          for presentation only
+			    Note: properties might be ignored if not consistently
+			    applied to all outputs in the same clone group. In
+			    general, it's expected that presentation or primary
+			    outputs will not be cloned.
+
+        A mode represents a set of parameters that are applied to
+	each output, such as resolution and refresh rate. It is a separate
+	object so that it can be referenced by CRTCs and outputs.
+	Multiple outputs in the same CRTCs must all have the same mode.
+	A mode is exposed as:
+	* u ID: the ID in the API
+	* x winsys_id: the low-level ID of this mode
+	* u width, height: the resolution
+	* d frequency: refresh rate
+        * u flags: mode flags as defined in xf86drmMode.h and randr.h
+
+        Output and modes are read-only objects (except for output properties),
+	they can change only in accordance to HW changes (such as hotplugging
+	a monitor), while CRTCs can be changed with ApplyConfiguration().
+
+        XXX: actually, if you insist enough, you can add new modes
+	through xrandr command line or the KMS API, overriding what the
+	kernel driver and the EDID say.
+	Usually, it only matters with old cards with broken drivers, or
+	old monitors with broken EDIDs, but it happens more often with
+	projectors (if for example the kernel driver doesn't add the
+	640x480 - 800x600 - 1024x768 default modes). Probably something
+	that we need to handle in mutter anyway.
+    -->
+    <method name="GetResources">
+      <arg name="serial" direction="out" type="u" />
+      <arg name="crtcs" direction="out" type="a(uxiiiiiuaua{sv})" />
+      <arg name="outputs" direction="out" type="a(uxiausauaua{sv})" />
+      <arg name="modes" direction="out" type="a(uxuudu)" />
+      <arg name="max_screen_width" direction="out" type="i" />
+      <arg name="max_screen_height" direction="out" type="i" />
+    </method>
+
+    <!--
+        ApplyConfiguration:
+	@serial: configuration serial
+	@persistent: whether this configuration should be saved on disk
+	@crtcs: new data for CRTCs
+	@outputs: new data for outputs
+
+	Applies the requested configuration changes.
+
+	@serial must match the serial from the last GetResources() call,
+	or org.freedesktop.DBus.AccessDenied will be generated.
+
+	If @persistent is true, mutter will attempt to replicate this
+	configuration the next time this HW layout appears.
+
+	@crtcs represents the new logical configuration, as a list
+	of structures containing:
+	- u ID: the API ID from the corresponding GetResources() call
+	- i new_mode: the API ID of the new mode to configure the CRTC
+	              with, or -1 if the CRTC should be disabled
+        - i x, y: the new coordinates of the top left corner
+	          the geometry will be completed with the size information
+		  from @new_mode
+        - u transform: the desired transform
+	- au outputs: the API ID of outputs that should be assigned to
+	              this CRTC
+        - a{sv} properties: properties whose value should be changed
+
+	Note: CRTCs not referenced in the array will be	disabled.
+
+	@outputs represent the output property changes as:
+	- u ID: the API ID of the output to change
+	- a{sv} properties: properties whose value should be changed
+
+	Note: both for CRTCs and outputs, properties not included in
+	the dictionary will not be changed.
+
+	Note: unrecognized properties will have no effect, but if the
+	configuration change succeeds the property will be reported
+	by the next GetResources() call, and if @persistent is true,
+	it will also be saved to disk.
+
+	If the configuration is invalid according to the previous
+	GetResources() call, for example because a CRTC references
+	an output it cannot drive, or not all outputs support the
+	chosen mode, the error org.freedesktop.DBus.InvalidArgs will
+	be generated.
+
+	If the configuration cannot be applied for any other reason
+	(eg. the screen size would exceed texture limits), the error
+	org.freedesktop.DBus.Error.LimitsExceeded will be generated.
+    -->
+    <method name="ApplyConfiguration">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="persistent" direction="in" type="b" />
+      <arg name="crtcs" direction="in" type="a(uiiiuaua{sv})" />
+      <arg name="outputs" direction="in" type="a(ua{sv})" />
+    </method>
+
+    <!--
+        ChangeBacklight:
+	@serial: configuration serial
+	@output: the API id of the output
+	@value: the new backlight value
+
+	Changes the backlight of @output to @value, which is
+	expressed as a percentage and rounded to the HW limits.
+
+        Returns the new value after rounding.
+    -->
+    <method name="ChangeBacklight">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="output" direction="in" type="u" />
+      <arg name="value" direction="in" type="i" />
+      <arg name="new_value" direction="out" type="i" />
+    </method>
+
+    <!--
+        GetCrtcGamma:
+	@serial: configuration serial
+	@crtc: API id of the crtc
+	@red: red gamma ramp
+	@green: green gamma ramp
+	@blue: blue gamma ramp
+
+	Requests the current gamma ramps of @crtc.
+    -->
+    <method name="GetCrtcGamma">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="crtc" direction="in" type="u" />
+      <arg name="red" direction="out" type="aq" />
+      <arg name="green" direction="out" type="aq" />
+      <arg name="blue" direction="out" type="aq" />
+    </method>
+
+    <!--
+        SetCrtcGamma:
+	@serial: configuration serial
+	@crtc: API id of the crtc
+	@red: red gamma ramp
+	@green: green gamma ramp
+	@blue: blue gamma ramp
+
+	Changes the gamma ramps of @crtc.
+    -->
+    <method name="SetCrtcGamma">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="crtc" direction="in" type="u" />
+      <arg name="red" direction="in" type="aq" />
+      <arg name="green" direction="in" type="aq" />
+      <arg name="blue" direction="in" type="aq" />
+    </method>
+
+    <!--
+        PowerSaveMode:
+
+	Contains the current power saving mode for the screen, and
+	allows changing it.
+
+        Possible values:
+	- 0: on
+	- 1: standby
+	- 2: suspend
+	- 3: off
+	- -1: unknown (unsupported)
+
+        A client should not attempt to change the powersave mode
+	from -1 (unknown) to any other value, and viceversa.
+	Note that the actual effects of the different values
+	depend on the hardware and the kernel driver in use, and
+	it's perfectly possible that all values different than on
+	have the same effect.
+	Also, setting the PowerSaveMode to 3 (off) may or may
+	not have the same effect as disabling all outputs by
+	setting no CRTC on them with ApplyConfiguration(), and
+	may or may not cause a configuration change.
+
+        Also note that this property might become out of date
+	if changed through different means (for example using the
+	XRandR interface directly).
+    -->
+    <property name="PowerSaveMode" type="i" access="readwrite" />
+
+    <!--
+        PanelOrientationManaged:
+
+        Whether the built-in panel orientation is automatically managed
+        by mutter.
+    -->
+    <property name="PanelOrientationManaged" type="b" access="read" />
+
+    <!--
+        ApplyMonitorsConfigAllowed:
+
+        Whether calling the ApplyMonitorsConfig method is allowed.
+    -->
+    <property name="ApplyMonitorsConfigAllowed" type="b" access="read" />
+
+    <!--
+        NightLightSupported:
+
+        Whether night light is supported by this system.
+    -->
+    <property name="NightLightSupported" type="b" access="read" />
+
+    <!--
+        MonitorsChanged:
+
+	The signal is emitted every time the screen configuration
+	changes.
+	The client should then call GetResources() to read the new layout.
+    -->
+    <signal name="MonitorsChanged" />
+
+    <!--
+	GetCurrentState:
+	@serial: configuration serial
+	@monitors: available monitors
+	@logical_monitors: current logical monitor configuration
+	@properties: display configuration properties
+
+	@monitors represent connected physical monitors
+
+	* s connector: connector name (e.g. HDMI-1, DP-1, etc)
+	* s vendor: vendor name
+	* s product: product name
+	* s serial: product serial
+	* a(siiddada{sv}) modes: available modes
+	    * s id: mode ID
+	    * i width: width in physical pixels
+	    * i height: height in physical pixels
+	    * d refresh rate: refresh rate
+	    * d preferred scale: scale preferred as per calculations
+	    * ad supported scales: scales supported by this mode
+	    * a{sv} properties: optional properties, including:
+	       - "is-current" (b): the mode is currently active mode
+	       - "is-preferred" (b): the mode is the preferred mode
+	       - "is-interlaced" (b): the mode is an interlaced mode
+	* a{sv} properties: optional properties, including:
+	    - "width-mm" (i): physical width of monitor in millimeters
+	    - "height-mm" (i): physical height of monitor in millimeters
+	    - "is-underscanning" (b): whether underscanning is enabled
+				      (absence of this means underscanning
+				      not being supported)
+	    - "is-vrr-allowed" (b): whether variable refresh rate is allowed
+	                            (absence of this means variable refresh
+	                            rate not being supported)
+
+	    - "max-screen-size" (ii): the maximum size a screen may have
+				      (absence of this means unlimited screen
+				      size)
+	    - "is-builtin" (b): whether the monitor is built in, e.g. a
+				laptop panel (absence of this means it is
+				not built in)
+	    - "display-name" (s): a human readable display name of the monitor
+	    - "privacy-screen-state" (bb): the state of the privacy screen
+				     (absence of this means it is not being
+				     supported) first value indicates whether
+				     it's enabled and second value whether it's
+				     hardware locked (and so can't be changed
+				     via gsettings)
+
+        Possible mode flags:
+	  1 : preferred mode
+	  2 : current mode
+
+
+	@logical_monitors represent current logical monitor configuration
+
+	* i x: x position
+	* i y: y position
+	* d scale: scale
+	* u transform: transform (see below)
+	* b primary: true if this is the primary logical monitor
+	* a(sss) monitors: monitors displaying this logical monitor
+	    * connector: name of the connector (e.g. DP-1, eDP-1 etc)
+	    * vendor: vendor name
+	    * product: product name
+	    * serial: product serial
+	* a{sv} properties: possibly other properties
+
+	Posisble transform values:
+	  0: normal
+	  1: 90°
+	  2: 180°
+	  3: 270°
+	  4: flipped
+	  5: 90° flipped
+	  6: 180° flipped
+	  7: 270° flipped
+
+
+	@layout_mode current layout mode represents the way logical monitors
+	are laid out on the screen. Possible modes include:
+
+	  1 : physical
+	  2 : logical
+
+	With physical layout mode, each logical monitor has the same dimensions
+	as the monitor modes of the associated monitors assigned to it, no
+	matter what scale is in use.
+
+	With logical mode, the dimension of a logical monitor is the dimension
+	of the monitor mode, divided by the logical monitor scale.
+
+
+	Possible @properties are:
+
+	* "layout-mode" (u): Represents in what way logical monitors are laid
+			     out on the screen. The layout mode can be either
+			     of the ones listed below. Absence of this property
+			     means the layout mode cannot be changed, and that
+			     "logical" mode is assumed to be used.
+	    * 1 : logical  - the dimension of a logical monitor is derived from
+			     the monitor modes associated with it, then scaled
+			     using the logical monitor scale.
+	    * 2 : physical - the dimension of a logical monitor is derived from
+			     the monitor modes associated with it.
+	* "supports-changing-layout-mode" (b): True if the layout mode can be
+					       changed. Absence of this means the
+					       layout mode cannot be changed.
+	* "global-scale-required" (b): True if all the logical monitors must
+				       always use the same scale. Absence of
+				       this means logical monitor scales can
+				       differ.
+	* "legacy-ui-scaling-factor" (i): The legacy scaling factor traditionally
+				          used to scale X11 clients (commonly
+					  communicated via the
+					  Gdk/WindowScalingFactor XSetting entry).
+    -->
+    <method name="GetCurrentState">
+      <arg name="serial" direction="out" type="u" />
+      <arg name="monitors" direction="out" type="a((ssss)a(siiddada{sv})a{sv})" />
+      <arg name="logical_monitors" direction="out" type="a(iiduba(ssss)a{sv})" />
+      <arg name="properties" direction="out" type="a{sv}" />
+    </method>
+
+    <!--
+	ApplyMonitorsConfig:
+	@serial: configuration serial
+	@method: configuration method
+	@logical_monitors: monitors configuration
+	@properties: properties
+
+	@method represents the way the configuration should be handled.
+
+	Possible methods:
+	  0: verify
+	  1: temporary
+	  2: persistent
+
+	@logical_monitors consists of a list of logical monitor configurations.
+	Each logical monitor configuration consists of:
+
+	* i: layout x position
+	* i: layout y position
+	* d: scale
+	* u: transform (see GetCurrentState)
+	* b primary: true if this is the primary logical monitor
+	* a(ssa{sv}): a list of monitors, each consisting of:
+	    * s: connector
+	    * s: monitor mode ID
+	    * a{sv}: monitor properties, including:
+	        - "enable_underscanning" (b): enable monitor underscanning;
+					      may only be set when underscanning
+					      is supported (see GetCurrentState).
+	        - "allow_vrr" (b): whether to allow variable refresh rate; may
+	                           only be set when variable refresh rate is
+	                           supported (see GetCurrentState).
+
+	@properties may effect the global monitor configuration state. Possible
+	properties are:
+
+	* "layout-mode" (u): layout mode the passed configuration is in; may
+			     only be set when changing the layout mode is
+			     supported (see GetCurrentState).
+    -->
+    <method name="ApplyMonitorsConfig">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="method" direction="in" type="u" />
+      <arg name="logical_monitors" direction="in" type="a(iiduba(ssa{sv}))" />
+      <arg name="properties" direction="in" type="a{sv}" />
+    </method>
+
+    <!--
+        SetOutputCTM:
+        @serial: configuration serial
+        @output: API id of the output
+        @ctm: 3x3 matrix in fixed-point sign-magnitude S31.32
+
+        Changes the color transform matrix of @output
+    -->
+    <method name="SetOutputCTM">
+      <arg name="serial" direction="in" type="u" />
+      <arg name="output" direction="in" type="u" />
+      <arg name="ctm" direction="in" type="(ttttttttt)" />
+    </method>
+  </interface>
+</node>
diff '--color=auto' -uraN a/data/meson.build b/data/meson.build
--- a/data/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/data/meson.build	2023-10-12 20:59:22.707167662 +0300
@@ -41,6 +41,13 @@
   install_dir: schemadir
 )
 
+configure_file(
+  input: 'org.gnome.mutter.x11.gschema.xml.in',
+  output: 'org.gnome.mutter.x11.gschema.xml',
+  configuration: gschema_config,
+  install_dir: schemadir
+)
+
 install_data(['mutter-schemas.convert'],
   install_dir: datadir / 'GConf/gsettings',
 )
diff '--color=auto' -uraN a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
--- a/data/org.gnome.mutter.gschema.xml.in	2023-09-16 23:51:03.000000000 +0300
+++ b/data/org.gnome.mutter.gschema.xml.in	2023-10-12 20:59:22.707167662 +0300
@@ -5,6 +5,7 @@
     <value nick="kms-modifiers" value="2"/>
     <value nick="rt-scheduler" value="4"/>
     <value nick="autoclose-xwayland" value="8"/>
+    <value nick="variable-refresh-rate" value="16"/>
   </flags>
 
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
@@ -103,7 +104,7 @@
 
     <key name="experimental-features"
         flags='org.gnome.mutter.MetaExperimentalFeature'>
-      <default>[]</default>
+      <default>["variable-refresh-rate"]</default>
       <summary>Enable experimental features</summary>
       <description>
         To enable experimental features, add the feature keyword to the list.
@@ -133,6 +134,16 @@
                                         relevant X11 clients are gone.
                                         Requires a restart.
 
+        • “variable-refresh-rate”     — makes mutter dynamically adjust the
+                                        refresh rate of the monitor when
+                                        applicable if supported by the monitor,
+                                        GPU and DRM driver. Configurable in
+                                        Settings. Requires a restart.
+
+        • “x11-randr-fractional-scaling” — enable fractional scaling under X11
+                                           using xrandr scaling. It might reduce
+                                           performances.
+                                           Does not require a restart.
       </description>
     </key>
 
diff '--color=auto' -uraN a/data/org.gnome.mutter.gschema.xml.in.orig b/data/org.gnome.mutter.gschema.xml.in.orig
--- a/data/org.gnome.mutter.gschema.xml.in.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/data/org.gnome.mutter.gschema.xml.in.orig	2023-10-12 20:59:22.670500538 +0300
@@ -0,0 +1,195 @@
+<schemalist>
+
+  <flags id="org.gnome.mutter.MetaExperimentalFeature">
+    <value nick="scale-monitor-framebuffer" value="1"/>
+    <value nick="kms-modifiers" value="2"/>
+    <value nick="rt-scheduler" value="4"/>
+    <value nick="autoclose-xwayland" value="8"/>
+    <value nick="variable-refresh-rate" value="16"/>
+  </flags>
+
+  <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
+          gettext-domain="@GETTEXT_DOMAIN@">
+
+    <key name="overlay-key" type="s">
+      <default>'Super_L'</default>
+      <summary>Modifier to use for extended window management operations</summary>
+      <description>
+        This key will initiate the “overlay”, which is a combination window
+        overview and application launching system.  The default is intended
+        to be the “Windows key” on PC hardware.
+
+        It’s expected that this binding either the default or set to
+        the empty string.
+      </description>
+    </key>
+
+    <key name="attach-modal-dialogs" type="b">
+      <default>false</default>
+      <summary>Attach modal dialogs</summary>
+      <description>
+        When true, instead of having independent titlebars, modal dialogs
+        appear attached to the titlebar of the parent window and are moved
+        together with the parent window.
+      </description>
+    </key>
+
+    <key name="edge-tiling" type="b">
+      <default>false</default>
+      <summary>Enable edge tiling when dropping windows on screen edges</summary>
+      <description>
+        If enabled, dropping windows on vertical screen edges maximizes them
+        vertically and resizes them horizontally to cover half of the available
+        area. Dropping windows on the top screen edge maximizes them completely.
+      </description>
+    </key>
+
+    <key name="dynamic-workspaces" type="b">
+      <default>false</default>
+      <summary>Workspaces are managed dynamically</summary>
+      <description>
+        Determines whether workspaces are managed dynamically or
+        whether there’s a static number of workspaces (determined
+        by the num-workspaces key in org.gnome.desktop.wm.preferences).
+      </description>
+    </key>
+
+    <key name="workspaces-only-on-primary" type="b">
+      <default>false</default>
+      <summary>Workspaces only on primary</summary>
+      <description>
+        Determines whether workspace switching should happen for windows
+        on all monitors or only for windows on the primary monitor.
+      </description>
+    </key>
+
+    <key name="focus-change-on-pointer-rest" type="b">
+      <default>false</default>
+      <summary>Delay focus changes until the pointer stops moving</summary>
+      <description>
+        If set to true, and the focus mode is either “sloppy” or “mouse”
+        then the focus will not be changed immediately when entering a
+        window, but only after the pointer stops moving.
+      </description>
+    </key>
+
+    <key name="draggable-border-width" type="i">
+      <default>10</default>
+      <range min="0" max="64"/>
+      <summary>Draggable border width</summary>
+      <description>
+          The amount of total draggable borders. If the theme’s visible
+          borders are not enough, invisible borders will be added to meet
+          this value.
+      </description>
+    </key>
+
+    <key name="auto-maximize" type="b">
+      <default>true</default>
+      <summary>Auto maximize nearly monitor sized windows</summary>
+      <description>
+        If enabled, new windows that are initially the size of the monitor
+        automatically get maximized.
+      </description>
+    </key>
+
+    <key name="center-new-windows" type="b">
+      <default>false</default>
+      <summary>Place new windows in the center</summary>
+      <description>
+        When true, the new windows will always be put in the center of the
+        active screen of the monitor.
+      </description>
+    </key>
+
+    <key name="experimental-features"
+        flags='org.gnome.mutter.MetaExperimentalFeature'>
+      <default>["variable-refresh-rate"]</default>
+      <summary>Enable experimental features</summary>
+      <description>
+        To enable experimental features, add the feature keyword to the list.
+        Whether the feature requires restarting the compositor depends on the
+        given feature. Any experimental feature is not required to still be
+        available, or configurable. Don’t expect adding anything in this
+        setting to be future proof.
+
+        Currently possible keywords:
+
+        • “scale-monitor-framebuffer” — makes mutter default to layout logical
+                                        monitors in a logical pixel coordinate
+                                        space, while scaling monitor
+                                        framebuffers instead of window content,
+                                        to manage HiDPI monitors. Does not
+                                        require a restart.
+
+        • “kms-modifiers”             — makes mutter always allocate scanout
+                                        buffers with explicit modifiers, if
+                                        supported by the driver. Requires a
+                                        restart.
+
+        • “rt-scheduler”              — makes mutter request a low priority
+                                        real-time scheduling. Requires a restart.
+
+        • “autoclose-xwayland”        — automatically terminates Xwayland if all
+                                        relevant X11 clients are gone.
+                                        Requires a restart.
+
+        • “variable-refresh-rate”     — makes mutter dynamically adjust the
+                                        refresh rate of the monitor when
+                                        applicable if supported by the monitor,
+                                        GPU and DRM driver. Configurable in
+                                        Settings. Requires a restart.
+
+      </description>
+    </key>
+
+    <key name="locate-pointer-key" type="s">
+      <default>'Control_L'</default>
+      <summary>Modifier to use to locate the pointer</summary>
+      <description>
+        This key will initiate the “locate pointer” action.
+      </description>
+    </key>
+
+    <key name="check-alive-timeout" type="u">
+      <default>5000</default>
+      <summary>Timeout for check-alive ping</summary>
+      <description>
+        Number of milliseconds a client has to respond to a ping request in
+        order to not be detected as frozen. Using 0 will disable the alive check
+        completely.
+      </description>
+    </key>
+
+    <child name="keybindings" schema="org.gnome.mutter.keybindings"/>
+
+  </schema>
+  <schema id="org.gnome.mutter.keybindings" path="/org/gnome/mutter/keybindings/">
+
+    <key name="toggle-tiled-left" type="as">
+      <default><![CDATA[['<Super>Left']]]></default>
+      <summary>View split on left</summary>
+    </key>
+
+    <key name="toggle-tiled-right" type="as">
+      <default><![CDATA[['<Super>Right']]]></default>
+      <summary>View split on right</summary>
+    </key>
+
+    <key name="switch-monitor" type="as">
+      <default><![CDATA[['<Super>p','XF86Display']]]></default>
+      <summary>Switch monitor configurations</summary>
+    </key>
+
+    <key name="rotate-monitor" type="as">
+      <default><![CDATA[['XF86RotateWindows']]]></default>
+      <summary>Rotates the built-in monitor configuration</summary>
+    </key>
+
+    <key name="cancel-input-capture" type="as">
+      <default><![CDATA[['<Super><Shift>Escape']]]></default>
+      <summary>Cancel any active input capture session</summary>
+    </key>
+
+  </schema>
+</schemalist>
diff '--color=auto' -uraN a/data/org.gnome.mutter.gschema.xml.in.rej b/data/org.gnome.mutter.gschema.xml.in.rej
--- a/data/org.gnome.mutter.gschema.xml.in.rej	1970-01-01 02:00:00.000000000 +0200
+++ b/data/org.gnome.mutter.gschema.xml.in.rej	2023-10-12 20:59:22.707167662 +0300
@@ -0,0 +1,12 @@
+--- data/org.gnome.mutter.gschema.xml.in
++++ data/org.gnome.mutter.gschema.xml.in
+@@ -101,8 +101,7 @@
+       </description>
+     </key>
+ 
+-    <key name="experimental-features"
+-        flags='org.gnome.mutter.MetaExperimentalFeature'>
++    <key name="experimental-features" type="as">
+       <default>[]</default>
+       <summary>Enable experimental features</summary>
+       <description>
diff '--color=auto' -uraN a/data/org.gnome.mutter.x11.gschema.xml.in b/data/org.gnome.mutter.x11.gschema.xml.in
--- a/data/org.gnome.mutter.x11.gschema.xml.in	1970-01-01 02:00:00.000000000 +0200
+++ b/data/org.gnome.mutter.x11.gschema.xml.in	2023-10-12 20:59:22.707167662 +0300
@@ -0,0 +1,30 @@
+<schemalist>
+
+  <enum id="org.gnome.mutter.X11.scale-mode">
+    <value nick="scale-up" value="1"/>
+    <value nick="scale-ui-down" value="2"/>
+  </enum>
+
+  <schema id="org.gnome.mutter.x11" path="/org/gnome/mutter/x11/"
+          gettext-domain="@GETTEXT_DOMAIN@">
+
+    <key name="fractional-scale-mode" enum="org.gnome.mutter.X11.scale-mode">
+      <default>"scale-ui-down"</default>
+      <description>
+        Choose the scaling mode to be used under X11 via Randr extension.
+
+        Supported methods are:
+
+        • “scale-up”     — Scale everything up to the requested scale, shrinking
+                           the UI. The applications will look blurry when scaling
+                           at higher values and the resolution will be lowered.
+        • “scale-ui-down — Scale up the UI toolkits to the closest integer
+                           scaling value upwards, while scale down the display
+                           to match the requested scaling level.
+                           It increases the resolution of the logical display.
+      </description>
+    </key>
+
+  </schema>
+
+</schemalist>
diff '--color=auto' -uraN a/meson.build b/meson.build
--- a/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/meson.build	2023-10-12 20:59:22.700500912 +0300
@@ -398,7 +398,7 @@
 
   add_test_setup('plain')
 
-  xvfb = find_program('xvfb-run')
+  xvfb = find_program('xvfb-run', required: false)
   xvfb_args = [
     '-a',
     '-s',
diff '--color=auto' -uraN a/src/backends/meta-crtc.c b/src/backends/meta-crtc.c
--- a/src/backends/meta-crtc.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-crtc.c	2023-10-12 20:59:22.707167662 +0300
@@ -125,6 +125,7 @@
   config->layout = *layout;
   config->mode = mode;
   config->transform = transform;
+  config->scale = 1.0f;
 
   priv->config = config;
 }
@@ -289,6 +290,26 @@
                  gamma->size * sizeof (uint16_t)) == 0;
 }
 
+void
+meta_crtc_set_config_scale (MetaCrtc *crtc,
+                            float    scale)
+{
+  MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+
+  g_return_if_fail (scale > 0);
+
+  if (priv->config)
+    priv->config->scale = scale;
+}
+
+float
+meta_crtc_get_config_scale (MetaCrtc *crtc)
+{
+  MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+
+  return priv->config ? priv->config->scale : 1.0f;
+}
+
 static void
 meta_crtc_set_property (GObject      *object,
                         guint         prop_id,
diff '--color=auto' -uraN a/src/backends/meta-crtc.h b/src/backends/meta-crtc.h
--- a/src/backends/meta-crtc.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-crtc.h	2023-10-12 20:59:22.707167662 +0300
@@ -30,6 +30,7 @@
   graphene_rect_t layout;
   MetaMonitorTransform transform;
   MetaCrtcMode *mode;
+  float scale;
 } MetaCrtcConfig;
 
 #define META_TYPE_CRTC (meta_crtc_get_type ())
@@ -75,6 +76,11 @@
                            MetaCrtcMode         *mode,
                            MetaMonitorTransform  transform);
 
+void meta_crtc_set_config_scale (MetaCrtc *crtc,
+                                 float    scale);
+
+float meta_crtc_get_config_scale (MetaCrtc *crtc);
+
 META_EXPORT_TEST
 void meta_crtc_unset_config (MetaCrtc *crtc);
 
diff '--color=auto' -uraN a/src/backends/meta-egl.c b/src/backends/meta-egl.c
--- a/src/backends/meta-egl.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-egl.c	2023-10-12 20:59:22.720501162 +0300
@@ -238,6 +238,14 @@
   return has_extensions;
 }
 
+const char *
+meta_egl_query_string (MetaEgl    *egl,
+                       EGLDisplay  display,
+                       EGLint      name)
+{
+  return eglQueryString (display, name);
+}
+
 gboolean
 meta_egl_initialize (MetaEgl   *egl,
                      EGLDisplay display,
diff '--color=auto' -uraN a/src/backends/meta-egl.h b/src/backends/meta-egl.h
--- a/src/backends/meta-egl.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-egl.h	2023-10-12 20:59:22.720501162 +0300
@@ -47,6 +47,10 @@
                                   const char   *first_extension,
                                   ...);
 
+const char * meta_egl_query_string (MetaEgl    *egl,
+                                    EGLDisplay  display,
+                                    EGLint      name);
+
 gboolean meta_egl_initialize (MetaEgl   *egl,
                               EGLDisplay display,
                               GError   **error);
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
--- a/src/backends/meta-monitor-config-manager.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-manager.c	2023-10-12 20:59:22.707167662 +0300
@@ -216,6 +216,18 @@
   else
     crtc_hw_transform = META_MONITOR_TRANSFORM_NORMAL;
 
+  scale = data->logical_monitor_config->scale;
+  if (!meta_monitor_manager_is_scale_supported (data->monitor_manager,
+                                                data->config->layout_mode,
+                                                monitor, mode, scale))
+    {
+      scale = roundf (scale);
+      if (!meta_monitor_manager_is_scale_supported (data->monitor_manager,
+                                                    data->config->layout_mode,
+                                                    monitor, mode, scale))
+        scale = 1.0;
+    }
+
   meta_monitor_calculate_crtc_pos (monitor, mode, output, crtc_transform,
                                    &crtc_x, &crtc_y);
 
@@ -230,6 +242,8 @@
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       scale = 1.0;
       break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      break;
     }
 
   crtc_mode = monitor_crtc_mode->crtc_mode;
@@ -257,6 +271,7 @@
     .mode = crtc_mode,
     .layout = crtc_layout,
     .transform = crtc_hw_transform,
+    .scale = scale,
     .outputs = g_ptr_array_new ()
   };
   g_ptr_array_add (crtc_assignment->outputs, output);
@@ -285,6 +300,7 @@
     .is_primary = assign_output_as_primary,
     .is_presentation = assign_output_as_presentation,
     .is_underscanning = data->monitor_config->enable_underscanning,
+    .is_vrr_disallowed = data->monitor_config->disallow_vrr,
     .has_max_bpc = data->monitor_config->has_max_bpc,
     .max_bpc = data->monitor_config->max_bpc
   };
@@ -691,7 +707,8 @@
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = meta_monitor_spec_clone (monitor_spec),
     .mode_spec = g_memdup2 (mode_spec, sizeof (MetaMonitorModeSpec)),
-    .enable_underscanning = meta_monitor_is_underscanning (monitor)
+    .enable_underscanning = meta_monitor_is_underscanning (monitor),
+    .disallow_vrr = meta_monitor_is_vrr_disallowed (monitor),
   };
 
   monitor_config->has_max_bpc =
@@ -722,6 +739,7 @@
 static void
 scale_logical_monitor_width (MetaLogicalMonitorLayoutMode  layout_mode,
                              float                         scale,
+                             float                         max_scale,
                              int                           mode_width,
                              int                           mode_height,
                              int                          *width,
@@ -733,6 +751,13 @@
       *width = (int) roundf (mode_width / scale);
       *height = (int) roundf (mode_height / scale);
       return;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      {
+        float ui_scale = scale / ceilf (max_scale);
+        *width = (int) roundf (mode_width / ui_scale);
+        *height = (int) roundf (mode_height / ui_scale);
+      }
+      return;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       *width = mode_width;
       *height = mode_height;
@@ -742,12 +767,37 @@
   g_assert_not_reached ();
 }
 
+static float
+get_preferred_preferred_max_scale (MetaMonitorManager           *monitor_manager,
+                                   GList                        *monitors,
+                                   MetaLogicalMonitorLayoutMode  layout_mode)
+{
+  float scale = 1.0;
+  GList *l;
+
+  for (l = monitors; l; l = l->next)
+    {
+      float s;
+      MetaMonitor *monitor = l->data;
+      MetaMonitorMode *mode = meta_monitor_get_preferred_mode (monitor);
+
+      s = meta_monitor_manager_calculate_monitor_mode_scale (monitor_manager,
+                                                             layout_mode,
+                                                             monitor,
+                                                             mode);
+      scale = MAX (scale, s);
+    }
+
+  return scale;
+}
+
 static MetaLogicalMonitorConfig *
 create_preferred_logical_monitor_config (MetaMonitorManager          *monitor_manager,
                                          MetaMonitor                 *monitor,
                                          int                          x,
                                          int                          y,
                                          float                        scale,
+                                         float                        max_scale,
                                          MetaLogicalMonitorLayoutMode layout_mode)
 {
   MetaMonitorMode *mode;
@@ -758,7 +808,7 @@
 
   mode = meta_monitor_get_preferred_mode (monitor);
   meta_monitor_mode_get_resolution (mode, &width, &height);
-  scale_logical_monitor_width (layout_mode, scale,
+  scale_logical_monitor_width (layout_mode, scale, max_scale,
                                width, height, &width, &height);
 
   monitor_config = create_monitor_config (monitor, mode);
@@ -937,6 +987,7 @@
   MetaMonitor *primary_monitor;
   MetaLogicalMonitorLayoutMode layout_mode;
   float scale;
+  float max_scale = 1.0;
   GList *l;
   int x, y;
 
@@ -956,6 +1007,10 @@
    */
   monitors = g_list_prepend (monitors, primary_monitor);
 
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    max_scale = get_preferred_preferred_max_scale (monitor_manager, monitors,
+                                                   layout_mode);
+
   for (l = monitors; l; l = l->next)
     {
       MetaMonitor *monitor = l->data;
@@ -979,6 +1034,7 @@
         create_preferred_logical_monitor_config (monitor_manager,
                                                  monitor,
                                                  x, y, scale,
+                                                 max_scale,
                                                  layout_mode);
       logical_monitor_config->is_primary = (monitor == primary_monitor);
       logical_monitor_configs = g_list_append (logical_monitor_configs,
@@ -1045,6 +1101,7 @@
         .mode_spec = g_memdup2 (monitor_config_in->mode_spec,
                                 sizeof (MetaMonitorModeSpec)),
         .enable_underscanning = monitor_config_in->enable_underscanning,
+        .disallow_vrr = monitor_config_in->disallow_vrr,
         .has_max_bpc = monitor_config_in->has_max_bpc,
         .max_bpc = monitor_config_in->max_bpc
       };
@@ -1224,6 +1281,39 @@
                                               META_MONITOR_TRANSFORM_NORMAL);
 }
 
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_layout (MetaMonitorConfigManager     *config_manager,
+                                               MetaMonitorsConfig           *config,
+                                               MetaLogicalMonitorLayoutMode  layout_mode)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  GList *logical_monitor_configs;
+  GList *l;
+
+  if (!config)
+    return NULL;
+
+  if (config->layout_mode == layout_mode)
+    return g_object_ref (config);
+
+  logical_monitor_configs =
+    clone_logical_monitor_config_list (config->logical_monitor_configs);
+
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL)
+    {
+      for (l = logical_monitor_configs; l; l = l->next)
+        {
+          MetaLogicalMonitorConfig *monitor_config = l->data;
+          monitor_config->scale = roundf (monitor_config->scale);
+        }
+    }
+
+  return meta_monitors_config_new (monitor_manager,
+                                   logical_monitor_configs,
+                                   layout_mode,
+                                   META_MONITORS_CONFIG_FLAG_NONE);
+}
+
 static MetaMonitorsConfig *
 create_monitors_switch_config (MetaMonitorConfigManager    *config_manager,
                                MonitorMatchRule             match_rule,
@@ -1254,6 +1344,7 @@
   GList *monitor_configs = NULL;
   gint common_mode_w = 0, common_mode_h = 0;
   float best_scale = 1.0;
+  float max_scale = 1.0;
   MetaMonitor *monitor;
   GList *modes;
   GList *monitors;
@@ -1345,7 +1436,11 @@
       monitor_configs = g_list_prepend (monitor_configs, create_monitor_config (monitor, mode));
     }
 
-  scale_logical_monitor_width (layout_mode, best_scale,
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    max_scale = get_preferred_preferred_max_scale (monitor_manager, monitors,
+                                                   layout_mode);
+
+  scale_logical_monitor_width (layout_mode, best_scale, max_scale,
                                common_mode_w, common_mode_h,
                                &width, &height);
 
@@ -1815,6 +1910,7 @@
 meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
                                     MetaLogicalMonitorLayoutMode layout_mode,
                                     MetaMonitorManager          *monitor_manager,
+                                    float                        max_scale,
                                     GError                     **error)
 {
   GList *l;
@@ -1851,6 +1947,10 @@
 
   switch (layout_mode)
     {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      expected_mode_width /= ceilf (max_scale);
+      expected_mode_height /= ceilf (max_scale);
+      /* fall through! */
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
       expected_mode_width = roundf (expected_mode_width *
                                     logical_monitor_config->scale);
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-manager.c.orig b/src/backends/meta-monitor-config-manager.c.orig
--- a/src/backends/meta-monitor-config-manager.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor-config-manager.c.orig	2023-10-12 20:59:22.670500538 +0300
@@ -0,0 +1,2051 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2016 Red Hat
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/meta-monitor-config-manager.h"
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-monitor-config-migration.h"
+#include "backends/meta-monitor-config-store.h"
+#include "backends/meta-monitor-manager-private.h"
+#include "backends/meta-output.h"
+#include "core/boxes-private.h"
+#include "meta/meta-monitor-manager.h"
+
+#define CONFIG_HISTORY_MAX_SIZE 3
+
+struct _MetaMonitorConfigManager
+{
+  GObject parent;
+
+  MetaMonitorManager *monitor_manager;
+
+  MetaMonitorConfigStore *config_store;
+
+  MetaMonitorsConfig *current_config;
+  GQueue config_history;
+};
+
+G_DEFINE_TYPE (MetaMonitorConfigManager, meta_monitor_config_manager,
+               G_TYPE_OBJECT)
+
+G_DEFINE_TYPE (MetaMonitorsConfig, meta_monitors_config,
+               G_TYPE_OBJECT)
+
+static void
+meta_crtc_assignment_free (MetaCrtcAssignment *assignment);
+
+static void
+meta_output_assignment_free (MetaOutputAssignment *assignment);
+
+MetaMonitorConfigManager *
+meta_monitor_config_manager_new (MetaMonitorManager *monitor_manager)
+{
+  MetaMonitorConfigManager *config_manager;
+
+  config_manager = g_object_new (META_TYPE_MONITOR_CONFIG_MANAGER, NULL);
+  config_manager->monitor_manager = monitor_manager;
+  config_manager->config_store =
+    meta_monitor_config_store_new (monitor_manager);
+
+  return config_manager;
+}
+
+MetaMonitorConfigStore *
+meta_monitor_config_manager_get_store (MetaMonitorConfigManager *config_manager)
+{
+  return config_manager->config_store;
+}
+
+static gboolean
+is_crtc_reserved (MetaCrtc *crtc,
+                  GArray   *reserved_crtcs)
+{
+  unsigned int i;
+
+  for (i = 0; i < reserved_crtcs->len; i++)
+    {
+       uint64_t id;
+
+       id = g_array_index (reserved_crtcs, uint64_t, i);
+       if (id == meta_crtc_get_id (crtc))
+         return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+is_crtc_assigned (MetaCrtc  *crtc,
+                  GPtrArray *crtc_assignments)
+{
+  unsigned int i;
+
+  for (i = 0; i < crtc_assignments->len; i++)
+    {
+      MetaCrtcAssignment *assigned_crtc_assignment =
+        g_ptr_array_index (crtc_assignments, i);
+
+      if (assigned_crtc_assignment->crtc == crtc)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static MetaCrtc *
+find_unassigned_crtc (MetaOutput *output,
+                      GPtrArray  *crtc_assignments,
+                      GArray     *reserved_crtcs)
+{
+  MetaCrtc *crtc;
+  const MetaOutputInfo *output_info;
+  unsigned int i;
+
+  crtc = meta_output_get_assigned_crtc (output);
+  if (crtc && !is_crtc_assigned (crtc, crtc_assignments))
+    return crtc;
+
+  output_info = meta_output_get_info (output);
+
+  /* then try to assign a CRTC that wasn't used */
+  for (i = 0; i < output_info->n_possible_crtcs; i++)
+    {
+      crtc = output_info->possible_crtcs[i];
+
+      if (is_crtc_assigned (crtc, crtc_assignments))
+        continue;
+
+      if (is_crtc_reserved (crtc, reserved_crtcs))
+        continue;
+
+      return crtc;
+    }
+
+  /* finally just give a CRTC that we haven't assigned */
+  for (i = 0; i < output_info->n_possible_crtcs; i++)
+    {
+      crtc = output_info->possible_crtcs[i];
+
+      if (is_crtc_assigned (crtc, crtc_assignments))
+        continue;
+
+      return crtc;
+    }
+
+  return NULL;
+}
+
+typedef struct
+{
+  MetaMonitorManager *monitor_manager;
+  MetaMonitorsConfig *config;
+  MetaLogicalMonitorConfig *logical_monitor_config;
+  MetaMonitorConfig *monitor_config;
+  GPtrArray *crtc_assignments;
+  GPtrArray *output_assignments;
+  GArray *reserved_crtcs;
+} MonitorAssignmentData;
+
+static gboolean
+assign_monitor_crtc (MetaMonitor         *monitor,
+                     MetaMonitorMode     *mode,
+                     MetaMonitorCrtcMode *monitor_crtc_mode,
+                     gpointer             user_data,
+                     GError             **error)
+{
+  MonitorAssignmentData *data = user_data;
+  MetaOutput *output;
+  MetaCrtc *crtc;
+  MetaMonitorTransform transform;
+  MetaMonitorTransform crtc_transform;
+  MetaMonitorTransform crtc_hw_transform;
+  int crtc_x, crtc_y;
+  float x_offset, y_offset;
+  float scale = 0.0;
+  float width, height;
+  MetaCrtcMode *crtc_mode;
+  const MetaCrtcModeInfo *crtc_mode_info;
+  graphene_rect_t crtc_layout;
+  MetaCrtcAssignment *crtc_assignment;
+  MetaOutputAssignment *output_assignment;
+  MetaMonitorConfig *first_monitor_config;
+  gboolean assign_output_as_primary;
+  gboolean assign_output_as_presentation;
+
+  output = monitor_crtc_mode->output;
+
+  crtc = find_unassigned_crtc (output,
+                               data->crtc_assignments,
+                               data->reserved_crtcs);
+
+  if (!crtc)
+    {
+      MetaMonitorSpec *monitor_spec = meta_monitor_get_spec (monitor);
+
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "No available CRTC for monitor '%s %s' not found",
+                   monitor_spec->vendor, monitor_spec->product);
+      return FALSE;
+    }
+
+  transform = data->logical_monitor_config->transform;
+  crtc_transform = meta_monitor_logical_to_crtc_transform (monitor, transform);
+  if (meta_monitor_manager_is_transform_handled (data->monitor_manager,
+                                                 crtc,
+                                                 crtc_transform))
+    crtc_hw_transform = crtc_transform;
+  else
+    crtc_hw_transform = META_MONITOR_TRANSFORM_NORMAL;
+
+  meta_monitor_calculate_crtc_pos (monitor, mode, output, crtc_transform,
+                                   &crtc_x, &crtc_y);
+
+  x_offset = data->logical_monitor_config->layout.x;
+  y_offset = data->logical_monitor_config->layout.y;
+
+  switch (data->config->layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      scale = data->logical_monitor_config->scale;
+      break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      scale = 1.0;
+      break;
+    }
+
+  crtc_mode = monitor_crtc_mode->crtc_mode;
+  crtc_mode_info = meta_crtc_mode_get_info (monitor_crtc_mode->crtc_mode);
+
+  if (meta_monitor_transform_is_rotated (crtc_transform))
+    {
+      width = crtc_mode_info->height / scale;
+      height = crtc_mode_info->width / scale;
+    }
+  else
+    {
+      width = crtc_mode_info->width / scale;
+      height = crtc_mode_info->height / scale;
+    }
+
+  crtc_layout = GRAPHENE_RECT_INIT (x_offset + (crtc_x / scale),
+                                    y_offset + (crtc_y / scale),
+                                    width,
+                                    height);
+
+  crtc_assignment = g_new0 (MetaCrtcAssignment, 1);
+  *crtc_assignment = (MetaCrtcAssignment) {
+    .crtc = crtc,
+    .mode = crtc_mode,
+    .layout = crtc_layout,
+    .transform = crtc_hw_transform,
+    .outputs = g_ptr_array_new ()
+  };
+  g_ptr_array_add (crtc_assignment->outputs, output);
+
+  /*
+   * Only one output can be marked as primary (due to Xrandr limitation),
+   * so only mark the main output of the first monitor in the logical monitor
+   * as such.
+   */
+  first_monitor_config = data->logical_monitor_config->monitor_configs->data;
+  if (data->logical_monitor_config->is_primary &&
+      data->monitor_config == first_monitor_config &&
+      meta_monitor_get_main_output (monitor) == output)
+    assign_output_as_primary = TRUE;
+  else
+    assign_output_as_primary = FALSE;
+
+  if (data->logical_monitor_config->is_presentation)
+    assign_output_as_presentation = TRUE;
+  else
+    assign_output_as_presentation = FALSE;
+
+  output_assignment = g_new0 (MetaOutputAssignment, 1);
+  *output_assignment = (MetaOutputAssignment) {
+    .output = output,
+    .is_primary = assign_output_as_primary,
+    .is_presentation = assign_output_as_presentation,
+    .is_underscanning = data->monitor_config->enable_underscanning,
+    .is_vrr_disallowed = data->monitor_config->disallow_vrr,
+    .has_max_bpc = data->monitor_config->has_max_bpc,
+    .max_bpc = data->monitor_config->max_bpc
+  };
+
+  g_ptr_array_add (data->crtc_assignments, crtc_assignment);
+  g_ptr_array_add (data->output_assignments, output_assignment);
+
+  return TRUE;
+}
+
+static gboolean
+assign_monitor_crtcs (MetaMonitorManager       *manager,
+                      MetaMonitorsConfig       *config,
+                      MetaLogicalMonitorConfig *logical_monitor_config,
+                      MetaMonitorConfig        *monitor_config,
+                      GPtrArray                *crtc_assignments,
+                      GPtrArray                *output_assignments,
+                      GArray                   *reserved_crtcs,
+                      GError                  **error)
+{
+  MetaMonitorSpec *monitor_spec = monitor_config->monitor_spec;
+  MetaMonitorModeSpec *monitor_mode_spec = monitor_config->mode_spec;
+  MetaMonitor *monitor;
+  MetaMonitorMode *monitor_mode;
+  MonitorAssignmentData data;
+
+  monitor = meta_monitor_manager_get_monitor_from_spec (manager, monitor_spec);
+  if (!monitor)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Configured monitor '%s %s' not found",
+                   monitor_spec->vendor, monitor_spec->product);
+      return FALSE;
+    }
+
+  monitor_mode = meta_monitor_get_mode_from_spec (monitor, monitor_mode_spec);
+  if (!monitor_mode)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Invalid mode %dx%d (%.3f) for monitor '%s %s'",
+                   monitor_mode_spec->width, monitor_mode_spec->height,
+                   monitor_mode_spec->refresh_rate,
+                   monitor_spec->vendor, monitor_spec->product);
+      return FALSE;
+    }
+
+  data = (MonitorAssignmentData) {
+    .monitor_manager = manager,
+    .config = config,
+    .logical_monitor_config = logical_monitor_config,
+    .monitor_config = monitor_config,
+    .crtc_assignments = crtc_assignments,
+    .output_assignments = output_assignments,
+    .reserved_crtcs = reserved_crtcs
+  };
+  if (!meta_monitor_mode_foreach_crtc (monitor, monitor_mode,
+                                       assign_monitor_crtc,
+                                       &data,
+                                       error))
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+assign_logical_monitor_crtcs (MetaMonitorManager       *manager,
+                              MetaMonitorsConfig       *config,
+                              MetaLogicalMonitorConfig *logical_monitor_config,
+                              GPtrArray                *crtc_assignments,
+                              GPtrArray                *output_assignments,
+                              GArray                   *reserved_crtcs,
+                              GError                  **error)
+{
+  GList *l;
+
+  for (l = logical_monitor_config->monitor_configs; l; l = l->next)
+    {
+      MetaMonitorConfig *monitor_config = l->data;
+
+      if (!assign_monitor_crtcs (manager,
+                                 config,
+                                 logical_monitor_config,
+                                 monitor_config,
+                                 crtc_assignments, output_assignments,
+                                 reserved_crtcs, error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_monitor_config_manager_assign (MetaMonitorManager *manager,
+                                    MetaMonitorsConfig *config,
+                                    GPtrArray         **out_crtc_assignments,
+                                    GPtrArray         **out_output_assignments,
+                                    GError            **error)
+{
+  GPtrArray *crtc_assignments;
+  GPtrArray *output_assignments;
+  GArray *reserved_crtcs;
+  GList *l;
+
+  crtc_assignments =
+    g_ptr_array_new_with_free_func ((GDestroyNotify) meta_crtc_assignment_free);
+  output_assignments =
+    g_ptr_array_new_with_free_func ((GDestroyNotify) meta_output_assignment_free);
+  reserved_crtcs = g_array_new (FALSE, FALSE, sizeof (uint64_t));
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      GList *k;
+
+      for (k = logical_monitor_config->monitor_configs; k; k = k->next)
+        {
+          MetaMonitorConfig *monitor_config = k->data;
+          MetaMonitorSpec *monitor_spec = monitor_config->monitor_spec;
+          MetaMonitor *monitor;
+          GList *o;
+
+          monitor = meta_monitor_manager_get_monitor_from_spec (manager, monitor_spec);
+
+          for (o = meta_monitor_get_outputs (monitor); o; o = o->next)
+            {
+              MetaOutput *output = o->data;
+              MetaCrtc *crtc;
+
+              crtc = meta_output_get_assigned_crtc (output);
+              if (crtc)
+                {
+                  uint64_t crtc_id = meta_crtc_get_id (crtc);
+
+                  g_array_append_val (reserved_crtcs, crtc_id);
+                }
+            }
+        }
+    }
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+      if (!assign_logical_monitor_crtcs (manager,
+                                         config, logical_monitor_config,
+                                         crtc_assignments, output_assignments,
+                                         reserved_crtcs, error))
+        {
+          g_ptr_array_free (crtc_assignments, TRUE);
+          g_ptr_array_free (output_assignments, TRUE);
+          g_array_free (reserved_crtcs, TRUE);
+          return FALSE;
+        }
+    }
+
+  g_array_free (reserved_crtcs, TRUE);
+
+  *out_crtc_assignments = crtc_assignments;
+  *out_output_assignments = output_assignments;
+
+  return TRUE;
+}
+
+static gboolean
+is_lid_closed (MetaMonitorManager *monitor_manager)
+{
+    MetaBackend *backend;
+
+    backend = meta_monitor_manager_get_backend (monitor_manager);
+    return meta_backend_is_lid_closed (backend);
+}
+
+MetaMonitorsConfigKey *
+meta_create_monitors_config_key_for_current_state (MetaMonitorManager *monitor_manager)
+{
+  MetaMonitorsConfigKey *config_key;
+  MetaMonitorSpec *laptop_monitor_spec;
+  GList *l;
+  GList *monitor_specs;
+
+  laptop_monitor_spec = NULL;
+  monitor_specs = NULL;
+  for (l = monitor_manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorSpec *monitor_spec;
+
+      if (meta_monitor_is_laptop_panel (monitor))
+        {
+          laptop_monitor_spec = meta_monitor_get_spec (monitor);
+
+          if (is_lid_closed (monitor_manager))
+            continue;
+        }
+
+      monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
+      monitor_specs = g_list_prepend (monitor_specs, monitor_spec);
+    }
+
+  if (!monitor_specs && laptop_monitor_spec)
+    {
+      monitor_specs =
+        g_list_prepend (NULL, meta_monitor_spec_clone (laptop_monitor_spec));
+    }
+
+  if (!monitor_specs)
+    return NULL;
+
+  monitor_specs = g_list_sort (monitor_specs,
+                               (GCompareFunc) meta_monitor_spec_compare);
+
+  config_key = g_new0 (MetaMonitorsConfigKey, 1);
+  *config_key = (MetaMonitorsConfigKey) {
+    .monitor_specs = monitor_specs
+  };
+
+  return config_key;
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_get_stored (MetaMonitorConfigManager *config_manager)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaMonitorsConfigKey *config_key;
+  MetaMonitorsConfig *config;
+  GError *error = NULL;
+
+  config_key =
+    meta_create_monitors_config_key_for_current_state (monitor_manager);
+  if (!config_key)
+    return NULL;
+
+  config = meta_monitor_config_store_lookup (config_manager->config_store,
+                                             config_key);
+  meta_monitors_config_key_free (config_key);
+
+  if (!config)
+    return NULL;
+
+  if (config->flags & META_MONITORS_CONFIG_FLAG_MIGRATED)
+    {
+      if (!meta_finish_monitors_config_migration (monitor_manager, config,
+                                                  &error))
+        {
+          g_warning ("Failed to finish monitors config migration: %s",
+                     error->message);
+          g_error_free (error);
+          meta_monitor_config_store_remove (config_manager->config_store, config);
+          return NULL;
+        }
+    }
+
+  return config;
+}
+
+typedef enum _MonitorMatchRule
+{
+  MONITOR_MATCH_ALL = 0,
+  MONITOR_MATCH_EXTERNAL = (1 << 0),
+  MONITOR_MATCH_BUILTIN = (1 << 1),
+  MONITOR_MATCH_VISIBLE = (1 << 2),
+  MONITOR_MATCH_WITH_SUGGESTED_POSITION = (1 << 3),
+  MONITOR_MATCH_PRIMARY = (1 << 4),
+  MONITOR_MATCH_ALLOW_FALLBACK = (1 << 5),
+} MonitorMatchRule;
+
+static gboolean
+monitor_matches_rule (MetaMonitor        *monitor,
+                      MetaMonitorManager *monitor_manager,
+                      MonitorMatchRule    match_rule)
+{
+  if (!monitor)
+    return FALSE;
+
+  if (match_rule & MONITOR_MATCH_BUILTIN)
+    {
+      if (!meta_monitor_is_laptop_panel (monitor))
+        return FALSE;
+    }
+  else if (match_rule & MONITOR_MATCH_EXTERNAL)
+    {
+      if (meta_monitor_is_laptop_panel (monitor))
+        return FALSE;
+    }
+
+  if (match_rule & MONITOR_MATCH_VISIBLE)
+    {
+      if (meta_monitor_is_laptop_panel (monitor) &&
+          is_lid_closed (monitor_manager))
+        return FALSE;
+    }
+
+  if (match_rule & MONITOR_MATCH_WITH_SUGGESTED_POSITION)
+    {
+      if (!meta_monitor_get_suggested_position (monitor, NULL, NULL))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static GList *
+find_monitors (MetaMonitorManager *monitor_manager,
+               MonitorMatchRule    match_rule,
+               MetaMonitor        *not_this_one)
+{
+  GList *result = NULL;
+  GList *monitors, *l;
+
+  monitors = meta_monitor_manager_get_monitors (monitor_manager);
+  for (l = g_list_last (monitors); l; l = l->prev)
+    {
+      MetaMonitor *monitor = l->data;
+
+      if (not_this_one && monitor == not_this_one)
+        continue;
+
+      if (monitor_matches_rule (monitor, monitor_manager, match_rule))
+        result = g_list_prepend (result, monitor);
+    }
+
+  return result;
+}
+
+static MetaMonitor *
+find_monitor_with_highest_preferred_resolution (MetaMonitorManager *monitor_manager,
+                                                MonitorMatchRule    match_rule)
+{
+  g_autoptr (GList) monitors = NULL;
+  GList *l;
+  int largest_area = 0;
+  MetaMonitor *largest_monitor = NULL;
+
+  monitors = find_monitors (monitor_manager, match_rule, NULL);
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorMode *mode;
+      int width, height;
+      int area;
+
+      mode = meta_monitor_get_preferred_mode (monitor);
+      meta_monitor_mode_get_resolution (mode, &width, &height);
+      area = width * height;
+
+      if (area > largest_area)
+        {
+          largest_area = area;
+          largest_monitor = monitor;
+        }
+    }
+
+  return largest_monitor;
+}
+
+/*
+ * Try to find the primary monitor. The priority of classification is:
+ *
+ * 1. Find the primary monitor as reported by the underlying system,
+ * 2. Find the laptop panel
+ * 3. Find the external monitor with highest resolution
+ *
+ * If the laptop lid is closed, exclude the laptop panel from possible
+ * alternatives, except if no other alternatives exist.
+ */
+static MetaMonitor *
+find_primary_monitor (MetaMonitorManager *monitor_manager,
+                      MonitorMatchRule    match_rule)
+{
+  MetaMonitor *monitor;
+
+  monitor = meta_monitor_manager_get_primary_monitor (monitor_manager);
+  if (monitor_matches_rule (monitor, monitor_manager, match_rule))
+    return monitor;
+
+  monitor = meta_monitor_manager_get_laptop_panel (monitor_manager);
+  if (monitor_matches_rule (monitor, monitor_manager, match_rule))
+    return monitor;
+
+  monitor = find_monitor_with_highest_preferred_resolution (monitor_manager,
+                                                            match_rule);
+  if (monitor)
+    return monitor;
+
+  if (match_rule & MONITOR_MATCH_ALLOW_FALLBACK)
+    return find_monitor_with_highest_preferred_resolution (monitor_manager,
+                                                           MONITOR_MATCH_ALL);
+
+  return NULL;
+}
+
+static MetaMonitorConfig *
+create_monitor_config (MetaMonitor     *monitor,
+                       MetaMonitorMode *mode)
+{
+  MetaMonitorSpec *monitor_spec;
+  MetaMonitorModeSpec *mode_spec;
+  MetaMonitorConfig *monitor_config;
+
+  monitor_spec = meta_monitor_get_spec (monitor);
+  mode_spec = meta_monitor_mode_get_spec (mode);
+
+  monitor_config = g_new0 (MetaMonitorConfig, 1);
+  *monitor_config = (MetaMonitorConfig) {
+    .monitor_spec = meta_monitor_spec_clone (monitor_spec),
+    .mode_spec = g_memdup2 (mode_spec, sizeof (MetaMonitorModeSpec)),
+    .enable_underscanning = meta_monitor_is_underscanning (monitor),
+    .disallow_vrr = meta_monitor_is_vrr_disallowed (monitor),
+  };
+
+  monitor_config->has_max_bpc =
+    meta_monitor_get_max_bpc (monitor, &monitor_config->max_bpc);
+
+  return monitor_config;
+}
+
+static MetaMonitorTransform
+get_monitor_transform (MetaMonitorManager *monitor_manager,
+                       MetaMonitor        *monitor)
+{
+  MetaOrientationManager *orientation_manager;
+  MetaOrientation orientation;
+  MetaBackend *backend;
+
+  if (!meta_monitor_is_laptop_panel (monitor) ||
+      !meta_monitor_manager_get_panel_orientation_managed (monitor_manager))
+    return META_MONITOR_TRANSFORM_NORMAL;
+
+  backend = meta_monitor_manager_get_backend (monitor_manager);
+  orientation_manager = meta_backend_get_orientation_manager (backend);
+  orientation = meta_orientation_manager_get_orientation (orientation_manager);
+
+  return meta_monitor_transform_from_orientation (orientation);
+}
+
+static void
+scale_logical_monitor_width (MetaLogicalMonitorLayoutMode  layout_mode,
+                             float                         scale,
+                             int                           mode_width,
+                             int                           mode_height,
+                             int                          *width,
+                             int                          *height)
+{
+  switch (layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      *width = (int) roundf (mode_width / scale);
+      *height = (int) roundf (mode_height / scale);
+      return;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      *width = mode_width;
+      *height = mode_height;
+      return;
+    }
+
+  g_assert_not_reached ();
+}
+
+static MetaLogicalMonitorConfig *
+create_preferred_logical_monitor_config (MetaMonitorManager          *monitor_manager,
+                                         MetaMonitor                 *monitor,
+                                         int                          x,
+                                         int                          y,
+                                         float                        scale,
+                                         MetaLogicalMonitorLayoutMode layout_mode)
+{
+  MetaMonitorMode *mode;
+  int width, height;
+  MetaMonitorTransform transform;
+  MetaMonitorConfig *monitor_config;
+  MetaLogicalMonitorConfig *logical_monitor_config;
+
+  mode = meta_monitor_get_preferred_mode (monitor);
+  meta_monitor_mode_get_resolution (mode, &width, &height);
+  scale_logical_monitor_width (layout_mode, scale,
+                               width, height, &width, &height);
+
+  monitor_config = create_monitor_config (monitor, mode);
+
+  transform = get_monitor_transform (monitor_manager, monitor);
+  if (meta_monitor_transform_is_rotated (transform))
+    {
+      int temp = width;
+      width = height;
+      height = temp;
+    }
+
+  logical_monitor_config = g_new0 (MetaLogicalMonitorConfig, 1);
+  *logical_monitor_config = (MetaLogicalMonitorConfig) {
+    .layout = (MtkRectangle) {
+      .x = x,
+      .y = y,
+      .width = width,
+      .height = height
+    },
+    .transform = transform,
+    .scale = scale,
+    .monitor_configs = g_list_append (NULL, monitor_config)
+  };
+
+  return logical_monitor_config;
+}
+
+static MetaLogicalMonitorConfig *
+find_monitor_config (MetaMonitorsConfig *config,
+                     MetaMonitor        *monitor,
+                     MetaMonitorMode    *monitor_mode)
+{
+  int mode_width, mode_height;
+  GList *l;
+
+  meta_monitor_mode_get_resolution (monitor_mode, &mode_width, &mode_height);
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      GList *l_monitor;
+
+      for (l_monitor = logical_monitor_config->monitor_configs;
+           l_monitor;
+           l_monitor = l_monitor->next)
+        {
+          MetaMonitorConfig *monitor_config = l_monitor->data;
+          MetaMonitorModeSpec *mode_spec =
+            meta_monitor_mode_get_spec (monitor_mode);
+
+          if (meta_monitor_spec_equals (meta_monitor_get_spec (monitor),
+                                         monitor_config->monitor_spec) &&
+              meta_monitor_mode_spec_has_similar_size (mode_spec,
+                                                       monitor_config->mode_spec))
+            return logical_monitor_config;
+        }
+    }
+
+  return NULL;
+}
+
+static gboolean
+get_last_scale_for_monitor (MetaMonitorConfigManager *config_manager,
+                            MetaMonitor              *monitor,
+                            MetaMonitorMode          *monitor_mode,
+                            float                    *out_scale)
+{
+  g_autoptr (GList) configs = NULL;
+  GList *l;
+
+  if (config_manager->current_config)
+    configs = g_list_append (configs, config_manager->current_config);
+
+  configs = g_list_concat (configs,
+                           g_list_copy (config_manager->config_history.head));
+
+  for (l = configs; l; l = l->next)
+    {
+      MetaMonitorsConfig *config = l->data;
+      MetaLogicalMonitorConfig *logical_monitor_config;
+
+      logical_monitor_config = find_monitor_config (config,
+                                                    monitor, monitor_mode);
+      if (logical_monitor_config)
+        {
+          *out_scale = logical_monitor_config->scale;
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+static float
+compute_scale_for_monitor (MetaMonitorConfigManager *config_manager,
+                           MetaMonitor              *monitor,
+                           MetaMonitor              *primary_monitor)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaMonitor *target_monitor = monitor;
+  MetaLogicalMonitorLayoutMode layout_mode;
+  MetaMonitorMode *monitor_mode;
+  float scale;
+
+  if ((meta_monitor_manager_get_capabilities (monitor_manager) &
+       META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED) &&
+      primary_monitor)
+    target_monitor = primary_monitor;
+
+  layout_mode = meta_monitor_manager_get_default_layout_mode (monitor_manager);
+  monitor_mode = meta_monitor_get_preferred_mode (target_monitor);
+
+  if (get_last_scale_for_monitor (config_manager,
+                                  target_monitor, monitor_mode,
+                                  &scale))
+    return scale;
+
+  return meta_monitor_manager_calculate_monitor_mode_scale (monitor_manager,
+                                                            layout_mode,
+                                                            target_monitor,
+                                                            monitor_mode);
+}
+
+typedef enum _MonitorPositioningMode
+{
+  MONITOR_POSITIONING_LINEAR,
+  MONITOR_POSITIONING_SUGGESTED,
+} MonitorPositioningMode;
+
+static gboolean
+verify_suggested_monitors_config (GList *logical_monitor_configs)
+{
+  g_autoptr (GList) region = NULL;
+  GList *l;
+
+  for (l = logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      MtkRectangle *rect = &logical_monitor_config->layout;
+
+      if (meta_rectangle_overlaps_with_region (region, rect))
+        {
+          g_warning ("Suggested monitor config has overlapping region, "
+                      "rejecting");
+          return FALSE;
+        }
+
+      region = g_list_prepend (region, rect);
+    }
+
+  for (l = region; region->next && l; l = l->next)
+    {
+      MtkRectangle *rect = l->data;
+
+      if (!meta_rectangle_is_adjacent_to_any_in_region (region, rect))
+        {
+          g_warning ("Suggested monitor config has monitors with no "
+                      "neighbors, rejecting");
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+static MetaMonitorsConfig *
+create_monitors_config (MetaMonitorConfigManager *config_manager,
+                        MonitorMatchRule          match_rule,
+                        MonitorPositioningMode    positioning,
+                        MetaMonitorsConfigFlag    config_flags)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  g_autoptr (GList) monitors = NULL;
+  g_autolist (MetaLogicalMonitorConfig) logical_monitor_configs = NULL;
+  MetaMonitor *primary_monitor;
+  MetaLogicalMonitorLayoutMode layout_mode;
+  float scale;
+  GList *l;
+  int x, y;
+
+  primary_monitor = find_primary_monitor (monitor_manager,
+                                          match_rule | MONITOR_MATCH_VISIBLE);
+  if (!primary_monitor)
+    return NULL;
+
+  x = y = 0;
+  layout_mode = meta_monitor_manager_get_default_layout_mode (monitor_manager);
+
+  if (!(match_rule & MONITOR_MATCH_PRIMARY))
+    monitors = find_monitors (monitor_manager, match_rule, primary_monitor);
+
+  /* The primary monitor needs to be at the head of the list for the
+   * linear positioning to be correct.
+   */
+  monitors = g_list_prepend (monitors, primary_monitor);
+
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaLogicalMonitorConfig *logical_monitor_config;
+      gboolean has_suggested_position;
+
+      switch (positioning)
+        {
+        case MONITOR_POSITIONING_LINEAR:
+          break;
+        case MONITOR_POSITIONING_SUGGESTED:
+          has_suggested_position =
+            meta_monitor_get_suggested_position (monitor, &x, &y);
+          g_assert (has_suggested_position);
+          break;
+        }
+
+      scale = compute_scale_for_monitor (config_manager, monitor,
+                                         primary_monitor);
+      logical_monitor_config =
+        create_preferred_logical_monitor_config (monitor_manager,
+                                                 monitor,
+                                                 x, y, scale,
+                                                 layout_mode);
+      logical_monitor_config->is_primary = (monitor == primary_monitor);
+      logical_monitor_configs = g_list_append (logical_monitor_configs,
+                                               logical_monitor_config);
+
+      x += logical_monitor_config->layout.width;
+    }
+
+  if (positioning == MONITOR_POSITIONING_SUGGESTED)
+    {
+      if (!verify_suggested_monitors_config (logical_monitor_configs))
+        return NULL;
+    }
+
+  return meta_monitors_config_new (monitor_manager,
+                                   g_steal_pointer (&logical_monitor_configs),
+                                   layout_mode,
+                                   config_flags);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_linear (MetaMonitorConfigManager *config_manager)
+{
+  return create_monitors_config (config_manager,
+                                 MONITOR_MATCH_VISIBLE |
+                                 MONITOR_MATCH_ALLOW_FALLBACK,
+                                 MONITOR_POSITIONING_LINEAR,
+                                 META_MONITORS_CONFIG_FLAG_NONE);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_fallback (MetaMonitorConfigManager *config_manager)
+{
+  return create_monitors_config (config_manager,
+                                 MONITOR_MATCH_PRIMARY |
+                                 MONITOR_MATCH_ALLOW_FALLBACK,
+                                 MONITOR_POSITIONING_LINEAR,
+                                 META_MONITORS_CONFIG_FLAG_NONE);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_suggested (MetaMonitorConfigManager *config_manager)
+{
+  return create_monitors_config (config_manager,
+                                 MONITOR_MATCH_WITH_SUGGESTED_POSITION,
+                                 MONITOR_POSITIONING_SUGGESTED,
+                                 META_MONITORS_CONFIG_FLAG_NONE);
+}
+
+static GList *
+clone_monitor_config_list (GList *monitor_configs_in)
+{
+  MetaMonitorConfig *monitor_config_in;
+  MetaMonitorConfig *monitor_config_out;
+  GList *monitor_configs_out = NULL;
+  GList *l;
+
+  for (l = monitor_configs_in; l; l = l->next)
+    {
+      monitor_config_in = l->data;
+      monitor_config_out = g_new0 (MetaMonitorConfig, 1);
+      *monitor_config_out = (MetaMonitorConfig) {
+        .monitor_spec = meta_monitor_spec_clone (monitor_config_in->monitor_spec),
+        .mode_spec = g_memdup2 (monitor_config_in->mode_spec,
+                                sizeof (MetaMonitorModeSpec)),
+        .enable_underscanning = monitor_config_in->enable_underscanning,
+        .disallow_vrr = monitor_config_in->disallow_vrr,
+        .has_max_bpc = monitor_config_in->has_max_bpc,
+        .max_bpc = monitor_config_in->max_bpc
+      };
+      monitor_configs_out =
+        g_list_append (monitor_configs_out, monitor_config_out);
+    }
+
+  return monitor_configs_out;
+}
+
+static GList *
+clone_logical_monitor_config_list (GList *logical_monitor_configs_in)
+{
+  MetaLogicalMonitorConfig *logical_monitor_config_in;
+  MetaLogicalMonitorConfig *logical_monitor_config_out;
+  GList *logical_monitor_configs_out = NULL;
+  GList *l;
+
+  for (l = logical_monitor_configs_in; l; l = l->next)
+    {
+      logical_monitor_config_in = l->data;
+
+      logical_monitor_config_out =
+        g_memdup2 (logical_monitor_config_in,
+                   sizeof (MetaLogicalMonitorConfig));
+      logical_monitor_config_out->monitor_configs =
+        clone_monitor_config_list (logical_monitor_config_in->monitor_configs);
+
+      logical_monitor_configs_out =
+        g_list_append (logical_monitor_configs_out, logical_monitor_config_out);
+    }
+
+  return logical_monitor_configs_out;
+}
+
+static MetaLogicalMonitorConfig *
+find_logical_config_for_builtin_monitor (MetaMonitorConfigManager *config_manager,
+                                         GList                    *logical_monitor_configs)
+{
+  MetaLogicalMonitorConfig *logical_monitor_config;
+  MetaMonitorConfig *monitor_config;
+  MetaMonitor *panel;
+  GList *l;
+
+  panel = meta_monitor_manager_get_laptop_panel (config_manager->monitor_manager);
+  if (panel)
+    {
+      for (l = logical_monitor_configs; l; l = l->next)
+        {
+          logical_monitor_config = l->data;
+          /*
+           * We only want to return the config for the panel if it is
+           * configured on its own, so we skip configs which contain clones.
+           */
+          if (g_list_length (logical_monitor_config->monitor_configs) != 1)
+            continue;
+
+          monitor_config = logical_monitor_config->monitor_configs->data;
+          if (meta_monitor_spec_equals (meta_monitor_get_spec (panel),
+                                        monitor_config->monitor_spec))
+            {
+              MetaMonitorMode *mode;
+
+              mode = meta_monitor_get_mode_from_spec (panel,
+                                                      monitor_config->mode_spec);
+              if (mode)
+                return logical_monitor_config;
+            }
+        }
+    }
+
+  return NULL;
+}
+
+static MetaMonitorsConfig *
+create_for_builtin_display_rotation (MetaMonitorConfigManager *config_manager,
+                                     MetaMonitorsConfig       *base_config,
+                                     gboolean                  rotate,
+                                     MetaMonitorTransform      transform)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaLogicalMonitorConfig *logical_monitor_config;
+  MetaLogicalMonitorConfig *current_logical_monitor_config;
+  MetaMonitorsConfig *config;
+  GList *logical_monitor_configs, *current_configs;
+  MetaLogicalMonitorLayoutMode layout_mode;
+
+  g_return_val_if_fail (base_config, NULL);
+
+  current_configs = base_config->logical_monitor_configs;
+  current_logical_monitor_config =
+    find_logical_config_for_builtin_monitor (config_manager, current_configs);
+  if (!current_logical_monitor_config)
+    return NULL;
+
+  if (rotate)
+    transform = (current_logical_monitor_config->transform + 1) % META_MONITOR_TRANSFORM_FLIPPED;
+  else
+    {
+      /*
+       * The transform coming from the accelerometer should be applied to
+       * the crtc as is, without taking panel-orientation into account, this
+       * is done so that non panel-orientation aware desktop environments do the
+       * right thing. Mutter corrects for panel-orientation when applying the
+       * transform from a logical-monitor-config, so we must convert here.
+       */
+      MetaMonitor *panel =
+        meta_monitor_manager_get_laptop_panel (config_manager->monitor_manager);
+
+      transform = meta_monitor_crtc_to_logical_transform (panel, transform);
+    }
+
+  if (current_logical_monitor_config->transform == transform)
+    return NULL;
+
+  logical_monitor_configs =
+    clone_logical_monitor_config_list (base_config->logical_monitor_configs);
+  logical_monitor_config =
+    find_logical_config_for_builtin_monitor (config_manager,
+                                             logical_monitor_configs);
+  logical_monitor_config->transform = transform;
+
+  if (meta_monitor_transform_is_rotated (current_logical_monitor_config->transform) !=
+      meta_monitor_transform_is_rotated (logical_monitor_config->transform))
+    {
+      int temp = logical_monitor_config->layout.width;
+      logical_monitor_config->layout.width = logical_monitor_config->layout.height;
+      logical_monitor_config->layout.height = temp;
+    }
+
+  layout_mode = base_config->layout_mode;
+  config = meta_monitors_config_new (monitor_manager,
+                                     logical_monitor_configs,
+                                     layout_mode,
+                                     META_MONITORS_CONFIG_FLAG_NONE);
+  meta_monitors_config_set_parent_config (config, base_config);
+
+  return config;
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_orientation (MetaMonitorConfigManager *config_manager,
+                                                    MetaMonitorsConfig       *base_config,
+                                                    MetaMonitorTransform      transform)
+{
+  return create_for_builtin_display_rotation (config_manager, base_config,
+                                              FALSE, transform);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_builtin_orientation (MetaMonitorConfigManager *config_manager,
+                                                            MetaMonitorsConfig       *base_config)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaMonitorTransform current_transform;
+  MetaMonitor *laptop_panel;
+
+  g_return_val_if_fail (
+    meta_monitor_manager_get_panel_orientation_managed (monitor_manager), NULL);
+
+  laptop_panel = meta_monitor_manager_get_laptop_panel (monitor_manager);
+  current_transform = get_monitor_transform (monitor_manager, laptop_panel);
+
+  return create_for_builtin_display_rotation (config_manager, base_config,
+                                              FALSE, current_transform);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_rotate_monitor (MetaMonitorConfigManager *config_manager)
+{
+  if (!config_manager->current_config)
+    return NULL;
+
+  return create_for_builtin_display_rotation (config_manager,
+                                              config_manager->current_config,
+                                              TRUE,
+                                              META_MONITOR_TRANSFORM_NORMAL);
+}
+
+static MetaMonitorsConfig *
+create_monitors_switch_config (MetaMonitorConfigManager    *config_manager,
+                               MonitorMatchRule             match_rule,
+                               MonitorPositioningMode       positioning,
+                               MetaMonitorsConfigFlag       config_flags,
+                               MetaMonitorSwitchConfigType  switch_config)
+{
+  MetaMonitorsConfig *monitors_config;
+
+  monitors_config = create_monitors_config (config_manager, match_rule,
+                                            positioning, config_flags);
+
+  if (!monitors_config)
+    return NULL;
+
+  meta_monitors_config_set_switch_config (monitors_config, switch_config);
+  return monitors_config;
+}
+
+static MetaMonitorsConfig *
+create_for_switch_config_all_mirror (MetaMonitorConfigManager *config_manager)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaMonitor *primary_monitor;
+  MetaLogicalMonitorLayoutMode layout_mode;
+  MetaLogicalMonitorConfig *logical_monitor_config = NULL;
+  GList *logical_monitor_configs;
+  GList *monitor_configs = NULL;
+  gint common_mode_w = 0, common_mode_h = 0;
+  float best_scale = 1.0;
+  MetaMonitor *monitor;
+  GList *modes;
+  GList *monitors;
+  GList *l;
+  MetaMonitorsConfig *monitors_config;
+  int width, height;
+
+  primary_monitor = find_primary_monitor (monitor_manager,
+                                          MONITOR_MATCH_ALLOW_FALLBACK);
+  if (!primary_monitor)
+    return NULL;
+
+  layout_mode = meta_monitor_manager_get_default_layout_mode (monitor_manager);
+  monitors = meta_monitor_manager_get_monitors (monitor_manager);
+  monitor = monitors->data;
+  modes = meta_monitor_get_modes (monitor);
+  for (l = modes; l; l = l->next)
+    {
+      MetaMonitorMode *mode = l->data;
+      gboolean common_mode_size = TRUE;
+      gint mode_w, mode_h;
+      GList *ll;
+
+      meta_monitor_mode_get_resolution (mode, &mode_w, &mode_h);
+
+      for (ll = monitors->next; ll; ll = ll->next)
+        {
+          MetaMonitor *monitor_b = ll->data;
+          gboolean have_same_mode_size = FALSE;
+          GList *mm;
+
+          for (mm = meta_monitor_get_modes (monitor_b); mm; mm = mm->next)
+            {
+              MetaMonitorMode *mode_b = mm->data;
+              gint mode_b_w, mode_b_h;
+
+              meta_monitor_mode_get_resolution (mode_b, &mode_b_w, &mode_b_h);
+
+              if (mode_w == mode_b_w &&
+                  mode_h == mode_b_h)
+                {
+                  have_same_mode_size = TRUE;
+                  break;
+                }
+            }
+
+          if (!have_same_mode_size)
+            {
+              common_mode_size = FALSE;
+              break;
+            }
+        }
+
+      if (common_mode_size &&
+          common_mode_w * common_mode_h < mode_w * mode_h)
+        {
+          common_mode_w = mode_w;
+          common_mode_h = mode_h;
+        }
+    }
+
+  if (common_mode_w == 0 || common_mode_h == 0)
+    return NULL;
+
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorMode *mode = NULL;
+      GList *ll;
+      float scale;
+
+      for (ll = meta_monitor_get_modes (monitor); ll; ll = ll->next)
+        {
+          gint mode_w, mode_h;
+
+          mode = ll->data;
+          meta_monitor_mode_get_resolution (mode, &mode_w, &mode_h);
+
+          if (mode_w == common_mode_w && mode_h == common_mode_h)
+            break;
+        }
+
+      if (!mode)
+        continue;
+
+      scale = compute_scale_for_monitor (config_manager, monitor,
+                                         primary_monitor);
+      best_scale = MAX (best_scale, scale);
+      monitor_configs = g_list_prepend (monitor_configs, create_monitor_config (monitor, mode));
+    }
+
+  scale_logical_monitor_width (layout_mode, best_scale,
+                               common_mode_w, common_mode_h,
+                               &width, &height);
+
+  logical_monitor_config = g_new0 (MetaLogicalMonitorConfig, 1);
+  *logical_monitor_config = (MetaLogicalMonitorConfig) {
+    .layout = MTK_RECTANGLE_INIT (0, 0, width, height),
+    .scale = best_scale,
+    .monitor_configs = monitor_configs,
+    .is_primary = TRUE,
+  };
+
+  logical_monitor_configs = g_list_append (NULL, logical_monitor_config);
+  monitors_config = meta_monitors_config_new (monitor_manager,
+                                              logical_monitor_configs,
+                                              layout_mode,
+                                              META_MONITORS_CONFIG_FLAG_NONE);
+
+  if (monitors_config)
+    meta_monitors_config_set_switch_config (monitors_config, META_MONITOR_SWITCH_CONFIG_ALL_MIRROR);
+
+  return monitors_config;
+}
+
+static MetaMonitorsConfig *
+create_for_switch_config_external (MetaMonitorConfigManager *config_manager)
+{
+  return create_monitors_switch_config (config_manager,
+                                        MONITOR_MATCH_EXTERNAL,
+                                        MONITOR_POSITIONING_LINEAR,
+                                        META_MONITORS_CONFIG_FLAG_NONE,
+                                        META_MONITOR_SWITCH_CONFIG_EXTERNAL);
+}
+
+static MetaMonitorsConfig *
+create_for_switch_config_builtin (MetaMonitorConfigManager *config_manager)
+{
+  return create_monitors_switch_config (config_manager,
+                                        MONITOR_MATCH_BUILTIN,
+                                        MONITOR_POSITIONING_LINEAR,
+                                        META_MONITORS_CONFIG_FLAG_NONE,
+                                        META_MONITOR_SWITCH_CONFIG_BUILTIN);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_switch_config (MetaMonitorConfigManager    *config_manager,
+                                                      MetaMonitorSwitchConfigType  config_type)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  MetaMonitorsConfig *config;
+
+  if (!meta_monitor_manager_can_switch_config (monitor_manager))
+    return NULL;
+
+  switch (config_type)
+    {
+    case META_MONITOR_SWITCH_CONFIG_ALL_MIRROR:
+      config = create_for_switch_config_all_mirror (config_manager);
+      break;
+    case META_MONITOR_SWITCH_CONFIG_ALL_LINEAR:
+      config = meta_monitor_config_manager_create_linear (config_manager);
+      break;
+    case META_MONITOR_SWITCH_CONFIG_EXTERNAL:
+      config = create_for_switch_config_external (config_manager);
+      break;
+    case META_MONITOR_SWITCH_CONFIG_BUILTIN:
+      config = create_for_switch_config_builtin (config_manager);
+      break;
+    case META_MONITOR_SWITCH_CONFIG_UNKNOWN:
+    default:
+      g_warn_if_reached ();
+      return NULL;
+    }
+
+  return config;
+}
+
+static MetaMonitorsConfig *
+get_root_config (MetaMonitorsConfig *config)
+{
+  if (!config->parent_config)
+    return config;
+
+  return get_root_config (config->parent_config);
+}
+
+static gboolean
+has_same_root_config (MetaMonitorsConfig *config_a,
+                      MetaMonitorsConfig *config_b)
+{
+  return get_root_config (config_a) == get_root_config (config_b);
+}
+
+void
+meta_monitor_config_manager_set_current (MetaMonitorConfigManager *config_manager,
+                                         MetaMonitorsConfig       *config)
+{
+  MetaMonitorsConfig *current_config = config_manager->current_config;
+  gboolean overrides_current = FALSE;
+
+  if (config && current_config &&
+      has_same_root_config (config, current_config))
+    {
+      overrides_current = meta_monitors_config_key_equal (config->key,
+                                                          current_config->key);
+    }
+
+  if (current_config && !overrides_current)
+    {
+      g_queue_push_head (&config_manager->config_history,
+                         g_object_ref (config_manager->current_config));
+      if (g_queue_get_length (&config_manager->config_history) >
+          CONFIG_HISTORY_MAX_SIZE)
+        g_object_unref (g_queue_pop_tail (&config_manager->config_history));
+    }
+
+  g_set_object (&config_manager->current_config, config);
+}
+
+void
+meta_monitor_config_manager_save_current (MetaMonitorConfigManager *config_manager)
+{
+  g_return_if_fail (config_manager->current_config);
+
+  meta_monitor_config_store_add (config_manager->config_store,
+                                 config_manager->current_config);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_get_current (MetaMonitorConfigManager *config_manager)
+{
+  return config_manager->current_config;
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_pop_previous (MetaMonitorConfigManager *config_manager)
+{
+  return g_queue_pop_head (&config_manager->config_history);
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_manager_get_previous (MetaMonitorConfigManager *config_manager)
+{
+  return g_queue_peek_head (&config_manager->config_history);
+}
+
+void
+meta_monitor_config_manager_clear_history (MetaMonitorConfigManager *config_manager)
+{
+  g_queue_foreach (&config_manager->config_history, (GFunc) g_object_unref, NULL);
+  g_queue_clear (&config_manager->config_history);
+}
+
+static void
+meta_monitor_config_manager_dispose (GObject *object)
+{
+  MetaMonitorConfigManager *config_manager =
+    META_MONITOR_CONFIG_MANAGER (object);
+
+  g_clear_object (&config_manager->current_config);
+  meta_monitor_config_manager_clear_history (config_manager);
+
+  G_OBJECT_CLASS (meta_monitor_config_manager_parent_class)->dispose (object);
+}
+
+static void
+meta_monitor_config_manager_init (MetaMonitorConfigManager *config_manager)
+{
+  g_queue_init (&config_manager->config_history);
+}
+
+static void
+meta_monitor_config_manager_class_init (MetaMonitorConfigManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_monitor_config_manager_dispose;
+}
+
+void
+meta_monitor_config_free (MetaMonitorConfig *monitor_config)
+{
+  if (monitor_config->monitor_spec)
+    meta_monitor_spec_free (monitor_config->monitor_spec);
+  g_free (monitor_config->mode_spec);
+  g_free (monitor_config);
+}
+
+void
+meta_logical_monitor_config_free (MetaLogicalMonitorConfig *logical_monitor_config)
+{
+  g_list_free_full (logical_monitor_config->monitor_configs,
+                    (GDestroyNotify) meta_monitor_config_free);
+  g_free (logical_monitor_config);
+}
+
+static MetaMonitorsConfigKey *
+meta_monitors_config_key_new (GList *logical_monitor_configs,
+                              GList *disabled_monitor_specs)
+{
+  MetaMonitorsConfigKey *config_key;
+  GList *monitor_specs;
+  GList *l;
+
+  monitor_specs = NULL;
+  for (l = logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      GList *k;
+
+      for (k = logical_monitor_config->monitor_configs; k; k = k->next)
+        {
+          MetaMonitorConfig *monitor_config = k->data;
+          MetaMonitorSpec *monitor_spec;
+
+          monitor_spec = meta_monitor_spec_clone (monitor_config->monitor_spec);
+          monitor_specs = g_list_prepend (monitor_specs, monitor_spec);
+        }
+    }
+
+  for (l = disabled_monitor_specs; l; l = l->next)
+    {
+      MetaMonitorSpec *monitor_spec = l->data;
+
+      monitor_spec = meta_monitor_spec_clone (monitor_spec);
+      monitor_specs = g_list_prepend (monitor_specs, monitor_spec);
+    }
+
+  monitor_specs = g_list_sort (monitor_specs,
+                               (GCompareFunc) meta_monitor_spec_compare);
+
+  config_key = g_new0 (MetaMonitorsConfigKey, 1);
+  *config_key = (MetaMonitorsConfigKey) {
+    .monitor_specs = monitor_specs
+  };
+
+  return config_key;
+}
+
+void
+meta_monitors_config_key_free (MetaMonitorsConfigKey *config_key)
+{
+  g_list_free_full (config_key->monitor_specs,
+                    (GDestroyNotify) meta_monitor_spec_free);
+  g_free (config_key);
+}
+
+unsigned int
+meta_monitors_config_key_hash (gconstpointer data)
+{
+  const MetaMonitorsConfigKey *config_key = data;
+  GList *l;
+  unsigned long hash;
+
+  hash = 0;
+  for (l = config_key->monitor_specs; l; l = l->next)
+    {
+      MetaMonitorSpec *monitor_spec = l->data;
+
+      hash ^= (g_str_hash (monitor_spec->connector) ^
+               g_str_hash (monitor_spec->vendor) ^
+               g_str_hash (monitor_spec->product) ^
+               g_str_hash (monitor_spec->serial));
+    }
+
+  return hash;
+}
+
+gboolean
+meta_monitors_config_key_equal (gconstpointer data_a,
+                                gconstpointer data_b)
+{
+  const MetaMonitorsConfigKey *config_key_a = data_a;
+  const MetaMonitorsConfigKey *config_key_b = data_b;
+  GList *l_a, *l_b;
+
+  for (l_a = config_key_a->monitor_specs, l_b = config_key_b->monitor_specs;
+       l_a && l_b;
+       l_a = l_a->next, l_b = l_b->next)
+    {
+      MetaMonitorSpec *monitor_spec_a = l_a->data;
+      MetaMonitorSpec *monitor_spec_b = l_b->data;
+
+      if (!meta_monitor_spec_equals (monitor_spec_a, monitor_spec_b))
+        return FALSE;
+    }
+
+  if (l_a || l_b)
+    return FALSE;
+
+  return TRUE;
+}
+
+MetaMonitorSwitchConfigType
+meta_monitors_config_get_switch_config (MetaMonitorsConfig *config)
+{
+  return config->switch_config;
+}
+
+void
+meta_monitors_config_set_switch_config (MetaMonitorsConfig          *config,
+                                        MetaMonitorSwitchConfigType  switch_config)
+{
+  config->switch_config = switch_config;
+}
+
+void
+meta_monitors_config_set_parent_config (MetaMonitorsConfig *config,
+                                        MetaMonitorsConfig *parent_config)
+{
+  g_assert (config != parent_config);
+  g_assert (!parent_config || parent_config->parent_config != config);
+
+  g_set_object (&config->parent_config, parent_config);
+}
+
+MetaMonitorsConfig *
+meta_monitors_config_new_full (GList                        *logical_monitor_configs,
+                               GList                        *disabled_monitor_specs,
+                               MetaLogicalMonitorLayoutMode  layout_mode,
+                               MetaMonitorsConfigFlag        flags)
+{
+  MetaMonitorsConfig *config;
+
+  config = g_object_new (META_TYPE_MONITORS_CONFIG, NULL);
+  config->logical_monitor_configs = logical_monitor_configs;
+  config->disabled_monitor_specs = disabled_monitor_specs;
+  config->key = meta_monitors_config_key_new (logical_monitor_configs,
+                                              disabled_monitor_specs);
+  config->layout_mode = layout_mode;
+  config->flags = flags;
+  config->switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
+
+  return config;
+}
+
+MetaMonitorsConfig *
+meta_monitors_config_new (MetaMonitorManager           *monitor_manager,
+                          GList                        *logical_monitor_configs,
+                          MetaLogicalMonitorLayoutMode  layout_mode,
+                          MetaMonitorsConfigFlag        flags)
+{
+  GList *disabled_monitor_specs = NULL;
+  GList *monitors;
+  GList *l;
+
+  monitors = meta_monitor_manager_get_monitors (monitor_manager);
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorSpec *monitor_spec;
+
+      if (!monitor_matches_rule (monitor, monitor_manager,
+                                 MONITOR_MATCH_VISIBLE))
+        continue;
+
+      monitor_spec = meta_monitor_get_spec (monitor);
+      if (meta_logical_monitor_configs_have_monitor (logical_monitor_configs,
+                                                     monitor_spec))
+        continue;
+
+      disabled_monitor_specs =
+        g_list_prepend (disabled_monitor_specs,
+                        meta_monitor_spec_clone (monitor_spec));
+    }
+
+  return meta_monitors_config_new_full (logical_monitor_configs,
+                                        disabled_monitor_specs,
+                                        layout_mode,
+                                        flags);
+}
+
+static void
+meta_monitors_config_finalize (GObject *object)
+{
+  MetaMonitorsConfig *config = META_MONITORS_CONFIG (object);
+
+  g_clear_object (&config->parent_config);
+  meta_monitors_config_key_free (config->key);
+  g_list_free_full (config->logical_monitor_configs,
+                    (GDestroyNotify) meta_logical_monitor_config_free);
+  g_list_free_full (config->disabled_monitor_specs,
+                    (GDestroyNotify) meta_monitor_spec_free);
+
+  G_OBJECT_CLASS (meta_monitors_config_parent_class)->finalize (object);
+}
+
+static void
+meta_monitors_config_init (MetaMonitorsConfig *config)
+{
+}
+
+static void
+meta_monitors_config_class_init (MetaMonitorsConfigClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_monitors_config_finalize;
+}
+
+static void
+meta_crtc_assignment_free (MetaCrtcAssignment *assignment)
+{
+  g_ptr_array_free (assignment->outputs, TRUE);
+  g_free (assignment);
+}
+
+static void
+meta_output_assignment_free (MetaOutputAssignment *assignment)
+{
+  g_free (assignment);
+}
+
+gboolean
+meta_verify_monitor_mode_spec (MetaMonitorModeSpec *monitor_mode_spec,
+                               GError             **error)
+{
+  if (monitor_mode_spec->width > 0 &&
+      monitor_mode_spec->height > 0 &&
+      monitor_mode_spec->refresh_rate > 0.0f)
+    {
+      return TRUE;
+    }
+  else
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitor mode invalid");
+      return FALSE;
+    }
+}
+
+gboolean
+meta_verify_monitor_spec (MetaMonitorSpec *monitor_spec,
+                          GError         **error)
+{
+  if (monitor_spec->connector &&
+      monitor_spec->vendor &&
+      monitor_spec->product &&
+      monitor_spec->serial)
+    {
+      return TRUE;
+    }
+  else
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitor spec incomplete");
+      return FALSE;
+    }
+}
+
+gboolean
+meta_verify_monitor_config (MetaMonitorConfig *monitor_config,
+                            GError           **error)
+{
+  if (monitor_config->monitor_spec && monitor_config->mode_spec)
+    {
+      return TRUE;
+    }
+  else
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitor config incomplete");
+      return FALSE;
+    }
+}
+
+gboolean
+meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
+                                    MetaLogicalMonitorLayoutMode layout_mode,
+                                    MetaMonitorManager          *monitor_manager,
+                                    GError                     **error)
+{
+  GList *l;
+  int expected_mode_width = 0;
+  int expected_mode_height = 0;
+
+  if (logical_monitor_config->layout.x < 0 ||
+      logical_monitor_config->layout.y < 0)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Invalid logical monitor position (%d, %d)",
+                   logical_monitor_config->layout.x,
+                   logical_monitor_config->layout.y);
+      return FALSE;
+    }
+
+  if (!logical_monitor_config->monitor_configs)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Logical monitor is empty");
+      return FALSE;
+    }
+
+  if (meta_monitor_transform_is_rotated (logical_monitor_config->transform))
+    {
+      expected_mode_width = logical_monitor_config->layout.height;
+      expected_mode_height = logical_monitor_config->layout.width;
+    }
+  else
+    {
+      expected_mode_width = logical_monitor_config->layout.width;
+      expected_mode_height = logical_monitor_config->layout.height;
+    }
+
+  switch (layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      expected_mode_width = roundf (expected_mode_width *
+                                    logical_monitor_config->scale);
+      expected_mode_height = roundf (expected_mode_height *
+                                     logical_monitor_config->scale);
+      break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      break;
+    }
+
+  for (l = logical_monitor_config->monitor_configs; l; l = l->next)
+    {
+      MetaMonitorConfig *monitor_config = l->data;
+
+      if (monitor_config->mode_spec->width != expected_mode_width ||
+          monitor_config->mode_spec->height != expected_mode_height)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Monitor modes in logical monitor conflict");
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+static gboolean
+has_adjacent_neighbour (MetaMonitorsConfig       *config,
+                        MetaLogicalMonitorConfig *logical_monitor_config)
+{
+  GList *l;
+
+  if (!config->logical_monitor_configs->next)
+    {
+      g_assert (config->logical_monitor_configs->data ==
+                logical_monitor_config);
+      return TRUE;
+    }
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *other_logical_monitor_config = l->data;
+
+      if (logical_monitor_config == other_logical_monitor_config)
+        continue;
+
+      if (meta_rectangle_is_adjacent_to (&logical_monitor_config->layout,
+                                         &other_logical_monitor_config->layout))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+gboolean
+meta_logical_monitor_configs_have_monitor (GList           *logical_monitor_configs,
+                                           MetaMonitorSpec *monitor_spec)
+{
+  GList *l;
+
+  for (l = logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      GList *k;
+
+      for (k = logical_monitor_config->monitor_configs; k; k = k->next)
+        {
+          MetaMonitorConfig *monitor_config = k->data;
+
+          if (meta_monitor_spec_equals (monitor_spec,
+                                        monitor_config->monitor_spec))
+            return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+static gboolean
+meta_monitors_config_is_monitor_enabled (MetaMonitorsConfig *config,
+                                         MetaMonitorSpec    *monitor_spec)
+{
+  return meta_logical_monitor_configs_have_monitor (config->logical_monitor_configs,
+                                                    monitor_spec);
+}
+
+gboolean
+meta_verify_monitors_config (MetaMonitorsConfig *config,
+                             MetaMonitorManager *monitor_manager,
+                             GError            **error)
+{
+  int min_x, min_y;
+  gboolean has_primary;
+  GList *region;
+  GList *l;
+  gboolean global_scale_required;
+
+  if (!config->logical_monitor_configs)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitors config incomplete");
+      return FALSE;
+    }
+
+  global_scale_required =
+    !!(meta_monitor_manager_get_capabilities (monitor_manager) &
+       META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED);
+
+  min_x = INT_MAX;
+  min_y = INT_MAX;
+  region = NULL;
+  has_primary = FALSE;
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+      if (global_scale_required)
+        {
+          MetaLogicalMonitorConfig *prev_logical_monitor_config =
+            l->prev ? l->prev->data : NULL;
+
+          if (prev_logical_monitor_config &&
+              (prev_logical_monitor_config->scale !=
+               logical_monitor_config->scale))
+            {
+              g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "Logical monitor scales must be identical");
+              return FALSE;
+            }
+        }
+
+      if (meta_rectangle_overlaps_with_region (region,
+                                               &logical_monitor_config->layout))
+        {
+          g_list_free (region);
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Logical monitors overlap");
+          return FALSE;
+        }
+
+      if (has_primary && logical_monitor_config->is_primary)
+        {
+          g_list_free (region);
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Config contains multiple primary logical monitors");
+          return FALSE;
+        }
+      else if (logical_monitor_config->is_primary)
+        {
+          has_primary = TRUE;
+        }
+
+      if (!has_adjacent_neighbour (config, logical_monitor_config))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Logical monitors not adjacent");
+          return FALSE;
+        }
+
+      min_x = MIN (logical_monitor_config->layout.x, min_x);
+      min_y = MIN (logical_monitor_config->layout.y, min_y);
+
+      region = g_list_prepend (region, &logical_monitor_config->layout);
+    }
+
+  g_list_free (region);
+
+  for (l = config->disabled_monitor_specs; l; l = l->next)
+    {
+      MetaMonitorSpec *monitor_spec = l->data;
+
+      if (meta_monitors_config_is_monitor_enabled (config, monitor_spec))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Assigned monitor explicitly disabled");
+          return FALSE;
+        }
+    }
+
+  if (min_x != 0 || min_y != 0)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Logical monitors positions are offset");
+      return FALSE;
+    }
+
+  if (!has_primary)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Config is missing primary logical");
+      return FALSE;
+    }
+
+  return TRUE;
+}
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-manager.h b/src/backends/meta-monitor-config-manager.h
--- a/src/backends/meta-monitor-config-manager.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-manager.h	2023-10-12 20:59:22.707167662 +0300
@@ -31,6 +31,7 @@
   MetaMonitorSpec *monitor_spec;
   MetaMonitorModeSpec *mode_spec;
   gboolean enable_underscanning;
+  gboolean disallow_vrr;
   gboolean has_max_bpc;
   unsigned int max_bpc;
 } MetaMonitorConfig;
@@ -115,6 +116,10 @@
 META_EXPORT_TEST
 MetaMonitorsConfig * meta_monitor_config_manager_create_for_rotate_monitor (MetaMonitorConfigManager *config_manager);
 
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_layout (MetaMonitorConfigManager     *config_manager,
+                                                                    MetaMonitorsConfig           *config,
+                                                                    MetaLogicalMonitorLayoutMode  layout_mode);
+
 META_EXPORT_TEST
 MetaMonitorsConfig * meta_monitor_config_manager_create_for_switch_config (MetaMonitorConfigManager    *config_manager,
                                                                            MetaMonitorSwitchConfigType  config_type);
@@ -200,6 +205,7 @@
 gboolean meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
                                              MetaLogicalMonitorLayoutMode layout_mode,
                                              MetaMonitorManager          *monitor_manager,
+                                             float                        max_scale,
                                              GError                     **error);
 
 META_EXPORT_TEST
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-manager.h.orig b/src/backends/meta-monitor-config-manager.h.orig
--- a/src/backends/meta-monitor-config-manager.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor-config-manager.h.orig	2023-10-12 20:59:22.670500538 +0300
@@ -0,0 +1,216 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2016 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "backends/meta-monitor.h"
+#include "backends/meta-monitor-manager-private.h"
+
+#define META_TYPE_MONITOR_CONFIG_MANAGER (meta_monitor_config_manager_get_type ())
+G_DECLARE_FINAL_TYPE (MetaMonitorConfigManager, meta_monitor_config_manager,
+                      META, MONITOR_CONFIG_MANAGER, GObject)
+
+typedef struct _MetaMonitorConfig
+{
+  MetaMonitorSpec *monitor_spec;
+  MetaMonitorModeSpec *mode_spec;
+  gboolean enable_underscanning;
+  gboolean disallow_vrr;
+  gboolean has_max_bpc;
+  unsigned int max_bpc;
+} MetaMonitorConfig;
+
+typedef struct _MetaLogicalMonitorConfig
+{
+  MtkRectangle layout;
+  GList *monitor_configs;
+  MetaMonitorTransform transform;
+  float scale;
+  gboolean is_primary;
+  gboolean is_presentation;
+} MetaLogicalMonitorConfig;
+
+typedef struct _MetaMonitorsConfigKey
+{
+  GList *monitor_specs;
+} MetaMonitorsConfigKey;
+
+enum _MetaMonitorsConfigFlag
+{
+  META_MONITORS_CONFIG_FLAG_NONE = 0,
+  META_MONITORS_CONFIG_FLAG_MIGRATED = (1 << 0),
+  META_MONITORS_CONFIG_FLAG_SYSTEM_CONFIG = (1 << 1),
+};
+
+struct _MetaMonitorsConfig
+{
+  GObject parent;
+
+  MetaMonitorsConfig *parent_config;
+  MetaMonitorsConfigKey *key;
+  GList *logical_monitor_configs;
+
+  GList *disabled_monitor_specs;
+
+  MetaMonitorsConfigFlag flags;
+
+  MetaLogicalMonitorLayoutMode layout_mode;
+
+  MetaMonitorSwitchConfigType switch_config;
+};
+
+#define META_TYPE_MONITORS_CONFIG (meta_monitors_config_get_type ())
+G_DECLARE_FINAL_TYPE (MetaMonitorsConfig, meta_monitors_config,
+                      META, MONITORS_CONFIG, GObject)
+
+META_EXPORT_TEST
+MetaMonitorConfigManager * meta_monitor_config_manager_new (MetaMonitorManager *monitor_manager);
+
+META_EXPORT_TEST
+MetaMonitorConfigStore * meta_monitor_config_manager_get_store (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+gboolean meta_monitor_config_manager_assign (MetaMonitorManager *manager,
+                                             MetaMonitorsConfig *config,
+                                             GPtrArray         **crtc_assignments,
+                                             GPtrArray         **output_assignments,
+                                             GError            **error);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_get_stored (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_linear (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_fallback (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_suggested (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_orientation (MetaMonitorConfigManager *config_manager,
+                                                                         MetaMonitorsConfig       *base_config,
+                                                                         MetaMonitorTransform      transform);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_builtin_orientation (MetaMonitorConfigManager *config_manager,
+                                                                                 MetaMonitorsConfig       *base_config);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_rotate_monitor (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_switch_config (MetaMonitorConfigManager    *config_manager,
+                                                                           MetaMonitorSwitchConfigType  config_type);
+
+META_EXPORT_TEST
+void meta_monitor_config_manager_set_current (MetaMonitorConfigManager *config_manager,
+                                              MetaMonitorsConfig       *config);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_get_current (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_pop_previous (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_config_manager_get_previous (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+void meta_monitor_config_manager_clear_history (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+void meta_monitor_config_manager_save_current (MetaMonitorConfigManager *config_manager);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitors_config_new_full (GList                        *logical_monitor_configs,
+                                                    GList                        *disabled_monitors,
+                                                    MetaLogicalMonitorLayoutMode  layout_mode,
+                                                    MetaMonitorsConfigFlag        flags);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitors_config_new (MetaMonitorManager           *monitor_manager,
+                                               GList                        *logical_monitor_configs,
+                                               MetaLogicalMonitorLayoutMode  layout_mode,
+                                               MetaMonitorsConfigFlag        flags);
+
+META_EXPORT_TEST
+MetaMonitorSwitchConfigType meta_monitors_config_get_switch_config (MetaMonitorsConfig *config);
+
+META_EXPORT_TEST
+void meta_monitors_config_set_switch_config (MetaMonitorsConfig          *config,
+                                             MetaMonitorSwitchConfigType  switch_config);
+
+META_EXPORT_TEST
+void meta_monitors_config_set_parent_config (MetaMonitorsConfig *config,
+                                             MetaMonitorsConfig *parent_config);
+
+META_EXPORT_TEST
+unsigned int meta_monitors_config_key_hash (gconstpointer config_key);
+
+META_EXPORT_TEST
+gboolean meta_monitors_config_key_equal (gconstpointer config_key_a,
+                                         gconstpointer config_key_b);
+
+META_EXPORT_TEST
+void meta_monitors_config_key_free (MetaMonitorsConfigKey *config_key);
+
+META_EXPORT_TEST
+void meta_logical_monitor_config_free (MetaLogicalMonitorConfig *logical_monitor_config);
+
+META_EXPORT_TEST
+void meta_monitor_config_free (MetaMonitorConfig *monitor_config);
+
+META_EXPORT_TEST
+MetaMonitorsConfigKey * meta_create_monitors_config_key_for_current_state (MetaMonitorManager *monitor_manager);
+
+META_EXPORT_TEST
+gboolean meta_logical_monitor_configs_have_monitor (GList           *logical_monitor_configs,
+                                                    MetaMonitorSpec *monitor_spec);
+
+META_EXPORT_TEST
+gboolean meta_verify_monitor_mode_spec (MetaMonitorModeSpec *monitor_mode_spec,
+                                        GError             **error);
+
+META_EXPORT_TEST
+gboolean meta_verify_monitor_spec (MetaMonitorSpec *monitor_spec,
+                                   GError         **error);
+
+META_EXPORT_TEST
+gboolean meta_verify_monitor_config (MetaMonitorConfig *monitor_config,
+                                     GError           **error);
+
+META_EXPORT_TEST
+gboolean meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
+                                             MetaLogicalMonitorLayoutMode layout_mode,
+                                             MetaMonitorManager          *monitor_manager,
+                                             GError                     **error);
+
+META_EXPORT_TEST
+gboolean meta_verify_monitors_config (MetaMonitorsConfig *config,
+                                      MetaMonitorManager *monitor_manager,
+                                      GError            **error);
+
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaMonitorConfig, meta_monitor_config_free)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaLogicalMonitorConfig,
+                               meta_logical_monitor_config_free)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaMonitorsConfigKey,
+                               meta_monitors_config_key_free)
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-store.c b/src/backends/meta-monitor-config-store.c
--- a/src/backends/meta-monitor-config-store.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-store.c	2023-10-12 20:59:22.707167662 +0300
@@ -165,6 +165,7 @@
   STATE_MONITOR_MODE_RATE,
   STATE_MONITOR_MODE_FLAG,
   STATE_MONITOR_UNDERSCANNING,
+  STATE_MONITOR_VRR_ALLOWED,
   STATE_MONITOR_MAXBPC,
   STATE_DISABLED,
   STATE_POLICY,
@@ -450,6 +451,10 @@
           {
             parser->state = STATE_MONITOR_UNDERSCANNING;
           }
+        else if (g_str_equal (element_name, "vrr-allowed"))
+          {
+            parser->state = STATE_MONITOR_VRR_ALLOWED;
+          }
         else if (g_str_equal (element_name, "maxbpc"))
           {
             parser->state = STATE_MONITOR_MAXBPC;
@@ -547,6 +552,13 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under vrr-allowed", element_name);
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
@@ -648,6 +660,7 @@
 static gboolean
 derive_logical_monitor_layout (MetaLogicalMonitorConfig    *logical_monitor_config,
                                MetaLogicalMonitorLayoutMode layout_mode,
+                               float                        max_scale,
                                GError                     **error)
 {
   MetaMonitorConfig *monitor_config;
@@ -685,6 +698,10 @@
 
   switch (layout_mode)
     {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      width *= ceilf (max_scale);
+      height *= ceilf (max_scale);
+      /* fall through! */
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
       width = roundf (width / logical_monitor_config->scale);
       height = roundf (height / logical_monitor_config->scale);
@@ -828,6 +845,14 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_assert (g_str_equal (element_name, "vrr-allowed"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         g_assert (g_str_equal (element_name, "maxbpc"));
@@ -900,6 +925,7 @@
         GList *l;
         MetaLogicalMonitorLayoutMode layout_mode;
         MetaMonitorsConfigFlag config_flags = META_MONITORS_CONFIG_FLAG_NONE;
+        float max_scale = 1.0f;
 
         g_assert (g_str_equal (element_name, "configuration"));
 
@@ -909,18 +935,29 @@
           layout_mode =
             meta_monitor_manager_get_default_layout_mode (store->monitor_manager);
 
+        if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+          {
+            for (l = parser->current_logical_monitor_configs; l; l = l->next)
+              {
+                MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+                max_scale = MAX (max_scale, logical_monitor_config->scale);
+              }
+          }
+
         for (l = parser->current_logical_monitor_configs; l; l = l->next)
           {
             MetaLogicalMonitorConfig *logical_monitor_config = l->data;
 
             if (!derive_logical_monitor_layout (logical_monitor_config,
                                                 layout_mode,
+                                                max_scale,
                                                 error))
               return;
 
             if (!meta_verify_logical_monitor_config (logical_monitor_config,
                                                      layout_mode,
                                                      store->monitor_manager,
+                                                     max_scale,
                                                      error))
               return;
           }
@@ -1327,6 +1364,18 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        gboolean allow_vrr = TRUE;
+
+        read_bool (text, text_len,
+                   &allow_vrr,
+                   error);
+        parser->current_monitor_config->disallow_vrr = !allow_vrr;
+
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         int signed_max_bpc;
@@ -1526,6 +1575,9 @@
       if (monitor_config->enable_underscanning)
         g_string_append (buffer, "        <underscanning>yes</underscanning>\n");
 
+      if (monitor_config->disallow_vrr)
+        g_string_append (buffer, "        <vrr-allowed>no</vrr-allowed>\n");
+
       if (monitor_config->has_max_bpc)
         {
           g_string_append_printf (buffer, "        <maxbpc>%u</maxbpc>\n",
diff '--color=auto' -uraN a/src/backends/meta-monitor-config-store.c.orig b/src/backends/meta-monitor-config-store.c.orig
--- a/src/backends/meta-monitor-config-store.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor-config-store.c.orig	2023-10-12 20:59:22.670500538 +0300
@@ -0,0 +1,2145 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2017 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/meta-monitor-config-store.h"
+
+#include <gio/gio.h>
+#include <string.h>
+
+#include "backends/meta-monitor-config-manager.h"
+#include "backends/meta-monitor-config-migration.h"
+
+#define MONITORS_CONFIG_XML_FORMAT_VERSION 2
+
+#define QUOTE1(a) #a
+#define QUOTE(a) QUOTE1(a)
+
+/*
+ * Example configuration:
+ *
+ * <monitors version="2">
+ *   <configuration>
+ *     <logicalmonitor>
+ *       <x>0</x>
+ *       <y>0</y>
+ *       <scale>1</scale>
+ *       <monitor>
+ *         <monitorspec>
+ *           <connector>LVDS1</connector>
+ *           <vendor>Vendor A</vendor>
+ *           <product>Product A</product>
+ *           <serial>Serial A</serial>
+ *         </monitorspec>
+ *         <mode>
+ *           <width>1920</width>
+ *           <height>1080</height>
+ *           <rate>60.049972534179688</rate>
+ *           <flag>interlace</flag>
+ *         </mode>
+ *       </monitor>
+ *       <transform>
+ *         <rotation>right</rotation>
+ *         <flipped>no</flipped>
+ *       </transform>
+ *       <primary>yes</primary>
+ *       <presentation>no</presentation>
+ *     </logicalmonitor>
+ *     <logicalmonitor>
+ *       <x>1920</x>
+ *       <y>1080</y>
+ *       <monitor>
+ *         <monitorspec>
+ *           <connector>LVDS2</connector>
+ *           <vendor>Vendor B</vendor>
+ *           <product>Product B</product>
+ *           <serial>Serial B</serial>
+ *         </monitorspec>
+ *         <mode>
+ *           <width>1920</width>
+ *           <height>1080</height>
+ *           <rate>60.049972534179688</rate>
+ *         </mode>
+ *         <underscanning>yes</underscanning>
+ *       </monitor>
+ *       <presentation>yes</presentation>
+ *     </logicalmonitor>
+ *     <disabled>
+ *       <monitorspec>
+ *         <connector>LVDS3</connector>
+ *         <vendor>Vendor C</vendor>
+ *         <product>Product C</product>
+ *         <serial>Serial C</serial>
+ *       </monitorspec>
+ *     </disabled>
+ *   </configuration>
+ * </monitors>
+ *
+ */
+
+enum
+{
+  PROP_0,
+
+  PROP_MONITOR_MANAGER,
+
+  PROP_LAST
+};
+
+static GParamSpec *obj_props[PROP_LAST];
+
+struct _MetaMonitorConfigStore
+{
+  GObject parent;
+
+  MetaMonitorManager *monitor_manager;
+
+  GHashTable *configs;
+
+  GCancellable *save_cancellable;
+
+  GFile *user_file;
+  GFile *custom_read_file;
+  GFile *custom_write_file;
+
+  gboolean has_stores_policy;
+  GList *stores_policy;
+
+  gboolean has_dbus_policy;
+  MetaMonitorConfigPolicy policy;
+};
+
+#define META_MONITOR_CONFIG_STORE_ERROR (meta_monitor_config_store_error_quark ())
+static GQuark meta_monitor_config_store_error_quark (void);
+
+enum
+{
+  META_MONITOR_CONFIG_STORE_ERROR_NEEDS_MIGRATION
+};
+
+G_DEFINE_QUARK (meta-monitor-config-store-error-quark,
+                meta_monitor_config_store_error)
+
+typedef enum
+{
+  STATE_INITIAL,
+  STATE_UNKNOWN,
+  STATE_MONITORS,
+  STATE_CONFIGURATION,
+  STATE_MIGRATED,
+  STATE_LOGICAL_MONITOR,
+  STATE_LOGICAL_MONITOR_X,
+  STATE_LOGICAL_MONITOR_Y,
+  STATE_LOGICAL_MONITOR_PRIMARY,
+  STATE_LOGICAL_MONITOR_PRESENTATION,
+  STATE_LOGICAL_MONITOR_SCALE,
+  STATE_TRANSFORM,
+  STATE_TRANSFORM_ROTATION,
+  STATE_TRANSFORM_FLIPPED,
+  STATE_MONITOR,
+  STATE_MONITOR_SPEC,
+  STATE_MONITOR_SPEC_CONNECTOR,
+  STATE_MONITOR_SPEC_VENDOR,
+  STATE_MONITOR_SPEC_PRODUCT,
+  STATE_MONITOR_SPEC_SERIAL,
+  STATE_MONITOR_MODE,
+  STATE_MONITOR_MODE_WIDTH,
+  STATE_MONITOR_MODE_HEIGHT,
+  STATE_MONITOR_MODE_RATE,
+  STATE_MONITOR_MODE_FLAG,
+  STATE_MONITOR_UNDERSCANNING,
+  STATE_MONITOR_VRR_ALLOWED,
+  STATE_MONITOR_MAXBPC,
+  STATE_DISABLED,
+  STATE_POLICY,
+  STATE_STORES,
+  STATE_STORE,
+  STATE_DBUS,
+} ParserState;
+
+typedef struct
+{
+  ParserState state;
+  MetaMonitorConfigStore *config_store;
+  GFile *file;
+
+  GHashTable *pending_configs;
+
+  ParserState monitor_spec_parent_state;
+
+  gboolean current_was_migrated;
+  GList *current_logical_monitor_configs;
+  MetaMonitorSpec *current_monitor_spec;
+  gboolean current_transform_flipped;
+  MetaMonitorTransform current_transform;
+  MetaMonitorModeSpec *current_monitor_mode_spec;
+  MetaMonitorConfig *current_monitor_config;
+  MetaLogicalMonitorConfig *current_logical_monitor_config;
+  GList *current_disabled_monitor_specs;
+  gboolean seen_policy;
+  gboolean seen_stores;
+  gboolean seen_dbus;
+  MetaConfigStore pending_store;
+  GList *stores;
+
+  gboolean enable_dbus_set;
+  gboolean enable_dbus;
+
+  ParserState unknown_state_root;
+  int unknown_level;
+
+  MetaMonitorsConfigFlag extra_config_flags;
+} ConfigParser;
+
+G_DEFINE_TYPE (MetaMonitorConfigStore, meta_monitor_config_store,
+               G_TYPE_OBJECT)
+
+static gboolean
+text_equals (const char *text,
+             int         len,
+             const char *expect)
+{
+  if (strlen (expect) != len)
+    return FALSE;
+
+  return strncmp (text, expect, len) == 0;
+}
+
+static void
+enter_unknown_element (ConfigParser *parser,
+                       const char   *element_name,
+                       const char   *root_element_name,
+                       ParserState   root_state)
+{
+  parser->state = STATE_UNKNOWN;
+  parser->unknown_level = 1;
+  parser->unknown_state_root = root_state;
+  g_warning ("Unknown element <%s> under <%s>, ignoring",
+             element_name, root_element_name);
+}
+
+static void
+handle_start_element (GMarkupParseContext  *context,
+                      const char           *element_name,
+                      const char          **attribute_names,
+                      const char          **attribute_values,
+                      gpointer              user_data,
+                      GError              **error)
+{
+  ConfigParser *parser = user_data;
+
+  switch (parser->state)
+    {
+    case STATE_INITIAL:
+      {
+        char *version;
+
+        if (!g_str_equal (element_name, "monitors"))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                         "Invalid document element '%s'", element_name);
+            return;
+          }
+
+        if (!g_markup_collect_attributes (element_name, attribute_names, attribute_values,
+                                          error,
+                                          G_MARKUP_COLLECT_STRING, "version", &version,
+                                          G_MARKUP_COLLECT_INVALID))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Missing config file format version");
+          }
+
+        if (g_str_equal (version, "1"))
+          {
+            g_set_error_literal (error,
+                                 META_MONITOR_CONFIG_STORE_ERROR,
+                                 META_MONITOR_CONFIG_STORE_ERROR_NEEDS_MIGRATION,
+                                 "monitors.xml has the old format");
+            return;
+          }
+
+        if (!g_str_equal (version, QUOTE (MONITORS_CONFIG_XML_FORMAT_VERSION)))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Invalid or unsupported version '%s'", version);
+            return;
+          }
+
+        parser->state = STATE_MONITORS;
+        return;
+      }
+
+    case STATE_MONITORS:
+      {
+        if (g_str_equal (element_name, "configuration"))
+          {
+            parser->state = STATE_CONFIGURATION;
+            parser->current_was_migrated = FALSE;
+          }
+        else if (g_str_equal (element_name, "policy"))
+          {
+            if (parser->seen_policy)
+              {
+                g_set_error (error,
+                             G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                             "Multiple policy definitions");
+                return;
+              }
+
+            parser->seen_policy = TRUE;
+            parser->state = STATE_POLICY;
+          }
+        else
+          {
+            enter_unknown_element (parser, element_name,
+                                   "monitors", STATE_MONITORS);
+            return;
+          }
+
+        return;
+      }
+
+    case STATE_UNKNOWN:
+      {
+        parser->unknown_level++;
+
+        return;
+      }
+
+    case STATE_CONFIGURATION:
+      {
+        if (g_str_equal (element_name, "logicalmonitor"))
+          {
+            parser->current_logical_monitor_config =
+              g_new0 (MetaLogicalMonitorConfig, 1);
+
+            parser->state = STATE_LOGICAL_MONITOR;
+          }
+        else if (g_str_equal (element_name, "migrated"))
+          {
+            parser->current_was_migrated = TRUE;
+
+            parser->state = STATE_MIGRATED;
+          }
+        else if (g_str_equal (element_name, "disabled"))
+          {
+            parser->state = STATE_DISABLED;
+          }
+        else
+          {
+            enter_unknown_element (parser, element_name,
+                                   "configuration", STATE_CONFIGURATION);
+          }
+
+        return;
+      }
+
+    case STATE_MIGRATED:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Unexpected element '%s'", element_name);
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR:
+      {
+        if (g_str_equal (element_name, "x"))
+          {
+            parser->state = STATE_LOGICAL_MONITOR_X;
+          }
+        else if (g_str_equal (element_name, "y"))
+          {
+            parser->state = STATE_LOGICAL_MONITOR_Y;
+          }
+        else if (g_str_equal (element_name, "scale"))
+          {
+            parser->state = STATE_LOGICAL_MONITOR_SCALE;
+          }
+        else if (g_str_equal (element_name, "primary"))
+          {
+            parser->state = STATE_LOGICAL_MONITOR_PRIMARY;
+          }
+        else if (g_str_equal (element_name, "presentation"))
+          {
+            parser->state = STATE_LOGICAL_MONITOR_PRESENTATION;
+          }
+        else if (g_str_equal (element_name, "transform"))
+          {
+            parser->state = STATE_TRANSFORM;
+          }
+        else if (g_str_equal (element_name, "monitor"))
+          {
+            parser->current_monitor_config = g_new0 (MetaMonitorConfig, 1);
+
+            parser->state = STATE_MONITOR;
+          }
+        else
+          {
+            enter_unknown_element (parser, element_name,
+                                   "logicalmonitor", STATE_LOGICAL_MONITOR);
+          }
+
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_X:
+    case STATE_LOGICAL_MONITOR_Y:
+    case STATE_LOGICAL_MONITOR_SCALE:
+    case STATE_LOGICAL_MONITOR_PRIMARY:
+    case STATE_LOGICAL_MONITOR_PRESENTATION:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid logical monitor element '%s'", element_name);
+        return;
+      }
+
+    case STATE_TRANSFORM:
+      {
+        if (g_str_equal (element_name, "rotation"))
+          {
+            parser->state = STATE_TRANSFORM_ROTATION;
+          }
+        else if (g_str_equal (element_name, "flipped"))
+          {
+            parser->state = STATE_TRANSFORM_FLIPPED;
+          }
+
+        return;
+      }
+
+    case STATE_TRANSFORM_ROTATION:
+    case STATE_TRANSFORM_FLIPPED:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid transform element '%s'", element_name);
+        return;
+      }
+
+    case STATE_MONITOR:
+      {
+        if (g_str_equal (element_name, "monitorspec"))
+          {
+            parser->current_monitor_spec = g_new0 (MetaMonitorSpec, 1);
+            parser->monitor_spec_parent_state = STATE_MONITOR;
+            parser->state = STATE_MONITOR_SPEC;
+          }
+        else if (g_str_equal (element_name, "mode"))
+          {
+            parser->current_monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
+
+            parser->state = STATE_MONITOR_MODE;
+          }
+        else if (g_str_equal (element_name, "underscanning"))
+          {
+            parser->state = STATE_MONITOR_UNDERSCANNING;
+          }
+        else if (g_str_equal (element_name, "vrr-allowed"))
+          {
+            parser->state = STATE_MONITOR_VRR_ALLOWED;
+          }
+        else if (g_str_equal (element_name, "maxbpc"))
+          {
+            parser->state = STATE_MONITOR_MAXBPC;
+          }
+        else
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                         "Invalid monitor element '%s'", element_name);
+            return;
+          }
+
+        return;
+      }
+
+    case STATE_MONITOR_SPEC:
+      {
+        if (g_str_equal (element_name, "connector"))
+          {
+            parser->state = STATE_MONITOR_SPEC_CONNECTOR;
+          }
+        else if (g_str_equal (element_name, "vendor"))
+          {
+            parser->state = STATE_MONITOR_SPEC_VENDOR;
+          }
+        else if (g_str_equal (element_name, "product"))
+          {
+            parser->state = STATE_MONITOR_SPEC_PRODUCT;
+          }
+        else if (g_str_equal (element_name, "serial"))
+          {
+            parser->state = STATE_MONITOR_SPEC_SERIAL;
+          }
+        else
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                         "Invalid monitor spec element '%s'", element_name);
+            return;
+          }
+
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_CONNECTOR:
+    case STATE_MONITOR_SPEC_VENDOR:
+    case STATE_MONITOR_SPEC_PRODUCT:
+    case STATE_MONITOR_SPEC_SERIAL:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid monitor spec element '%s'", element_name);
+        return;
+      }
+
+    case STATE_MONITOR_MODE:
+      {
+        if (g_str_equal (element_name, "width"))
+          {
+            parser->state = STATE_MONITOR_MODE_WIDTH;
+          }
+        else if (g_str_equal (element_name, "height"))
+          {
+            parser->state = STATE_MONITOR_MODE_HEIGHT;
+          }
+        else if (g_str_equal (element_name, "rate"))
+          {
+            parser->state = STATE_MONITOR_MODE_RATE;
+          }
+        else if (g_str_equal (element_name, "flag"))
+          {
+            parser->state = STATE_MONITOR_MODE_FLAG;
+          }
+        else
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                         "Invalid mode element '%s'", element_name);
+            return;
+          }
+
+        return;
+      }
+
+    case STATE_MONITOR_MODE_WIDTH:
+    case STATE_MONITOR_MODE_HEIGHT:
+    case STATE_MONITOR_MODE_RATE:
+    case STATE_MONITOR_MODE_FLAG:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid mode sub element '%s'", element_name);
+        return;
+      }
+
+    case STATE_MONITOR_UNDERSCANNING:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under underscanning", element_name);
+        return;
+      }
+
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under vrr-allowed", element_name);
+        return;
+      }
+
+    case STATE_MONITOR_MAXBPC:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under maxbpc", element_name);
+        return;
+      }
+
+    case STATE_DISABLED:
+      {
+        if (!g_str_equal (element_name, "monitorspec"))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                         "Invalid element '%s' under disabled", element_name);
+            return;
+          }
+
+        parser->current_monitor_spec = g_new0 (MetaMonitorSpec, 1);
+        parser->monitor_spec_parent_state = STATE_DISABLED;
+        parser->state = STATE_MONITOR_SPEC;
+
+        return;
+      }
+
+    case STATE_POLICY:
+      {
+        if (!(parser->extra_config_flags &
+              META_MONITORS_CONFIG_FLAG_SYSTEM_CONFIG))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Policy can only be defined in system level configurations");
+            return;
+          }
+
+        if (g_str_equal (element_name, "stores"))
+          {
+            if (parser->seen_stores)
+              {
+                g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                             "Multiple stores elements under policy");
+                return;
+              }
+
+            parser->seen_stores = TRUE;
+            parser->state = STATE_STORES;
+          }
+        else if (g_str_equal (element_name, "dbus"))
+          {
+            if (parser->seen_dbus)
+              {
+                g_set_error (error,
+                             G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                             "Multiple dbus elements under policy");
+                return;
+              }
+
+            parser->seen_dbus = TRUE;
+            parser->state = STATE_DBUS;
+          }
+        else
+          {
+            enter_unknown_element (parser, element_name,
+                                   "policy", STATE_POLICY);
+          }
+
+        return;
+      }
+
+    case STATE_STORES:
+      {
+        if (g_str_equal (element_name, "store"))
+          {
+            parser->state = STATE_STORE;
+          }
+        else
+          {
+            enter_unknown_element (parser, element_name,
+                                   "stores", STATE_STORES);
+          }
+
+        return;
+      }
+
+    case STATE_STORE:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid store sub element '%s'", element_name);
+        return;
+      }
+
+    case STATE_DBUS:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid dbus sub element '%s'", element_name);
+        return;
+      }
+    }
+}
+
+static gboolean
+derive_logical_monitor_layout (MetaLogicalMonitorConfig    *logical_monitor_config,
+                               MetaLogicalMonitorLayoutMode layout_mode,
+                               GError                     **error)
+{
+  MetaMonitorConfig *monitor_config;
+  int mode_width, mode_height;
+  int width = 0, height = 0;
+  GList *l;
+
+  monitor_config = logical_monitor_config->monitor_configs->data;
+  mode_width = monitor_config->mode_spec->width;
+  mode_height = monitor_config->mode_spec->height;
+
+  for (l = logical_monitor_config->monitor_configs->next; l; l = l->next)
+    {
+      monitor_config = l->data;
+
+      if (monitor_config->mode_spec->width != mode_width ||
+          monitor_config->mode_spec->height != mode_height)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Monitors in logical monitor incompatible");
+          return FALSE;
+        }
+    }
+
+  if (meta_monitor_transform_is_rotated (logical_monitor_config->transform))
+    {
+      width = mode_height;
+      height = mode_width;
+    }
+  else
+    {
+      width = mode_width;
+      height = mode_height;
+    }
+
+  switch (layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      width = roundf (width / logical_monitor_config->scale);
+      height = roundf (height / logical_monitor_config->scale);
+      break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      break;
+    }
+
+  logical_monitor_config->layout.width = width;
+  logical_monitor_config->layout.height = height;
+
+  return TRUE;
+}
+
+static void
+finish_monitor_spec (ConfigParser *parser)
+{
+  switch (parser->monitor_spec_parent_state)
+    {
+    case STATE_MONITOR:
+      {
+        parser->current_monitor_config->monitor_spec =
+          parser->current_monitor_spec;
+        parser->current_monitor_spec = NULL;
+
+        return;
+      }
+    case STATE_DISABLED:
+      {
+        parser->current_disabled_monitor_specs =
+          g_list_prepend (parser->current_disabled_monitor_specs,
+                          parser->current_monitor_spec);
+        parser->current_monitor_spec = NULL;
+
+        return;
+      }
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+static void
+handle_end_element (GMarkupParseContext  *context,
+                    const char           *element_name,
+                    gpointer              user_data,
+                    GError              **error)
+{
+  ConfigParser *parser = user_data;
+
+  switch (parser->state)
+    {
+    case STATE_LOGICAL_MONITOR_X:
+    case STATE_LOGICAL_MONITOR_Y:
+    case STATE_LOGICAL_MONITOR_SCALE:
+    case STATE_LOGICAL_MONITOR_PRIMARY:
+    case STATE_LOGICAL_MONITOR_PRESENTATION:
+      {
+        parser->state = STATE_LOGICAL_MONITOR;
+        return;
+      }
+
+    case STATE_TRANSFORM:
+      {
+        g_assert (g_str_equal (element_name, "transform"));
+
+        parser->current_logical_monitor_config->transform =
+          parser->current_transform;
+        if (parser->current_transform_flipped)
+          {
+            parser->current_logical_monitor_config->transform +=
+              META_MONITOR_TRANSFORM_FLIPPED;
+          }
+
+        parser->current_transform = META_MONITOR_TRANSFORM_NORMAL;
+        parser->current_transform_flipped = FALSE;
+
+        parser->state = STATE_LOGICAL_MONITOR;
+        return;
+      }
+
+    case STATE_TRANSFORM_ROTATION:
+    case STATE_TRANSFORM_FLIPPED:
+      {
+        parser->state = STATE_TRANSFORM;
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_CONNECTOR:
+    case STATE_MONITOR_SPEC_VENDOR:
+    case STATE_MONITOR_SPEC_PRODUCT:
+    case STATE_MONITOR_SPEC_SERIAL:
+      {
+        parser->state = STATE_MONITOR_SPEC;
+        return;
+      }
+
+    case STATE_MONITOR_SPEC:
+      {
+        g_assert (g_str_equal (element_name, "monitorspec"));
+
+        if (!meta_verify_monitor_spec (parser->current_monitor_spec, error))
+          return;
+
+        finish_monitor_spec (parser);
+
+        parser->state = parser->monitor_spec_parent_state;
+        return;
+      }
+
+    case STATE_MONITOR_MODE_WIDTH:
+    case STATE_MONITOR_MODE_HEIGHT:
+    case STATE_MONITOR_MODE_RATE:
+    case STATE_MONITOR_MODE_FLAG:
+      {
+        parser->state = STATE_MONITOR_MODE;
+        return;
+      }
+
+    case STATE_MONITOR_MODE:
+      {
+        g_assert (g_str_equal (element_name, "mode"));
+
+        if (!meta_verify_monitor_mode_spec (parser->current_monitor_mode_spec,
+                                            error))
+          return;
+
+        parser->current_monitor_config->mode_spec =
+          parser->current_monitor_mode_spec;
+        parser->current_monitor_mode_spec = NULL;
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
+    case STATE_MONITOR_UNDERSCANNING:
+      {
+        g_assert (g_str_equal (element_name, "underscanning"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_assert (g_str_equal (element_name, "vrr-allowed"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
+    case STATE_MONITOR_MAXBPC:
+      {
+        g_assert (g_str_equal (element_name, "maxbpc"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
+    case STATE_MONITOR:
+      {
+        MetaLogicalMonitorConfig *logical_monitor_config;
+
+        g_assert (g_str_equal (element_name, "monitor"));
+
+        if (!meta_verify_monitor_config (parser->current_monitor_config, error))
+          return;
+
+        logical_monitor_config = parser->current_logical_monitor_config;
+
+        logical_monitor_config->monitor_configs =
+          g_list_append (logical_monitor_config->monitor_configs,
+                         parser->current_monitor_config);
+        parser->current_monitor_config = NULL;
+
+        parser->state = STATE_LOGICAL_MONITOR;
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR:
+      {
+        MetaLogicalMonitorConfig *logical_monitor_config =
+          parser->current_logical_monitor_config;
+
+        g_assert (g_str_equal (element_name, "logicalmonitor"));
+
+        if (parser->current_was_migrated)
+          logical_monitor_config->scale = -1;
+        else if (logical_monitor_config->scale == 0)
+          logical_monitor_config->scale = 1;
+
+        parser->current_logical_monitor_configs =
+          g_list_append (parser->current_logical_monitor_configs,
+                         logical_monitor_config);
+        parser->current_logical_monitor_config = NULL;
+
+        parser->state = STATE_CONFIGURATION;
+        return;
+      }
+
+    case STATE_MIGRATED:
+      {
+        g_assert (g_str_equal (element_name, "migrated"));
+
+        parser->state = STATE_CONFIGURATION;
+        return;
+      }
+
+    case STATE_DISABLED:
+      {
+        g_assert (g_str_equal (element_name, "disabled"));
+
+        parser->state = STATE_CONFIGURATION;
+        return;
+      }
+
+    case STATE_CONFIGURATION:
+      {
+        MetaMonitorConfigStore *store = parser->config_store;
+        MetaMonitorsConfig *config;
+        GList *l;
+        MetaLogicalMonitorLayoutMode layout_mode;
+        MetaMonitorsConfigFlag config_flags = META_MONITORS_CONFIG_FLAG_NONE;
+
+        g_assert (g_str_equal (element_name, "configuration"));
+
+        if (parser->current_was_migrated)
+          layout_mode = META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+        else
+          layout_mode =
+            meta_monitor_manager_get_default_layout_mode (store->monitor_manager);
+
+        for (l = parser->current_logical_monitor_configs; l; l = l->next)
+          {
+            MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+            if (!derive_logical_monitor_layout (logical_monitor_config,
+                                                layout_mode,
+                                                error))
+              return;
+
+            if (!meta_verify_logical_monitor_config (logical_monitor_config,
+                                                     layout_mode,
+                                                     store->monitor_manager,
+                                                     error))
+              return;
+          }
+
+        if (parser->current_was_migrated)
+          config_flags |= META_MONITORS_CONFIG_FLAG_MIGRATED;
+
+        config_flags |= parser->extra_config_flags;
+
+        config =
+          meta_monitors_config_new_full (parser->current_logical_monitor_configs,
+                                         parser->current_disabled_monitor_specs,
+                                         layout_mode,
+                                         config_flags);
+
+        parser->current_logical_monitor_configs = NULL;
+        parser->current_disabled_monitor_specs = NULL;
+
+        if (!meta_verify_monitors_config (config, store->monitor_manager,
+                                          error))
+          {
+            g_object_unref (config);
+            return;
+          }
+
+        g_hash_table_replace (parser->pending_configs,
+                              config->key, config);
+
+        parser->state = STATE_MONITORS;
+        return;
+      }
+
+    case STATE_STORE:
+      {
+        g_assert (g_str_equal (element_name, "store"));
+
+        if (parser->pending_store == -1)
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Got an empty store");
+            return;
+          }
+
+        if (g_list_find (parser->stores,
+                         GINT_TO_POINTER (parser->pending_store)))
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Multiple identical stores in policy");
+            return;
+          }
+
+        parser->stores =
+          g_list_append (parser->stores,
+                         GINT_TO_POINTER (parser->pending_store));
+        parser->pending_store = -1;
+
+        parser->state = STATE_STORES;
+        return;
+      }
+
+    case STATE_STORES:
+      {
+        g_assert (g_str_equal (element_name, "stores"));
+
+        if (parser->config_store->has_stores_policy)
+          {
+            g_warning ("Ignoring stores policy from '%s', "
+                       "it has already been configured",
+                       g_file_peek_path (parser->file));
+            g_clear_pointer (&parser->stores, g_list_free);
+          }
+        else
+          {
+            parser->config_store->stores_policy =
+              g_steal_pointer (&parser->stores);
+            parser->config_store->has_stores_policy = TRUE;
+          }
+
+        parser->state = STATE_POLICY;
+        return;
+      }
+
+    case STATE_DBUS:
+      {
+        if (!parser->config_store->has_dbus_policy)
+          {
+            parser->config_store->has_dbus_policy = TRUE;
+            parser->config_store->policy.enable_dbus = parser->enable_dbus;
+            parser->enable_dbus_set = FALSE;
+          }
+        else
+          {
+            g_warning ("Policy for monitor configuration via D-Bus "
+                       "has already been set, ignoring policy from '%s'",
+                       g_file_get_path (parser->file));
+          }
+        parser->state = STATE_POLICY;
+
+        return;
+      }
+
+    case STATE_POLICY:
+      {
+        g_assert (g_str_equal (element_name, "policy"));
+
+        parser->state = STATE_MONITORS;
+        return;
+      }
+
+    case STATE_UNKNOWN:
+      {
+        parser->unknown_level--;
+        if (parser->unknown_level == 0)
+          {
+            g_assert (parser->unknown_state_root >= 0);
+            parser->state = parser->unknown_state_root;
+            parser->unknown_state_root = -1;
+          }
+        return;
+      }
+
+    case STATE_MONITORS:
+      {
+        g_assert (g_str_equal (element_name, "monitors"));
+
+        parser->state = STATE_INITIAL;
+        return;
+      }
+
+    case STATE_INITIAL:
+      {
+        g_assert_not_reached ();
+      }
+    }
+}
+
+static gboolean
+read_int (const char  *text,
+          gsize        text_len,
+          gint        *out_value,
+          GError     **error)
+{
+  char buf[64];
+  int64_t value;
+  char *end;
+
+  strncpy (buf, text, text_len);
+  buf[MIN (63, text_len)] = 0;
+
+  value = g_ascii_strtoll (buf, &end, 10);
+
+  if (*end || value < 0 || value > G_MAXINT16)
+    {
+      g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                   "Expected a number, got %s", buf);
+      return FALSE;
+    }
+  else
+    {
+      *out_value = value;
+      return TRUE;
+    }
+}
+
+static gboolean
+read_float (const char  *text,
+            gsize        text_len,
+            float       *out_value,
+            GError     **error)
+{
+  char buf[64];
+  float value;
+  char *end;
+
+  strncpy (buf, text, text_len);
+  buf[MIN (63, text_len)] = 0;
+
+  value = g_ascii_strtod (buf, &end);
+
+  if (*end)
+    {
+      g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                   "Expected a number, got %s", buf);
+      return FALSE;
+    }
+  else
+    {
+      *out_value = value;
+      return TRUE;
+    }
+}
+
+static gboolean
+read_bool (const char  *text,
+           gsize        text_len,
+           gboolean    *out_value,
+           GError     **error)
+{
+  if (text_equals (text, text_len, "no"))
+    {
+      *out_value = FALSE;
+      return TRUE;
+    }
+  else if (text_equals (text, text_len, "yes"))
+    {
+      *out_value = TRUE;
+      return TRUE;
+    }
+  else
+    {
+      g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                   "Invalid boolean value '%.*s'", (int) text_len, text);
+      return FALSE;
+    }
+}
+
+static gboolean
+is_all_whitespace (const char *text,
+                   gsize       text_len)
+{
+  gsize i;
+
+  for (i = 0; i < text_len; i++)
+    if (!g_ascii_isspace (text[i]))
+      return FALSE;
+
+  return TRUE;
+}
+
+static void
+handle_text (GMarkupParseContext *context,
+             const gchar         *text,
+             gsize                text_len,
+             gpointer             user_data,
+             GError             **error)
+{
+  ConfigParser *parser = user_data;
+
+  switch (parser->state)
+    {
+    case STATE_UNKNOWN:
+      return;
+
+    case STATE_INITIAL:
+    case STATE_MONITORS:
+    case STATE_CONFIGURATION:
+    case STATE_MIGRATED:
+    case STATE_LOGICAL_MONITOR:
+    case STATE_MONITOR:
+    case STATE_MONITOR_SPEC:
+    case STATE_MONITOR_MODE:
+    case STATE_TRANSFORM:
+    case STATE_DISABLED:
+    case STATE_POLICY:
+    case STATE_STORES:
+      {
+        if (!is_all_whitespace (text, text_len))
+          g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                       "Unexpected content at this point");
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_CONNECTOR:
+      {
+        parser->current_monitor_spec->connector = g_strndup (text, text_len);
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_VENDOR:
+      {
+        parser->current_monitor_spec->vendor = g_strndup (text, text_len);
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_PRODUCT:
+      {
+        parser->current_monitor_spec->product = g_strndup (text, text_len);
+        return;
+      }
+
+    case STATE_MONITOR_SPEC_SERIAL:
+      {
+        parser->current_monitor_spec->serial = g_strndup (text, text_len);
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_X:
+      {
+        read_int (text, text_len,
+                  &parser->current_logical_monitor_config->layout.x, error);
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_Y:
+      {
+        read_int (text, text_len,
+                  &parser->current_logical_monitor_config->layout.y, error);
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_SCALE:
+      {
+        if (!read_float (text, text_len,
+                         &parser->current_logical_monitor_config->scale, error))
+          return;
+
+        if (parser->current_logical_monitor_config->scale <= 0.0)
+          {
+            g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                         "Logical monitor scale '%g' invalid",
+                         parser->current_logical_monitor_config->scale);
+            return;
+          }
+
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_PRIMARY:
+      {
+        read_bool (text, text_len,
+                   &parser->current_logical_monitor_config->is_primary,
+                   error);
+        return;
+      }
+
+    case STATE_LOGICAL_MONITOR_PRESENTATION:
+      {
+        read_bool (text, text_len,
+                   &parser->current_logical_monitor_config->is_presentation,
+                   error);
+        return;
+      }
+
+    case STATE_TRANSFORM_ROTATION:
+      {
+        if (text_equals (text, text_len, "normal"))
+          parser->current_transform = META_MONITOR_TRANSFORM_NORMAL;
+        else if (text_equals (text, text_len, "left"))
+          parser->current_transform = META_MONITOR_TRANSFORM_90;
+        else if (text_equals (text, text_len, "upside_down"))
+          parser->current_transform = META_MONITOR_TRANSFORM_180;
+        else if (text_equals (text, text_len, "right"))
+          parser->current_transform = META_MONITOR_TRANSFORM_270;
+        else
+          g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                       "Invalid rotation type %.*s", (int)text_len, text);
+
+        return;
+      }
+
+    case STATE_TRANSFORM_FLIPPED:
+      {
+        read_bool (text, text_len,
+                   &parser->current_transform_flipped,
+                   error);
+        return;
+      }
+
+    case STATE_MONITOR_MODE_WIDTH:
+      {
+        read_int (text, text_len,
+                  &parser->current_monitor_mode_spec->width,
+                  error);
+        return;
+      }
+
+    case STATE_MONITOR_MODE_HEIGHT:
+      {
+        read_int (text, text_len,
+                  &parser->current_monitor_mode_spec->height,
+                  error);
+        return;
+      }
+
+    case STATE_MONITOR_MODE_RATE:
+      {
+        read_float (text, text_len,
+                    &parser->current_monitor_mode_spec->refresh_rate,
+                    error);
+        return;
+      }
+
+    case STATE_MONITOR_MODE_FLAG:
+      {
+        if (text_equals (text, text_len, "interlace"))
+          {
+            parser->current_monitor_mode_spec->flags |=
+              META_CRTC_MODE_FLAG_INTERLACE;
+          }
+        else
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Invalid mode flag %.*s", (int) text_len, text);
+          }
+
+        return;
+      }
+
+    case STATE_MONITOR_UNDERSCANNING:
+      {
+        read_bool (text, text_len,
+                   &parser->current_monitor_config->enable_underscanning,
+                   error);
+        return;
+      }
+
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        gboolean allow_vrr = TRUE;
+
+        read_bool (text, text_len,
+                   &allow_vrr,
+                   error);
+        parser->current_monitor_config->disallow_vrr = !allow_vrr;
+
+        return;
+      }
+
+    case STATE_MONITOR_MAXBPC:
+      {
+        int signed_max_bpc;
+
+        if (read_int (text, text_len, &signed_max_bpc, error))
+          {
+            if (signed_max_bpc >= 0)
+              {
+                parser->current_monitor_config->has_max_bpc = TRUE;
+                parser->current_monitor_config->max_bpc = signed_max_bpc;
+              }
+            else
+              {
+                g_set_error (error, G_MARKUP_ERROR,
+                             G_MARKUP_ERROR_INVALID_CONTENT,
+                             "Invalid negative maxbpc value \"%s\"",
+                             text);
+              }
+          }
+
+        return;
+      }
+
+    case STATE_STORE:
+      {
+        MetaConfigStore store;
+
+        if (parser->pending_store != -1)
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Multiple store strings");
+            return;
+          }
+
+        if (text_equals (text, text_len, "system"))
+          {
+            store = META_CONFIG_STORE_SYSTEM;
+          }
+        else if (text_equals (text, text_len, "user"))
+          {
+            store = META_CONFIG_STORE_USER;
+          }
+        else
+          {
+            g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,
+                         "Invalid store %.*s", (int) text_len, text);
+            return;
+          }
+
+        parser->pending_store = store;
+        return;
+      }
+
+    case STATE_DBUS:
+      {
+        parser->enable_dbus_set = TRUE;
+        read_bool (text, text_len,
+                   &parser->enable_dbus,
+                   error);
+        return;
+      }
+    }
+}
+
+static const GMarkupParser config_parser = {
+  .start_element = handle_start_element,
+  .end_element = handle_end_element,
+  .text = handle_text
+};
+
+static gboolean
+read_config_file (MetaMonitorConfigStore  *config_store,
+                  GFile                   *file,
+                  MetaMonitorsConfigFlag   extra_config_flags,
+                  GHashTable             **out_configs,
+                  GError                 **error)
+{
+  char *buffer;
+  gsize size;
+  ConfigParser parser;
+  GMarkupParseContext *parse_context;
+
+  if (!g_file_load_contents (file, NULL, &buffer, &size, NULL, error))
+    return FALSE;
+
+  parser = (ConfigParser) {
+    .state = STATE_INITIAL,
+    .file = file,
+    .config_store = config_store,
+    .pending_configs = g_hash_table_new_full (meta_monitors_config_key_hash,
+                                              meta_monitors_config_key_equal,
+                                              NULL,
+                                              g_object_unref),
+    .extra_config_flags = extra_config_flags,
+    .unknown_state_root = -1,
+    .pending_store = -1,
+  };
+
+  parse_context = g_markup_parse_context_new (&config_parser,
+                                              G_MARKUP_TREAT_CDATA_AS_TEXT |
+                                              G_MARKUP_PREFIX_ERROR_POSITION,
+                                              &parser, NULL);
+  if (!g_markup_parse_context_parse (parse_context, buffer, size, error))
+    {
+      g_list_free_full (parser.current_logical_monitor_configs,
+                        (GDestroyNotify) meta_logical_monitor_config_free);
+      g_clear_pointer (&parser.current_monitor_spec,
+                       meta_monitor_spec_free);
+      g_free (parser.current_monitor_mode_spec);
+      g_clear_pointer (&parser.current_monitor_config,
+                      meta_monitor_config_free);
+      g_clear_pointer (&parser.current_logical_monitor_config,
+                       meta_logical_monitor_config_free);
+      g_list_free (parser.stores);
+      g_hash_table_unref (parser.pending_configs);
+      return FALSE;
+    }
+
+  *out_configs = g_steal_pointer (&parser.pending_configs);
+
+  g_markup_parse_context_free (parse_context);
+  g_free (buffer);
+
+  return TRUE;
+}
+
+MetaMonitorsConfig *
+meta_monitor_config_store_lookup (MetaMonitorConfigStore *config_store,
+                                  MetaMonitorsConfigKey  *key)
+{
+  return META_MONITORS_CONFIG (g_hash_table_lookup (config_store->configs,
+                                                    key));
+}
+
+static void
+append_monitor_spec (GString         *buffer,
+                     MetaMonitorSpec *monitor_spec,
+                     const char      *indentation)
+{
+  char *escaped;
+
+  g_string_append_printf (buffer, "%s<monitorspec>\n", indentation);
+
+  escaped = g_markup_escape_text (monitor_spec->connector, -1);
+  g_string_append_printf (buffer, "%s  <connector>%s</connector>\n",
+                          indentation,
+                          escaped);
+  g_free (escaped);
+
+  escaped = g_markup_escape_text (monitor_spec->vendor, -1);
+  g_string_append_printf (buffer, "%s  <vendor>%s</vendor>\n",
+                          indentation,
+                          escaped);
+  g_free (escaped);
+
+  escaped = g_markup_escape_text (monitor_spec->product, -1);
+  g_string_append_printf (buffer, "%s  <product>%s</product>\n",
+                          indentation,
+                          escaped);
+  g_free (escaped);
+
+  escaped = g_markup_escape_text (monitor_spec->serial, -1);
+  g_string_append_printf (buffer, "%s  <serial>%s</serial>\n",
+                          indentation,
+                          escaped);
+  g_free (escaped);
+
+  g_string_append_printf (buffer, "%s</monitorspec>\n", indentation);
+}
+
+static void
+append_monitors (GString *buffer,
+                 GList   *monitor_configs)
+{
+  GList *l;
+
+  for (l = monitor_configs; l; l = l->next)
+    {
+      MetaMonitorConfig *monitor_config = l->data;
+      char rate_str[G_ASCII_DTOSTR_BUF_SIZE];
+
+      g_ascii_formatd (rate_str, sizeof (rate_str),
+                       "%.3f", monitor_config->mode_spec->refresh_rate);
+
+      g_string_append (buffer, "      <monitor>\n");
+      append_monitor_spec (buffer, monitor_config->monitor_spec, "        ");
+      g_string_append (buffer, "        <mode>\n");
+      g_string_append_printf (buffer, "          <width>%d</width>\n",
+                              monitor_config->mode_spec->width);
+      g_string_append_printf (buffer, "          <height>%d</height>\n",
+                              monitor_config->mode_spec->height);
+      g_string_append_printf (buffer, "          <rate>%s</rate>\n",
+                              rate_str);
+      if (monitor_config->mode_spec->flags & META_CRTC_MODE_FLAG_INTERLACE)
+        g_string_append_printf (buffer, "          <flag>interlace</flag>\n");
+      g_string_append (buffer, "        </mode>\n");
+      if (monitor_config->enable_underscanning)
+        g_string_append (buffer, "        <underscanning>yes</underscanning>\n");
+
+      if (monitor_config->disallow_vrr)
+        g_string_append (buffer, "        <vrr-allowed>no</vrr-allowed>\n");
+
+      if (monitor_config->has_max_bpc)
+        {
+          g_string_append_printf (buffer, "        <maxbpc>%u</maxbpc>\n",
+                                  monitor_config->max_bpc);
+        }
+      g_string_append (buffer, "      </monitor>\n");
+    }
+}
+
+static const char *
+bool_to_string (gboolean value)
+{
+  return value ? "yes" : "no";
+}
+
+static void
+append_transform (GString             *buffer,
+                  MetaMonitorTransform transform)
+{
+  const char *rotation = NULL;
+  gboolean flipped = FALSE;
+
+  switch (transform)
+    {
+    case META_MONITOR_TRANSFORM_NORMAL:
+      return;
+    case META_MONITOR_TRANSFORM_90:
+      rotation = "left";
+      break;
+    case META_MONITOR_TRANSFORM_180:
+      rotation = "upside_down";
+      break;
+    case META_MONITOR_TRANSFORM_270:
+      rotation = "right";
+      break;
+    case META_MONITOR_TRANSFORM_FLIPPED:
+      rotation = "normal";
+      flipped = TRUE;
+      break;
+    case META_MONITOR_TRANSFORM_FLIPPED_90:
+      rotation = "left";
+      flipped = TRUE;
+      break;
+    case META_MONITOR_TRANSFORM_FLIPPED_180:
+      rotation = "upside_down";
+      flipped = TRUE;
+      break;
+    case META_MONITOR_TRANSFORM_FLIPPED_270:
+      rotation = "right";
+      flipped = TRUE;
+      break;
+    }
+
+  g_string_append (buffer, "      <transform>\n");
+  g_string_append_printf (buffer, "        <rotation>%s</rotation>\n",
+                          rotation);
+  g_string_append_printf (buffer, "        <flipped>%s</flipped>\n",
+                          bool_to_string (flipped));
+  g_string_append (buffer, "      </transform>\n");
+}
+
+static void
+append_logical_monitor_xml (GString                  *buffer,
+                            MetaMonitorsConfig       *config,
+                            MetaLogicalMonitorConfig *logical_monitor_config)
+{
+  char scale_str[G_ASCII_DTOSTR_BUF_SIZE];
+
+  g_string_append (buffer, "    <logicalmonitor>\n");
+  g_string_append_printf (buffer, "      <x>%d</x>\n",
+                          logical_monitor_config->layout.x);
+  g_string_append_printf (buffer, "      <y>%d</y>\n",
+                          logical_monitor_config->layout.y);
+  g_ascii_dtostr (scale_str, G_ASCII_DTOSTR_BUF_SIZE,
+                  logical_monitor_config->scale);
+  if ((config->flags & META_MONITORS_CONFIG_FLAG_MIGRATED) == 0)
+    g_string_append_printf (buffer, "      <scale>%s</scale>\n",
+                            scale_str);
+  if (logical_monitor_config->is_primary)
+    g_string_append (buffer, "      <primary>yes</primary>\n");
+  if (logical_monitor_config->is_presentation)
+    g_string_append (buffer, "      <presentation>yes</presentation>\n");
+  append_transform (buffer, logical_monitor_config->transform);
+  append_monitors (buffer, logical_monitor_config->monitor_configs);
+  g_string_append (buffer, "    </logicalmonitor>\n");
+}
+
+static GString *
+generate_config_xml (MetaMonitorConfigStore *config_store)
+{
+  GString *buffer;
+  GHashTableIter iter;
+  MetaMonitorsConfig *config;
+
+  buffer = g_string_new ("");
+  g_string_append_printf (buffer, "<monitors version=\"%d\">\n",
+                          MONITORS_CONFIG_XML_FORMAT_VERSION);
+
+  g_hash_table_iter_init (&iter, config_store->configs);
+  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &config))
+    {
+      GList *l;
+
+      if (config->flags & META_MONITORS_CONFIG_FLAG_SYSTEM_CONFIG)
+        continue;
+
+      g_string_append (buffer, "  <configuration>\n");
+
+      if (config->flags & META_MONITORS_CONFIG_FLAG_MIGRATED)
+        g_string_append (buffer, "    <migrated/>\n");
+
+      for (l = config->logical_monitor_configs; l; l = l->next)
+        {
+          MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+          append_logical_monitor_xml (buffer, config, logical_monitor_config);
+        }
+
+      if (config->disabled_monitor_specs)
+        {
+          g_string_append (buffer, "    <disabled>\n");
+          for (l = config->disabled_monitor_specs; l; l = l->next)
+            {
+              MetaMonitorSpec *monitor_spec = l->data;
+
+              append_monitor_spec (buffer, monitor_spec, "      ");
+            }
+          g_string_append (buffer, "    </disabled>\n");
+        }
+
+      g_string_append (buffer, "  </configuration>\n");
+    }
+
+  g_string_append (buffer, "</monitors>\n");
+
+  return buffer;
+}
+
+typedef struct _SaveData
+{
+  MetaMonitorConfigStore *config_store;
+  GString *buffer;
+} SaveData;
+
+static void
+saved_cb (GObject      *object,
+          GAsyncResult *result,
+          gpointer      user_data)
+{
+  SaveData *data = user_data;
+  GError *error = NULL;
+
+  if (!g_file_replace_contents_finish (G_FILE (object), result, NULL, &error))
+    {
+      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+        {
+          g_warning ("Saving monitor configuration failed: %s", error->message);
+          g_clear_object (&data->config_store->save_cancellable);
+        }
+
+      g_error_free (error);
+    }
+  else
+    {
+      g_clear_object (&data->config_store->save_cancellable);
+    }
+
+  g_clear_object (&data->config_store);
+  g_string_free (data->buffer, TRUE);
+  g_free (data);
+}
+
+static void
+meta_monitor_config_store_save_sync (MetaMonitorConfigStore *config_store)
+{
+  GError *error = NULL;
+  GFile *file;
+  GString *buffer;
+
+  if (config_store->custom_write_file)
+    file = config_store->custom_write_file;
+  else
+    file = config_store->user_file;
+
+  buffer = generate_config_xml (config_store);
+
+  if (!g_file_replace_contents (file,
+                                buffer->str, buffer->len,
+                                NULL,
+                                FALSE,
+                                G_FILE_CREATE_REPLACE_DESTINATION,
+                                NULL,
+                                NULL,
+                                &error))
+    {
+      g_warning ("Saving monitor configuration failed: %s",
+                 error->message);
+      g_error_free (error);
+    }
+
+  g_string_free (buffer, TRUE);
+}
+
+static void
+meta_monitor_config_store_save (MetaMonitorConfigStore *config_store)
+{
+  GString *buffer;
+  SaveData *data;
+
+  if (config_store->save_cancellable)
+    {
+      g_cancellable_cancel (config_store->save_cancellable);
+      g_clear_object (&config_store->save_cancellable);
+    }
+
+  /*
+   * Custom write file is only ever used by the test suite, and the test suite
+   * will want to have be able to read back the content immediately, so for
+   * custom write files, do the content replacement synchronously.
+   */
+  if (config_store->custom_write_file)
+    {
+      meta_monitor_config_store_save_sync (config_store);
+      return;
+    }
+
+  if (config_store->has_stores_policy &&
+      !g_list_find (config_store->stores_policy,
+                    GINT_TO_POINTER (META_CONFIG_STORE_USER)))
+    return;
+
+  config_store->save_cancellable = g_cancellable_new ();
+
+  buffer = generate_config_xml (config_store);
+
+  data = g_new0 (SaveData, 1);
+  *data = (SaveData) {
+    .config_store = g_object_ref (config_store),
+    .buffer = buffer
+  };
+
+  g_file_replace_contents_async (config_store->user_file,
+                                 buffer->str, buffer->len,
+                                 NULL,
+                                 TRUE,
+                                 G_FILE_CREATE_REPLACE_DESTINATION,
+                                 config_store->save_cancellable,
+                                 saved_cb, data);
+}
+
+static void
+maybe_save_configs (MetaMonitorConfigStore *config_store)
+{
+  /*
+   * If a custom file is used, it means we are run by the test suite. When this
+   * is done, avoid replacing the user configuration file with test data,
+   * except if a custom write file is set as well.
+   */
+  if (!config_store->custom_read_file || config_store->custom_write_file)
+    meta_monitor_config_store_save (config_store);
+}
+
+static gboolean
+is_system_config (MetaMonitorsConfig *config)
+{
+  return !!(config->flags & META_MONITORS_CONFIG_FLAG_SYSTEM_CONFIG);
+}
+
+void
+meta_monitor_config_store_add (MetaMonitorConfigStore *config_store,
+                               MetaMonitorsConfig     *config)
+{
+  g_hash_table_replace (config_store->configs,
+                        config->key, g_object_ref (config));
+
+  if (!is_system_config (config))
+    maybe_save_configs (config_store);
+}
+
+void
+meta_monitor_config_store_remove (MetaMonitorConfigStore *config_store,
+                                  MetaMonitorsConfig     *config)
+{
+  g_hash_table_remove (config_store->configs, config->key);
+
+  if (!is_system_config (config))
+    maybe_save_configs (config_store);
+}
+
+gboolean
+meta_monitor_config_store_set_custom (MetaMonitorConfigStore  *config_store,
+                                      const char              *read_path,
+                                      const char              *write_path,
+                                      MetaMonitorsConfigFlag   config_flags,
+                                      GError                 **error)
+{
+  GHashTable *new_configs = NULL;
+
+  g_clear_object (&config_store->custom_read_file);
+  g_clear_object (&config_store->custom_write_file);
+
+  config_store->custom_read_file = g_file_new_for_path (read_path);
+  if (write_path)
+    config_store->custom_write_file = g_file_new_for_path (write_path);
+
+  g_clear_pointer (&config_store->stores_policy, g_list_free);
+  config_store->has_stores_policy = FALSE;
+  config_store->policy.enable_dbus = TRUE;
+  config_store->has_dbus_policy = FALSE;
+
+  if (!read_config_file (config_store,
+                         config_store->custom_read_file,
+                         config_flags,
+                         &new_configs,
+                         error))
+    return FALSE;
+
+  g_clear_pointer (&config_store->configs, g_hash_table_unref);
+  config_store->configs = g_steal_pointer (&new_configs);
+  return TRUE;
+}
+
+int
+meta_monitor_config_store_get_config_count (MetaMonitorConfigStore *config_store)
+{
+  return (int) g_hash_table_size (config_store->configs);
+}
+
+GList *
+meta_monitor_config_store_get_stores_policy (MetaMonitorConfigStore *config_store)
+{
+  return config_store->stores_policy;
+}
+
+MetaMonitorManager *
+meta_monitor_config_store_get_monitor_manager (MetaMonitorConfigStore *config_store)
+{
+  return config_store->monitor_manager;
+}
+
+MetaMonitorConfigStore *
+meta_monitor_config_store_new (MetaMonitorManager *monitor_manager)
+{
+  return g_object_new (META_TYPE_MONITOR_CONFIG_STORE,
+                       "monitor-manager", monitor_manager,
+                       NULL);
+}
+
+static void
+meta_monitor_config_store_constructed (GObject *object)
+{
+  MetaMonitorConfigStore *config_store = META_MONITOR_CONFIG_STORE (object);
+
+  meta_monitor_config_store_reset (config_store);
+
+  G_OBJECT_CLASS (meta_monitor_config_store_parent_class)->constructed (object);
+}
+
+static void
+meta_monitor_config_store_dispose (GObject *object)
+{
+  MetaMonitorConfigStore *config_store = META_MONITOR_CONFIG_STORE (object);
+
+  if (config_store->save_cancellable)
+    {
+      g_cancellable_cancel (config_store->save_cancellable);
+      g_clear_object (&config_store->save_cancellable);
+
+      meta_monitor_config_store_save_sync (config_store);
+    }
+
+  g_clear_pointer (&config_store->configs, g_hash_table_destroy);
+
+  g_clear_object (&config_store->user_file);
+  g_clear_object (&config_store->custom_read_file);
+  g_clear_object (&config_store->custom_write_file);
+  g_clear_pointer (&config_store->stores_policy, g_list_free);
+
+  G_OBJECT_CLASS (meta_monitor_config_store_parent_class)->dispose (object);
+}
+
+static void
+meta_monitor_config_store_get_property (GObject    *object,
+                                        guint       prop_id,
+                                        GValue     *value,
+                                        GParamSpec *pspec)
+{
+  MetaMonitorConfigStore *config_store = META_MONITOR_CONFIG_STORE (object);
+
+  switch (prop_id)
+    {
+    case PROP_MONITOR_MANAGER:
+      g_value_set_object (value, &config_store->monitor_manager);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_monitor_config_store_set_property (GObject      *object,
+                                        guint         prop_id,
+                                        const GValue *value,
+                                        GParamSpec   *pspec)
+{
+  MetaMonitorConfigStore *config_store = META_MONITOR_CONFIG_STORE (object);
+
+  switch (prop_id)
+    {
+    case PROP_MONITOR_MANAGER:
+      config_store->monitor_manager = g_value_get_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_monitor_config_store_init (MetaMonitorConfigStore *config_store)
+{
+  config_store->configs = g_hash_table_new_full (meta_monitors_config_key_hash,
+                                                 meta_monitors_config_key_equal,
+                                                 NULL,
+                                                 g_object_unref);
+  config_store->policy.enable_dbus = TRUE;
+}
+
+static void
+meta_monitor_config_store_class_init (MetaMonitorConfigStoreClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->constructed = meta_monitor_config_store_constructed;
+  object_class->dispose = meta_monitor_config_store_dispose;
+  object_class->get_property = meta_monitor_config_store_get_property;
+  object_class->set_property = meta_monitor_config_store_set_property;
+
+  obj_props[PROP_MONITOR_MANAGER] =
+    g_param_spec_object ("monitor-manager", NULL, NULL,
+                         META_TYPE_MONITOR_MANAGER,
+                         G_PARAM_READWRITE |
+                         G_PARAM_STATIC_STRINGS |
+                         G_PARAM_CONSTRUCT_ONLY);
+
+  g_object_class_install_properties (object_class, PROP_LAST, obj_props);
+}
+
+static void
+replace_configs (MetaMonitorConfigStore *config_store,
+                 GHashTable             *configs)
+{
+  GHashTableIter iter;
+  MetaMonitorsConfigKey *key;
+  MetaMonitorsConfig *config;
+
+  g_hash_table_iter_init (&iter, configs);
+  while (g_hash_table_iter_next (&iter,
+                                 (gpointer *) &key,
+                                 (gpointer *) &config))
+    {
+      g_hash_table_iter_steal (&iter);
+      g_hash_table_replace (config_store->configs, key, config);
+    }
+}
+
+void
+meta_monitor_config_store_reset (MetaMonitorConfigStore *config_store)
+{
+  g_autoptr (GHashTable) system_configs = NULL;
+  g_autoptr (GHashTable) user_configs = NULL;
+  const char * const *system_dirs;
+  char *user_file_path;
+  GError *error = NULL;
+
+  g_clear_object (&config_store->user_file);
+  g_clear_object (&config_store->custom_read_file);
+  g_clear_object (&config_store->custom_write_file);
+  g_hash_table_remove_all (config_store->configs);
+
+  for (system_dirs = g_get_system_config_dirs ();
+       system_dirs && *system_dirs;
+       system_dirs++)
+    {
+      g_autofree char *system_file_path = NULL;
+
+      system_file_path = g_build_filename (*system_dirs, "monitors.xml", NULL);
+      if (g_file_test (system_file_path, G_FILE_TEST_EXISTS))
+        {
+          g_autoptr (GFile) system_file = NULL;
+
+          system_file = g_file_new_for_path (system_file_path);
+          if (!read_config_file (config_store,
+                                 system_file,
+                                 META_MONITORS_CONFIG_FLAG_SYSTEM_CONFIG,
+                                 &system_configs,
+                                 &error))
+            {
+              if (g_error_matches (error,
+                                   META_MONITOR_CONFIG_STORE_ERROR,
+                                   META_MONITOR_CONFIG_STORE_ERROR_NEEDS_MIGRATION))
+                g_warning ("System monitor configuration file (%s) is "
+                           "incompatible; ask your administrator to migrate "
+                           "the system monitor configuration.",
+                           system_file_path);
+              else
+                g_warning ("Failed to read monitors config file '%s': %s",
+                           system_file_path, error->message);
+              g_clear_error (&error);
+            }
+        }
+    }
+
+  user_file_path = g_build_filename (g_get_user_config_dir (),
+                                     "monitors.xml",
+                                     NULL);
+  config_store->user_file = g_file_new_for_path (user_file_path);
+
+  if (g_file_test (user_file_path, G_FILE_TEST_EXISTS))
+    {
+      if (!read_config_file (config_store,
+                             config_store->user_file,
+                             META_MONITORS_CONFIG_FLAG_NONE,
+                             &user_configs,
+                             &error))
+        {
+          if (error->domain == META_MONITOR_CONFIG_STORE_ERROR &&
+              error->code == META_MONITOR_CONFIG_STORE_ERROR_NEEDS_MIGRATION)
+            {
+              g_clear_error (&error);
+              if (!meta_migrate_old_user_monitors_config (config_store, &error))
+                {
+                  g_warning ("Failed to migrate old monitors config file: %s",
+                             error->message);
+                  g_error_free (error);
+                }
+            }
+          else
+            {
+              g_warning ("Failed to read monitors config file '%s': %s",
+                         user_file_path, error->message);
+              g_error_free (error);
+            }
+        }
+    }
+
+  if (config_store->has_stores_policy)
+    {
+      GList *l;
+
+      for (l = g_list_last (config_store->stores_policy); l; l = l->prev)
+        {
+          MetaConfigStore store = GPOINTER_TO_INT (l->data);
+
+          switch (store)
+            {
+            case META_CONFIG_STORE_SYSTEM:
+              if (system_configs)
+                replace_configs (config_store, system_configs);
+              break;
+            case META_CONFIG_STORE_USER:
+              if (user_configs)
+                replace_configs (config_store, user_configs);
+            }
+        }
+    }
+  else
+    {
+      if (system_configs)
+        replace_configs (config_store, system_configs);
+      if (user_configs)
+        replace_configs (config_store, user_configs);
+    }
+
+
+  g_free (user_file_path);
+}
+
+const MetaMonitorConfigPolicy *
+meta_monitor_config_store_get_policy (MetaMonitorConfigStore *config_store)
+{
+  return &config_store->policy;
+}
diff '--color=auto' -uraN a/src/backends/meta-monitor-manager-dummy.c b/src/backends/meta-monitor-manager-dummy.c
--- a/src/backends/meta-monitor-manager-dummy.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager-dummy.c	2023-10-12 20:59:22.707167662 +0300
@@ -372,6 +372,15 @@
     }
 }
 
+static gboolean
+has_tiled_monitors (void)
+{
+  const char *tiled_monitors_str;
+
+  tiled_monitors_str = g_getenv ("MUTTER_DEBUG_TILED_DUMMY_MONITORS");
+  return g_strcmp0 (tiled_monitors_str, "1") == 0;
+}
+
 static void
 meta_monitor_manager_dummy_read_current (MetaMonitorManager *manager)
 {
@@ -380,7 +389,6 @@
   float *monitor_scales = NULL;
   const char *num_monitors_str;
   const char *monitor_scales_str;
-  const char *tiled_monitors_str;
   gboolean tiled_monitors;
   unsigned int i;
   GList *outputs;
@@ -458,8 +466,7 @@
       g_strfreev (scales_str_list);
     }
 
-  tiled_monitors_str = g_getenv ("MUTTER_DEBUG_TILED_DUMMY_MONITORS");
-  tiled_monitors = g_strcmp0 (tiled_monitors_str, "1") == 0;
+  tiled_monitors = has_tiled_monitors ();
 
   modes = NULL;
   crtcs = NULL;
@@ -662,6 +669,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
@@ -692,6 +700,9 @@
   MetaMonitorManagerCapability capabilities =
     META_MONITOR_MANAGER_CAPABILITY_NONE;
 
+  if (has_tiled_monitors ())
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_TILING;
+
   if (meta_settings_is_experimental_feature_enabled (
         settings,
         META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER))
diff '--color=auto' -uraN a/src/backends/meta-monitor-manager-private.h b/src/backends/meta-monitor-manager-private.h
--- a/src/backends/meta-monitor-manager-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager-private.h	2023-10-12 20:59:22.707167662 +0300
@@ -47,7 +47,9 @@
 {
   META_MONITOR_MANAGER_CAPABILITY_NONE = 0,
   META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE = (1 << 0),
-  META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED = (1 << 1)
+  META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED = (1 << 1),
+  META_MONITOR_MANAGER_CAPABILITY_TILING = (1 << 2),
+  META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING = (1 << 3),
 } MetaMonitorManagerCapability;
 
 /* Equivalent to the 'method' enum in org.gnome.Mutter.DisplayConfig */
@@ -62,7 +64,8 @@
 typedef enum _MetaLogicalMonitorLayoutMode
 {
   META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL = 1,
-  META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL = 2
+  META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL = 2,
+  META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL = 3
 } MetaLogicalMonitorLayoutMode;
 
 /* The source the privacy screen change has been triggered */
@@ -85,6 +88,7 @@
   MetaCrtc *crtc;
   MetaCrtcMode *mode;
   graphene_rect_t layout;
+  float scale;
   MetaMonitorTransform transform;
   GPtrArray *outputs;
 };
@@ -101,6 +105,7 @@
   gboolean is_primary;
   gboolean is_presentation;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   gboolean has_max_bpc;
   unsigned int max_bpc;
 };
@@ -148,6 +153,7 @@
   int screen_height;
 
   GList *monitors;
+  GList *scale_override_monitors;
 
   GList *logical_monitors;
   MetaLogicalMonitor *primary_logical_monitor;
@@ -160,6 +166,8 @@
 
   MetaMonitorConfigManager *config_manager;
 
+  gulong experimental_features_changed_handler_id;
+
   MetaMonitorSwitchConfigType current_switch_config;
 
   MetaPrivacyScreenChangeState privacy_screen_change_state;
@@ -177,6 +185,9 @@
  * @apply_monitors_config: Tries to apply the given config using the given
  *   method. Throws an error if something went wrong.
  *
+ * @update_screen_size_derived: Computes the screen size for derived
+ *   configuration.
+ *
  * @set_power_save_mode: Sets the #MetaPowerSave mode (for all displays).
  *
  * @change_backlight: Changes the backlight intensity to the given value (in
@@ -223,6 +234,9 @@
                              MetaOutput         *output,
                              int                 backlight);
 
+  void (*update_screen_size_derived)  (MetaMonitorManager *,
+                                       MetaMonitorsConfig *);
+
   void (* tiled_monitor_added) (MetaMonitorManager *manager,
                                 MetaMonitor        *monitor);
 
@@ -383,6 +397,11 @@
                                                             MetaMonitorMode             *monitor_mode,
                                                             float                        scale);
 
+float              meta_monitor_manager_get_maximum_crtc_scale (MetaMonitorManager *manager);
+
+gboolean           meta_monitor_manager_disable_scale_for_monitor (MetaMonitorManager *manager,
+                                                                   MetaLogicalMonitor *monitor);
+
 MetaMonitorManagerCapability
                    meta_monitor_manager_get_capabilities (MetaMonitorManager *manager);
 
diff '--color=auto' -uraN a/src/backends/meta-monitor-manager-private.h.orig b/src/backends/meta-monitor-manager-private.h.orig
--- a/src/backends/meta-monitor-manager-private.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor-manager-private.h.orig	2023-10-12 20:59:22.673833913 +0300
@@ -0,0 +1,438 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington
+ * Copyright (C) 2003 Rob Adams
+ * Copyright (C) 2004-2006 Elijah Newren
+ * Copyright (C) 2013 Red Hat Inc.
+ * Copyright (C) 2020 NVIDIA CORPORATION
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "cogl/cogl.h"
+#include <graphene.h>
+
+#ifdef HAVE_GNOME_DESKTOP
+#include <libgnome-desktop/gnome-pnp-ids.h>
+#endif
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-crtc.h"
+#include "backends/meta-cursor.h"
+#include "backends/meta-display-config-shared.h"
+#include "backends/meta-monitor-transform.h"
+#include "backends/meta-viewport-info.h"
+#include "core/util-private.h"
+#include "meta/display.h"
+#include "meta/meta-monitor-manager.h"
+
+#define META_MONITOR_MANAGER_MIN_SCREEN_WIDTH 640
+#define META_MONITOR_MANAGER_MIN_SCREEN_HEIGHT 480
+
+typedef enum _MetaMonitorManagerCapability
+{
+  META_MONITOR_MANAGER_CAPABILITY_NONE = 0,
+  META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE = (1 << 0),
+  META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED = (1 << 1)
+} MetaMonitorManagerCapability;
+
+/* Equivalent to the 'method' enum in org.gnome.Mutter.DisplayConfig */
+typedef enum _MetaMonitorsConfigMethod
+{
+  META_MONITORS_CONFIG_METHOD_VERIFY = 0,
+  META_MONITORS_CONFIG_METHOD_TEMPORARY = 1,
+  META_MONITORS_CONFIG_METHOD_PERSISTENT = 2
+} MetaMonitorsConfigMethod;
+
+/* Equivalent to the 'layout-mode' enum in org.gnome.Mutter.DisplayConfig */
+typedef enum _MetaLogicalMonitorLayoutMode
+{
+  META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL = 1,
+  META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL = 2
+} MetaLogicalMonitorLayoutMode;
+
+/* The source the privacy screen change has been triggered */
+typedef enum
+{
+  META_PRIVACY_SCREEN_CHANGE_STATE_NONE,
+  META_PRIVACY_SCREEN_CHANGE_STATE_INIT,
+  META_PRIVACY_SCREEN_CHANGE_STATE_PENDING_HOTKEY,
+  META_PRIVACY_SCREEN_CHANGE_STATE_PENDING_SETTING,
+} MetaPrivacyScreenChangeState;
+
+/*
+ * MetaCrtcAssignment:
+ *
+ * A representation of a CRTC configuration, generated by
+ * MetaMonitorConfigManager.
+ */
+struct _MetaCrtcAssignment
+{
+  MetaCrtc *crtc;
+  MetaCrtcMode *mode;
+  graphene_rect_t layout;
+  MetaMonitorTransform transform;
+  GPtrArray *outputs;
+};
+
+/*
+ * MetaOutputAssignment:
+ *
+ * A representation of a connector configuration, generated by
+ * MetaMonitorConfigManager.
+ */
+struct _MetaOutputAssignment
+{
+  MetaOutput *output;
+  gboolean is_primary;
+  gboolean is_presentation;
+  gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
+  gboolean has_max_bpc;
+  unsigned int max_bpc;
+};
+
+/*
+ * MetaOutputCtm:
+ *
+ * A 3x3 color transform matrix in the fixed-point S31.32 sign-magnitude format
+ * used by DRM.
+ */
+typedef struct _MetaOutputCtm
+{
+  uint64_t matrix[9];
+} MetaOutputCtm;
+
+#define META_TYPE_MONITOR_MANAGER            (meta_monitor_manager_get_type ())
+#define META_MONITOR_MANAGER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_MONITOR_MANAGER, MetaMonitorManager))
+#define META_MONITOR_MANAGER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_MONITOR_MANAGER, MetaMonitorManagerClass))
+#define META_IS_MONITOR_MANAGER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_MONITOR_MANAGER))
+#define META_IS_MONITOR_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_MONITOR_MANAGER))
+#define META_MONITOR_MANAGER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_MONITOR_MANAGER, MetaMonitorManagerClass))
+
+typedef struct _MetaDBusDisplayConfig MetaDBusDisplayConfig;
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaMonitorManager, g_object_unref)
+
+struct _MetaMonitorManager
+{
+  GObject parent_instance;
+
+  MetaDBusDisplayConfig *display_config;
+
+  MetaBackend *backend;
+
+  /* XXX: this structure is very badly
+     packed, but I like the logical organization
+     of fields */
+
+  gboolean in_init;
+  unsigned int serial;
+
+  MetaLogicalMonitorLayoutMode layout_mode;
+
+  int screen_width;
+  int screen_height;
+
+  GList *monitors;
+
+  GList *logical_monitors;
+  MetaLogicalMonitor *primary_logical_monitor;
+
+  guint dbus_name_id;
+  guint restore_config_id;
+  guint persistent_timeout_id;
+
+  guint panel_orientation_managed : 1;
+
+  MetaMonitorConfigManager *config_manager;
+
+  MetaMonitorSwitchConfigType current_switch_config;
+
+  MetaPrivacyScreenChangeState privacy_screen_change_state;
+};
+
+/**
+ * MetaMonitorManagerClass:
+ *
+ * @read_edid: Returns the raw Extended Display Identification Data (EDID)
+ *   for the given #MetaOutput object.
+ *
+ * @ensure_initial_config: Called on setup. Makes sure an initial config
+ *   is loaded.
+ *
+ * @apply_monitors_config: Tries to apply the given config using the given
+ *   method. Throws an error if something went wrong.
+ *
+ * @set_power_save_mode: Sets the #MetaPowerSave mode (for all displays).
+ *
+ * @change_backlight: Changes the backlight intensity to the given value (in
+ *   percent).
+ *
+ * @tiled_monitor_added: Should be called by a #MetaMonitor when it is created.
+ *
+ * @tiled_monitor_removed: Should be called by a #MetaMonitor when it is
+ *   destroyed.
+ *
+ * @is_transform_handled: vfunc for
+ *   meta_monitor_manager_is_transform_handled().
+ * @calculate_monitor_mode_scale: vfunc for
+ *   meta_monitor_manager_calculate_monitor_mode_scale().
+ * @calculate_supported_scales: vfunc for
+ *   meta_monitor_manager_calculate_supported_scales().
+ * @get_capabilities: vfunc for meta_monitor_manager_get_capabilities().
+ * @get_max_screen_size: vfunc for meta_monitor_manager_get_max_screen_size().
+ * @get_default_layout_mode: vfunc for meta_monitor_manager_get_default_layout_mode().
+ * @set_output_ctm: vfunc for meta_monitor_manager_output_set_ctm()
+ *
+ * The base class for a #MetaMonitorManager.
+ */
+struct _MetaMonitorManagerClass
+{
+  GObjectClass parent_class;
+
+  GBytes * (* read_edid) (MetaMonitorManager *manager,
+                          MetaOutput         *output);
+
+  void (* read_current_state) (MetaMonitorManager *manager);
+
+  void (* ensure_initial_config) (MetaMonitorManager *manager);
+
+  gboolean (* apply_monitors_config) (MetaMonitorManager        *manager,
+                                      MetaMonitorsConfig        *config,
+                                      MetaMonitorsConfigMethod   method,
+                                      GError                   **error);
+
+  void (* set_power_save_mode) (MetaMonitorManager *manager,
+                                MetaPowerSave       power_save);
+
+  void (* change_backlight) (MetaMonitorManager *manager,
+                             MetaOutput         *output,
+                             int                 backlight);
+
+  void (* tiled_monitor_added) (MetaMonitorManager *manager,
+                                MetaMonitor        *monitor);
+
+  void (* tiled_monitor_removed) (MetaMonitorManager *manager,
+                                  MetaMonitor        *monitor);
+
+  gboolean (* is_transform_handled) (MetaMonitorManager   *manager,
+                                     MetaCrtc             *crtc,
+                                     MetaMonitorTransform  transform);
+
+  float (* calculate_monitor_mode_scale) (MetaMonitorManager           *manager,
+                                          MetaLogicalMonitorLayoutMode  layout_mode,
+                                          MetaMonitor                  *monitor,
+                                          MetaMonitorMode              *monitor_mode);
+
+  float * (* calculate_supported_scales) (MetaMonitorManager           *manager,
+                                          MetaLogicalMonitorLayoutMode  layout_mode,
+                                          MetaMonitor                  *monitor,
+                                          MetaMonitorMode              *monitor_mode,
+                                          int                          *n_supported_scales);
+
+  MetaMonitorManagerCapability (* get_capabilities) (MetaMonitorManager *manager);
+
+  gboolean (* get_max_screen_size) (MetaMonitorManager *manager,
+                                    int                *width,
+                                    int                *height);
+
+  MetaLogicalMonitorLayoutMode (* get_default_layout_mode) (MetaMonitorManager *manager);
+
+  void (* set_output_ctm) (MetaOutput          *output,
+                           const MetaOutputCtm *ctm);
+
+  MetaVirtualMonitor * (* create_virtual_monitor) (MetaMonitorManager            *manager,
+                                                   const MetaVirtualMonitorInfo  *info,
+                                                   GError                       **error);
+};
+
+META_EXPORT_TEST
+MetaBackend *       meta_monitor_manager_get_backend (MetaMonitorManager *manager);
+
+void                meta_monitor_manager_setup (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+void                meta_monitor_manager_rebuild (MetaMonitorManager *manager,
+                                                  MetaMonitorsConfig *config);
+
+META_EXPORT_TEST
+void                meta_monitor_manager_rebuild_derived (MetaMonitorManager *manager,
+                                                          MetaMonitorsConfig *config);
+
+META_EXPORT_TEST
+int                 meta_monitor_manager_get_num_logical_monitors (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+GList *             meta_monitor_manager_get_logical_monitors (MetaMonitorManager *manager);
+
+MetaLogicalMonitor *meta_monitor_manager_get_logical_monitor_from_number (MetaMonitorManager *manager,
+                                                                          int                 number);
+
+META_EXPORT_TEST
+MetaLogicalMonitor *meta_monitor_manager_get_primary_logical_monitor (MetaMonitorManager *manager);
+
+MetaLogicalMonitor *meta_monitor_manager_get_logical_monitor_at (MetaMonitorManager *manager,
+                                                                 float               x,
+                                                                 float               y);
+
+MetaLogicalMonitor *meta_monitor_manager_get_logical_monitor_from_rect (MetaMonitorManager *manager,
+                                                                        MtkRectangle       *rect);
+
+MetaLogicalMonitor *meta_monitor_manager_get_highest_scale_monitor_from_rect (MetaMonitorManager *manager,
+                                                                              MtkRectangle       *rect);
+
+MetaLogicalMonitor *meta_monitor_manager_get_logical_monitor_neighbor (MetaMonitorManager  *manager,
+                                                                       MetaLogicalMonitor  *logical_monitor,
+                                                                       MetaDisplayDirection direction);
+
+MetaMonitor *       meta_monitor_manager_get_primary_monitor (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+MetaMonitor *       meta_monitor_manager_get_laptop_panel (MetaMonitorManager *manager);
+
+MetaMonitor *       meta_monitor_manager_get_monitor_from_spec (MetaMonitorManager *manager,
+                                                                MetaMonitorSpec    *monitor_spec);
+
+MetaMonitor *       meta_monitor_manager_get_monitor_from_connector (MetaMonitorManager *manager,
+                                                                     const char         *connector);
+
+META_EXPORT_TEST
+GList *             meta_monitor_manager_get_monitors      (MetaMonitorManager *manager);
+
+void                meta_monitor_manager_get_screen_size   (MetaMonitorManager *manager,
+                                                            int                *width,
+                                                            int                *height);
+
+MetaPowerSave       meta_monitor_manager_get_power_save_mode (MetaMonitorManager *manager);
+
+void                meta_monitor_manager_power_save_mode_changed (MetaMonitorManager        *manager,
+                                                                  MetaPowerSave              mode,
+                                                                  MetaPowerSaveChangeReason  reason);
+
+void                meta_monitor_manager_confirm_configuration (MetaMonitorManager *manager,
+                                                                gboolean            ok);
+
+gboolean           meta_monitor_manager_has_hotplug_mode_update (MetaMonitorManager *manager);
+
+void               meta_monitor_manager_read_current_state (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+void               meta_monitor_manager_reconfigure (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+void               meta_monitor_manager_reload (MetaMonitorManager *manager);
+
+gboolean           meta_monitor_manager_get_monitor_matrix (MetaMonitorManager *manager,
+                                                            MetaMonitor        *monitor,
+                                                            MetaLogicalMonitor *logical_monitor,
+                                                            gfloat              matrix[6]);
+
+void               meta_monitor_manager_tiled_monitor_added (MetaMonitorManager *manager,
+                                                             MetaMonitor        *monitor);
+void               meta_monitor_manager_tiled_monitor_removed (MetaMonitorManager *manager,
+                                                               MetaMonitor        *monitor);
+
+gboolean           meta_monitor_manager_is_transform_handled (MetaMonitorManager  *manager,
+                                                              MetaCrtc            *crtc,
+                                                              MetaMonitorTransform transform);
+
+META_EXPORT_TEST
+MetaMonitorsConfig * meta_monitor_manager_ensure_configured (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+void               meta_monitor_manager_update_logical_state (MetaMonitorManager *manager,
+                                                              MetaMonitorsConfig *config);
+
+META_EXPORT_TEST
+void               meta_monitor_manager_update_logical_state_derived (MetaMonitorManager *manager,
+                                                                      MetaMonitorsConfig *config);
+
+META_EXPORT_TEST
+void               meta_monitor_manager_lid_is_closed_changed (MetaMonitorManager *manager);
+
+gboolean           meta_monitor_manager_is_headless (MetaMonitorManager *manager);
+
+float              meta_monitor_manager_calculate_monitor_mode_scale (MetaMonitorManager           *manager,
+                                                                      MetaLogicalMonitorLayoutMode  layout_mode,
+                                                                      MetaMonitor                  *monitor,
+                                                                      MetaMonitorMode              *monitor_mode);
+
+float *            meta_monitor_manager_calculate_supported_scales (MetaMonitorManager          *,
+                                                                    MetaLogicalMonitorLayoutMode ,
+                                                                    MetaMonitor                 *,
+                                                                    MetaMonitorMode             *,
+                                                                    int                         *);
+
+gboolean           meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
+                                                            MetaLogicalMonitorLayoutMode layout_mode,
+                                                            MetaMonitor                 *monitor,
+                                                            MetaMonitorMode             *monitor_mode,
+                                                            float                        scale);
+
+MetaMonitorManagerCapability
+                   meta_monitor_manager_get_capabilities (MetaMonitorManager *manager);
+
+gboolean           meta_monitor_manager_get_max_screen_size (MetaMonitorManager *manager,
+                                                             int                *max_width,
+                                                             int                *max_height);
+
+MetaLogicalMonitorLayoutMode
+                   meta_monitor_manager_get_default_layout_mode (MetaMonitorManager *manager);
+
+META_EXPORT_TEST
+MetaVirtualMonitor * meta_monitor_manager_create_virtual_monitor (MetaMonitorManager            *manager,
+                                                                  const MetaVirtualMonitorInfo  *info,
+                                                                  GError                       **error);
+
+META_EXPORT_TEST
+MetaMonitorConfigManager *
+                   meta_monitor_manager_get_config_manager (MetaMonitorManager *manager);
+
+void meta_monitor_manager_rotate_monitor (MetaMonitorManager *manager);
+
+void meta_monitor_manager_clear_output (MetaOutput *output);
+void meta_monitor_manager_clear_mode (MetaCrtcMode *mode);
+void meta_monitor_manager_clear_crtc (MetaCrtc *crtc);
+
+gboolean meta_monitor_has_aspect_as_size (MetaMonitor *monitor);
+
+static inline MetaOutputAssignment *
+meta_find_output_assignment (MetaOutputAssignment **outputs,
+                             unsigned int           n_outputs,
+                             MetaOutput            *output)
+{
+  unsigned int i;
+
+  for (i = 0; i < n_outputs; i++)
+    {
+      MetaOutputAssignment *output_assignment = outputs[i];
+
+      if (output == output_assignment->output)
+        return output_assignment;
+    }
+
+  return NULL;
+}
+
+void meta_monitor_manager_post_init (MetaMonitorManager *manager);
+
+MetaViewportInfo * meta_monitor_manager_get_viewports (MetaMonitorManager *manager);
+
+GList * meta_monitor_manager_get_virtual_monitors (MetaMonitorManager *manager);
+
+void meta_monitor_manager_maybe_emit_privacy_screen_change (MetaMonitorManager *manager);
diff '--color=auto' -uraN a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
--- a/src/backends/meta-monitor-manager.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager.c	2023-10-12 20:59:22.710501037 +0300
@@ -131,6 +131,15 @@
 meta_monitor_manager_is_config_complete (MetaMonitorManager *manager,
                                          MetaMonitorsConfig *config);
 
+static gboolean
+meta_monitor_manager_is_scale_supported_with_threshold (MetaMonitorManager           *manager,
+                                                        MetaLogicalMonitorLayoutMode  layout_mode,
+                                                        MetaMonitor                  *monitor,
+                                                        MetaMonitorMode              *monitor_mode,
+                                                        float                         scale,
+                                                        float                         threshold,
+                                                        float                        *out_scale);
+
 static void
 meta_monitor_manager_real_read_current_state (MetaMonitorManager *manager);
 
@@ -224,6 +233,30 @@
                                                     primary_logical_monitor);
 }
 
+float
+meta_monitor_manager_get_maximum_crtc_scale (MetaMonitorManager *manager)
+{
+  GList *l;
+  float scale;
+
+  scale = 1.0f;
+  for (l = manager->monitors; l != NULL; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaOutput *output = meta_monitor_get_main_output (monitor);
+      MetaCrtc *crtc = meta_output_get_assigned_crtc (output);
+
+      if (crtc)
+        {
+          const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+
+          scale = MAX (scale, crtc_config ? crtc_config->scale : 1.0f);
+        }
+    }
+
+  return scale;
+}
+
 static float
 derive_configured_global_scale (MetaMonitorManager *manager,
                                 MetaMonitorsConfig *config)
@@ -335,6 +368,51 @@
   return 1.0;
 }
 
+static gboolean
+derive_scale_from_crtc (MetaMonitorManager *manager,
+                        MetaMonitor        *monitor,
+                        float              *out_scale)
+{
+  MetaMonitorManagerCapability capabilities;
+  MetaMonitorMode *monitor_mode;
+  float threshold;
+  MetaOutput *output;
+  MetaCrtc *crtc;
+  float scale;
+
+  capabilities = meta_monitor_manager_get_capabilities (manager);
+
+  if (!(capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return FALSE;
+
+  if (!(capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    return FALSE;
+
+  output = meta_monitor_get_main_output (monitor);
+  crtc = meta_output_get_assigned_crtc (output);
+
+  if (!crtc)
+    return FALSE;
+
+  /* Due to integer and possibly inverse scaling applied to the output the
+   * result could not match exactly, so we apply a more relaxed threshold
+   * in this case. */
+  threshold = 0.001f;
+
+  scale = meta_crtc_get_config_scale (crtc);
+  monitor_mode = meta_monitor_get_current_mode (monitor);
+  if (meta_monitor_manager_is_scale_supported_with_threshold (manager,
+                                                              manager->layout_mode,
+                                                              monitor,
+                                                              monitor_mode,
+                                                              scale,
+                                                              threshold,
+                                                              out_scale))
+    return TRUE;
+
+  return FALSE;
+}
+
 static void
 meta_monitor_manager_rebuild_logical_monitors_derived (MetaMonitorManager *manager,
                                                        MetaMonitorsConfig *config)
@@ -382,11 +460,17 @@
           float scale;
 
           if (use_global_scale)
-            scale = global_scale;
-          else if (config)
-            scale = derive_scale_from_config (manager, config, &layout);
+            scale = roundf (global_scale);
           else
-            scale = calculate_monitor_scale (manager, monitor);
+            {
+              if (!derive_scale_from_crtc (manager, monitor, &scale))
+                {
+                  if (config)
+                    scale = derive_scale_from_config (manager, config, &layout);
+                  else
+                    scale = calculate_monitor_scale (manager, monitor);
+                }
+            }
 
           g_assert (scale > 0);
 
@@ -601,13 +685,19 @@
                                                    MetaMonitor                  *monitor,
                                                    MetaMonitorMode              *monitor_mode)
 {
+  float scale;
   MetaMonitorManagerClass *manager_class =
     META_MONITOR_MANAGER_GET_CLASS (manager);
 
-  return manager_class->calculate_monitor_mode_scale (manager,
-                                                      layout_mode,
-                                                      monitor,
-                                                      monitor_mode);
+  scale = manager_class->calculate_monitor_mode_scale (manager,
+                                                       layout_mode,
+                                                       monitor,
+                                                       monitor_mode);
+
+  if (g_list_find (manager->scale_override_monitors, monitor))
+    return ceilf (scale);
+
+  return scale;
 }
 
 float *
@@ -775,7 +865,8 @@
 should_use_stored_config (MetaMonitorManager *manager)
 {
   return (manager->in_init ||
-          !meta_monitor_manager_has_hotplug_mode_update (manager));
+          (!manager->scale_override_monitors &&
+           !meta_monitor_manager_has_hotplug_mode_update (manager)));
 }
 
 MetaMonitorsConfig *
@@ -787,6 +878,8 @@
   MetaMonitorsConfigMethod method;
   MetaMonitorsConfigMethod fallback_method =
     META_MONITORS_CONFIG_METHOD_TEMPORARY;
+  MetaLogicalMonitorLayoutMode layout_mode =
+    meta_monitor_manager_get_default_layout_mode (manager);
 
   use_stored_config = should_use_stored_config (manager);
   if (use_stored_config)
@@ -796,7 +889,18 @@
 
   if (use_stored_config)
     {
+      g_autoptr(MetaMonitorsConfig) new_config = NULL;
+
       config = meta_monitor_config_manager_get_stored (manager->config_manager);
+      if (config && config->layout_mode != layout_mode)
+        {
+          new_config =
+            meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                           config,
+                                                           layout_mode);
+          config = new_config;
+        }
+
       if (config)
         {
           g_autoptr (MetaMonitorsConfig) oriented_config = NULL;
@@ -897,6 +1001,16 @@
 
       config = g_object_ref (config);
 
+      if (config && config->layout_mode != layout_mode)
+        {
+          MetaMonitorsConfig *new_config =
+            meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                           config,
+                                                           layout_mode);
+          g_object_unref (config);
+          config = new_config;
+        }
+
       if (meta_monitor_manager_is_config_complete (manager, config))
         {
           if (!meta_monitor_manager_apply_monitors_config (manager,
@@ -1087,6 +1201,66 @@
   handle_orientation_change (orientation_manager, manager);
 }
 
+static gboolean
+apply_x11_fractional_scaling_config (MetaMonitorManager *manager)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(MetaMonitorsConfig) config = NULL;
+  MetaMonitorsConfig *applied_config;
+  MetaLogicalMonitorLayoutMode layout_mode =
+    meta_monitor_manager_get_default_layout_mode (manager);
+
+  if (!META_IS_MONITOR_MANAGER_XRANDR (manager))
+    return TRUE;
+
+  applied_config =
+    meta_monitor_config_manager_get_current (manager->config_manager);
+  config =
+    meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                   applied_config,
+                                                   layout_mode);
+  if (!config)
+    return FALSE;
+
+  if (meta_monitor_manager_apply_monitors_config (manager,
+                                                  config,
+                                                  META_MONITORS_CONFIG_METHOD_PERSISTENT,
+                                                  &error))
+    {
+      if (config != applied_config && manager->persistent_timeout_id)
+        {
+          if (G_UNLIKELY (applied_config !=
+                          meta_monitor_config_manager_get_previous (manager->config_manager)))
+            {
+              meta_warning ("The removed configuration doesn't match the "
+                            "previously applied one, reverting may not work");
+            }
+          else
+            {
+              g_autoptr(MetaMonitorsConfig) previous_config = NULL;
+
+              /* The previous config we applied was just a temporary one that
+               * GNOME control center passed us while toggling the fractional
+               * scaling. So, in such case, once the configuration with the
+               * correct layout has been applied, we need to ignore the
+               * temporary one. */
+              previous_config =
+                meta_monitor_config_manager_pop_previous (manager->config_manager);
+
+              g_assert_true (applied_config == previous_config);
+            }
+        }
+    }
+  else
+    {
+      meta_warning ("Impossible to apply the layout config %s\n",
+                    error->message);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 static void
 experimental_features_changed (MetaSettings           *settings,
                                MetaExperimentalFeature old_experimental_features,
@@ -1094,6 +1268,8 @@
 {
   gboolean was_stage_views_scaled;
   gboolean is_stage_views_scaled;
+  gboolean was_x11_scaling;
+  gboolean x11_scaling;
   gboolean should_reconfigure = FALSE;
 
   was_stage_views_scaled =
@@ -1103,10 +1279,23 @@
     meta_settings_is_experimental_feature_enabled (
       settings,
       META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+  was_x11_scaling =
+    !!(old_experimental_features &
+       META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING);
+  x11_scaling =
+    meta_settings_is_experimental_feature_enabled (
+      settings,
+      META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING);
 
   if (is_stage_views_scaled != was_stage_views_scaled)
     should_reconfigure = TRUE;
 
+  if (was_x11_scaling != x11_scaling)
+    {
+      if (!apply_x11_fractional_scaling_config (manager))
+        should_reconfigure = TRUE;
+    }
+
   if (should_reconfigure)
     meta_monitor_manager_reconfigure (manager);
 
@@ -1330,10 +1519,11 @@
 
   manager->display_config = meta_dbus_display_config_skeleton_new ();
 
-  g_signal_connect_object (settings,
-                           "experimental-features-changed",
-                           G_CALLBACK (experimental_features_changed),
-                           manager, 0);
+  manager->experimental_features_changed_handler_id =
+    g_signal_connect_object (settings,
+                             "experimental-features-changed",
+                             G_CALLBACK (experimental_features_changed),
+                             manager, 0);
 
   g_signal_connect_object (settings,
                            "privacy-screen-changed",
@@ -1930,6 +2120,33 @@
 }
 
 static void
+restore_previous_experimental_config (MetaMonitorManager *manager,
+                                      MetaMonitorsConfig *previous_config)
+{
+  MetaBackend *backend = manager->backend;
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  gboolean was_fractional;
+
+  if (!META_IS_MONITOR_MANAGER_XRANDR (manager))
+    return;
+
+  was_fractional =
+    previous_config->layout_mode != META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+
+  if (meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING) == was_fractional)
+    return;
+
+  g_signal_handler_block (settings,
+                          manager->experimental_features_changed_handler_id);
+
+  meta_settings_enable_x11_fractional_scaling (settings, was_fractional);
+
+  g_signal_handler_unblock (settings,
+                            manager->experimental_features_changed_handler_id);
+}
+
+static void
 restore_previous_config (MetaMonitorManager *manager)
 {
   MetaMonitorsConfig *previous_config;
@@ -1954,6 +2171,8 @@
             g_set_object (&previous_config, oriented_config);
         }
 
+      restore_previous_experimental_config (manager, previous_config);
+
       method = META_MONITORS_CONFIG_METHOD_TEMPORARY;
       if (meta_monitor_manager_apply_monitors_config (manager,
                                                       previous_config,
@@ -2007,6 +2226,41 @@
   g_signal_emit (manager, signals[CONFIRM_DISPLAY_CHANGE], 0);
 }
 
+gboolean
+meta_monitor_manager_disable_scale_for_monitor (MetaMonitorManager *manager,
+                                                MetaLogicalMonitor *monitor)
+{
+  switch (manager->layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      break;
+    default:
+      return FALSE;
+    }
+
+  if (monitor && fmodf (monitor->scale, 1.0) != 0.0f)
+    {
+      if (manager->scale_override_monitors)
+        {
+          g_clear_pointer (&manager->scale_override_monitors, g_list_free);
+          g_object_unref (meta_monitor_config_manager_pop_previous (manager->config_manager));
+        }
+
+      manager->scale_override_monitors = g_list_copy (monitor->monitors);
+      meta_monitor_manager_ensure_configured (manager);
+      return TRUE;
+    }
+
+  if (manager->scale_override_monitors)
+    {
+      g_clear_pointer (&manager->scale_override_monitors, g_list_free);
+      restore_previous_config (manager);
+    }
+
+  return FALSE;
+}
+
 #define META_DISPLAY_CONFIG_MODE_FLAGS_PREFERRED (1 << 0)
 #define META_DISPLAY_CONFIG_MODE_FLAGS_CURRENT (1 << 1)
 
@@ -2034,6 +2288,7 @@
   MetaMonitorManagerCapability capabilities;
   int ui_scaling_factor;
   int max_screen_width, max_screen_height;
+  char *renderer;
 
   g_variant_builder_init (&monitors_builder,
                           G_VARIANT_TYPE (MONITORS_FORMAT));
@@ -2136,6 +2391,15 @@
                                  g_variant_new_boolean (is_underscanning));
         }
 
+      if (meta_monitor_is_vrr_capable (monitor))
+        {
+          gboolean vrr_disallowed = meta_monitor_is_vrr_disallowed (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-vrr-allowed",
+                                 g_variant_new_boolean (!vrr_disallowed));
+        }
+
       is_builtin = meta_monitor_is_laptop_panel (monitor);
       g_variant_builder_add (&monitor_properties_builder, "{sv}",
                              "is-builtin",
@@ -2202,6 +2466,14 @@
     }
 
   g_variant_builder_init (&properties_builder, G_VARIANT_TYPE ("a{sv}"));
+
+  renderer = g_ascii_strdown (G_OBJECT_TYPE_NAME (manager) +
+                              strlen (g_type_name (g_type_parent (G_OBJECT_TYPE (manager)))),
+                              -1);
+  g_variant_builder_add (&properties_builder, "{sv}",
+                         "renderer",
+                         g_variant_new_take_string (renderer));
+
   capabilities = meta_monitor_manager_get_capabilities (manager);
 
   g_variant_builder_add (&properties_builder, "{sv}",
@@ -2220,6 +2492,14 @@
                              "global-scale-required",
                              g_variant_new_boolean (TRUE));
     }
+  else if (META_IS_MONITOR_MANAGER_XRANDR (manager) &&
+           (capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING) &&
+           (capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      g_variant_builder_add (&properties_builder, "{sv}",
+                             "x11-fractional-scaling",
+                             g_variant_new_boolean (TRUE));
+    }
 
   ui_scaling_factor = meta_settings_get_ui_scaling_factor (settings);
   g_variant_builder_add (&properties_builder, "{sv}",
@@ -2264,12 +2544,14 @@
 #undef LOGICAL_MONITOR_FORMAT
 #undef LOGICAL_MONITORS_FORMAT
 
-gboolean
-meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
-                                         MetaLogicalMonitorLayoutMode layout_mode,
-                                         MetaMonitor                 *monitor,
-                                         MetaMonitorMode             *monitor_mode,
-                                         float                        scale)
+static gboolean
+meta_monitor_manager_is_scale_supported_with_threshold (MetaMonitorManager           *manager,
+                                                        MetaLogicalMonitorLayoutMode  layout_mode,
+                                                        MetaMonitor                  *monitor,
+                                                        MetaMonitorMode              *monitor_mode,
+                                                        float                         scale,
+                                                        float                         threshold,
+                                                        float                        *out_scale)
 {
   g_autofree float *supported_scales = NULL;
   int n_supported_scales;
@@ -2283,13 +2565,34 @@
                                                      &n_supported_scales);
   for (i = 0; i < n_supported_scales; i++)
     {
-      if (supported_scales[i] == scale)
-        return TRUE;
+      if (fabs (supported_scales[i] - scale) < threshold)
+        {
+          if (out_scale)
+            *out_scale = supported_scales[i];
+
+          return TRUE;
+        }
     }
 
   return FALSE;
 }
 
+gboolean
+meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
+                                         MetaLogicalMonitorLayoutMode layout_mode,
+                                         MetaMonitor                 *monitor,
+                                         MetaMonitorMode             *monitor_mode,
+                                         float                        scale)
+{
+  return meta_monitor_manager_is_scale_supported_with_threshold (manager,
+                                                                 layout_mode,
+                                                                 monitor,
+                                                                 monitor_mode,
+                                                                 scale,
+                                                                 FLT_EPSILON,
+                                                                 NULL);
+}
+
 static gboolean
 is_global_scale_matching_in_config (MetaMonitorsConfig *config,
                                     float               scale)
@@ -2455,6 +2758,8 @@
   g_autoptr (GVariant) properties_variant = NULL;
   gboolean enable_underscanning = FALSE;
   gboolean set_underscanning = FALSE;
+  gboolean allow_vrr = TRUE;
+  gboolean set_allow_vrr = FALSE;
 
   g_variant_get (monitor_config_variant, "(ss@a{sv})",
                  &connector,
@@ -2490,6 +2795,19 @@
         }
     }
 
+  set_allow_vrr =
+    g_variant_lookup (properties_variant, "allow_vrr", "b",
+                      &allow_vrr);
+  if (set_allow_vrr)
+    {
+      if (allow_vrr && !meta_monitor_is_vrr_capable (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Variable refresh rate requested but unsupported");
+          return NULL;
+        }
+    }
+
   monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
 
   monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
@@ -2499,7 +2817,8 @@
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = monitor_mode_spec,
-    .enable_underscanning = enable_underscanning
+    .enable_underscanning = enable_underscanning,
+    .disallow_vrr = !allow_vrr,
   };
 
   return monitor_config;
@@ -2590,6 +2909,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       width = roundf (width / scale);
       height = roundf (height / scale);
       break;
@@ -2689,9 +3009,11 @@
     .monitor_configs = monitor_configs
   };
 
-  if (!meta_verify_logical_monitor_config (logical_monitor_config,
+  if (layout_mode != META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL &&
+      !meta_verify_logical_monitor_config (logical_monitor_config,
                                            layout_mode,
                                            manager,
+                                           1.0f,
                                            error))
     {
       meta_logical_monitor_config_free (logical_monitor_config);
@@ -2712,6 +3034,7 @@
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       return TRUE;
     }
 
@@ -2736,6 +3059,7 @@
   MetaMonitorsConfig *config;
   GList *logical_monitor_configs = NULL;
   GError *error = NULL;
+  float max_scale = 1.0f;
 
   if (serial != manager->serial)
     {
@@ -2819,10 +3143,42 @@
           return TRUE;
         }
 
+      max_scale = MAX (max_scale, logical_monitor_config->scale);
       logical_monitor_configs = g_list_append (logical_monitor_configs,
                                                logical_monitor_config);
     }
 
+  if (manager->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      GList *l;
+      int ui_scale = ceilf (max_scale);
+
+      for (l = logical_monitor_configs; l; l = l->next)
+        {
+          MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+          logical_monitor_config->layout.width =
+            roundf (logical_monitor_config->layout.width * ui_scale);
+          logical_monitor_config->layout.height =
+            roundf (logical_monitor_config->layout.height * ui_scale);
+
+          if (!meta_verify_logical_monitor_config (logical_monitor_config,
+                                                   manager->layout_mode,
+                                                   manager,
+                                                   ui_scale,
+                                                   &error))
+            {
+              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                                    G_DBUS_ERROR_INVALID_ARGS,
+                                                    "%s", error->message);
+              g_error_free (error);
+              g_list_free_full (logical_monitor_configs,
+                                (GDestroyNotify) meta_logical_monitor_config_free);
+              return TRUE;
+            }
+        }
+    }
+
   config = meta_monitors_config_new (manager,
                                      logical_monitor_configs,
                                      layout_mode,
@@ -3529,6 +3885,10 @@
 {
   GList *gpus;
   GList *l;
+  gboolean has_tiling;
+
+  has_tiling = meta_monitor_manager_get_capabilities (manager) &
+                META_MONITOR_MANAGER_CAPABILITY_TILING;
 
   if (manager->monitors)
     {
@@ -3547,7 +3907,7 @@
           MetaOutput *output = k->data;
           const MetaOutputInfo *output_info = meta_output_get_info (output);
 
-          if (output_info->tile_info.group_id)
+          if (has_tiling && output_info->tile_info.group_id)
             {
               if (is_main_tiled_monitor_output (output))
                 {
@@ -3773,7 +4133,7 @@
   else
     manager->current_switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
 
-  manager->layout_mode = META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+  manager->layout_mode = meta_monitor_manager_get_default_layout_mode (manager);
 
   meta_monitor_manager_rebuild_logical_monitors_derived (manager, config);
 }
@@ -3782,10 +4142,14 @@
 meta_monitor_manager_rebuild_derived (MetaMonitorManager *manager,
                                       MetaMonitorsConfig *config)
 {
+  MetaMonitorManagerClass *klass = META_MONITOR_MANAGER_GET_CLASS (manager);
   GList *old_logical_monitors;
 
   meta_monitor_manager_update_monitor_modes_derived (manager);
 
+  if (klass->update_screen_size_derived)
+    klass->update_screen_size_derived (manager, config);
+
   if (manager->in_init)
     return;
 
diff '--color=auto' -uraN a/src/backends/meta-monitor-manager.c.orig b/src/backends/meta-monitor-manager.c.orig
--- a/src/backends/meta-monitor-manager.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor-manager.c.orig	2023-10-12 20:59:22.673833913 +0300
@@ -0,0 +1,4117 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2001, 2002 Havoc Pennington
+ * Copyright (C) 2002, 2003 Red Hat Inc.
+ * Some ICCCM manager selection code derived from fvwm2,
+ * Copyright (C) 2001 Dominik Vogt, Matthias Clasen, and fvwm2 team
+ * Copyright (C) 2003 Rob Adams
+ * Copyright (C) 2004-2006 Elijah Newren
+ * Copyright (C) 2013 Red Hat Inc.
+ * Copyright (C) 2020 NVIDIA CORPORATION
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/**
+ * MetaMonitorManager:
+ *
+ * A manager for multiple monitors
+ *
+ * #MetaMonitorManager is an abstract class which contains methods to handle
+ * multiple monitors (both #MetaMonitor and #MetaLogicalMonitor) and GPU's
+ * (#MetaGpu). Its functions include reading and/or changing the current
+ * configuration and available capabiliies.
+ *
+ * The #MetaMonitorManager also provides the "org.gnome.Mutter.DisplayConfig"
+ * DBus service, so apps like GNOME Settings can use this functionality.
+ */
+
+#include "config.h"
+
+#include "backends/meta-monitor-manager-private.h"
+
+#include <string.h>
+#include <math.h>
+#include <stdlib.h>
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-crtc.h"
+#include "backends/meta-logical-monitor.h"
+#include "backends/meta-monitor.h"
+#include "backends/meta-monitor-config-manager.h"
+#include "backends/meta-monitor-config-store.h"
+#include "backends/meta-orientation-manager.h"
+#include "backends/meta-output.h"
+#include "backends/meta-virtual-monitor.h"
+#include "backends/x11/meta-monitor-manager-xrandr.h"
+#include "clutter/clutter.h"
+#include "core/util-private.h"
+#include "meta/main.h"
+#include "meta/meta-enum-types.h"
+#include "meta/meta-x11-errors.h"
+
+#include "meta-dbus-display-config.h"
+
+#define DEFAULT_DISPLAY_CONFIGURATION_TIMEOUT 20
+
+enum
+{
+  PROP_0,
+
+  PROP_BACKEND,
+  PROP_PANEL_ORIENTATION_MANAGED,
+  PROP_HAS_BUILTIN_PANEL,
+  PROP_NIGHT_LIGHT_SUPPORTED,
+  PROP_EXPERIMENTAL_HDR,
+
+  PROP_LAST
+};
+
+static GParamSpec *obj_props[PROP_LAST];
+
+enum
+{
+  MONITORS_CHANGED,
+  MONITORS_CHANGED_INTERNAL,
+  POWER_SAVE_MODE_CHANGED,
+  CONFIRM_DISPLAY_CHANGE,
+  MONITOR_PRIVACY_SCREEN_CHANGED,
+  SIGNALS_LAST
+};
+
+/* Array index matches MetaMonitorTransform */
+static gfloat transform_matrices[][6] = {
+  {  1,  0,  0,  0,  1,  0 }, /* normal */
+  {  0, -1,  1,  1,  0,  0 }, /* 90° */
+  { -1,  0,  1,  0, -1,  1 }, /* 180° */
+  {  0,  1,  0, -1,  0,  1 }, /* 270° */
+  { -1,  0,  1,  0,  1,  0 }, /* normal flipped */
+  {  0,  1,  0,  1,  0,  0 }, /* 90° flipped */
+  {  1,  0,  0,  0, -1,  1 }, /* 180° flipped */
+  {  0, -1,  1, -1,  0,  1 }, /* 270° flipped */
+};
+
+static int signals[SIGNALS_LAST];
+
+typedef struct _MetaMonitorManagerPrivate
+{
+  MetaPowerSave power_save_mode;
+  gboolean      initial_orient_change_done;
+
+  GList *virtual_monitors;
+
+  gboolean shutting_down;
+
+  gboolean has_builtin_panel;
+  gboolean night_light_supported;
+  const char *experimental_hdr;
+
+  guint switch_config_handle_id;
+} MetaMonitorManagerPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaMonitorManager, meta_monitor_manager,
+                            G_TYPE_OBJECT)
+
+static void initialize_dbus_interface (MetaMonitorManager *manager);
+static void monitor_manager_setup_dbus_config_handlers (MetaMonitorManager *manager);
+
+static gboolean
+meta_monitor_manager_is_config_complete (MetaMonitorManager *manager,
+                                         MetaMonitorsConfig *config);
+
+static void
+meta_monitor_manager_real_read_current_state (MetaMonitorManager *manager);
+
+static gboolean
+is_global_scale_matching_in_config (MetaMonitorsConfig *config,
+                                    float               scale);
+
+MetaBackend *
+meta_monitor_manager_get_backend (MetaMonitorManager *manager)
+{
+  return manager->backend;
+}
+
+static void
+meta_monitor_manager_init (MetaMonitorManager *manager)
+{
+}
+
+static void
+meta_monitor_manager_set_primary_logical_monitor (MetaMonitorManager *manager,
+                                                  MetaLogicalMonitor *logical_monitor)
+{
+  manager->primary_logical_monitor = logical_monitor;
+  if (logical_monitor)
+    meta_logical_monitor_make_primary (logical_monitor);
+}
+
+static gboolean
+is_main_tiled_monitor_output (MetaOutput *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+
+  return (output_info->tile_info.loc_h_tile == 0 &&
+          output_info->tile_info.loc_v_tile == 0);
+}
+
+static MetaLogicalMonitor *
+logical_monitor_from_layout (MetaMonitorManager *manager,
+                             GList              *logical_monitors,
+                             MtkRectangle       *layout)
+{
+  GList *l;
+
+  for (l = logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+
+      if (mtk_rectangle_equal (layout, &logical_monitor->rect))
+        return logical_monitor;
+    }
+
+  return NULL;
+}
+
+static void
+meta_monitor_manager_rebuild_logical_monitors (MetaMonitorManager *manager,
+                                               MetaMonitorsConfig *config)
+{
+  GList *logical_monitor_configs;
+  GList *logical_monitors = NULL;
+  GList *l;
+  int monitor_number = 0;
+  MetaLogicalMonitor *primary_logical_monitor = NULL;
+
+  logical_monitor_configs = config ? config->logical_monitor_configs : NULL;
+  for (l = logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      MetaLogicalMonitor *logical_monitor;
+
+      logical_monitor = meta_logical_monitor_new (manager,
+                                                  logical_monitor_config,
+                                                  monitor_number);
+      monitor_number++;
+
+      if (logical_monitor_config->is_primary)
+        primary_logical_monitor = logical_monitor;
+
+      logical_monitors = g_list_append (logical_monitors, logical_monitor);
+    }
+
+  /*
+   * If no monitor was marked as primary, fall back on marking the first
+   * logical monitor the primary one.
+   */
+  if (!primary_logical_monitor && logical_monitors)
+    primary_logical_monitor = g_list_first (logical_monitors)->data;
+
+  manager->logical_monitors = logical_monitors;
+  meta_monitor_manager_set_primary_logical_monitor (manager,
+                                                    primary_logical_monitor);
+}
+
+static float
+derive_configured_global_scale (MetaMonitorManager *manager,
+                                MetaMonitorsConfig *config)
+{
+  GList *l;
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *monitor_config = l->data;
+
+      if (is_global_scale_matching_in_config (config, monitor_config->scale))
+        return monitor_config->scale;
+    }
+
+  return 1.0;
+}
+
+static float
+calculate_monitor_scale (MetaMonitorManager *manager,
+                         MetaMonitor        *monitor)
+{
+  MetaMonitorMode *monitor_mode;
+
+  monitor_mode = meta_monitor_get_current_mode (monitor);
+  return meta_monitor_manager_calculate_monitor_mode_scale (manager,
+                                                            manager->layout_mode,
+                                                            monitor,
+                                                            monitor_mode);
+}
+
+static gboolean
+meta_monitor_manager_is_scale_supported_by_other_monitors (MetaMonitorManager *manager,
+                                                           MetaMonitor        *not_this_one,
+                                                           float               scale)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorMode *mode;
+
+      if (monitor == not_this_one || !meta_monitor_is_active (monitor))
+        continue;
+
+      mode = meta_monitor_get_current_mode (monitor);
+      if (!meta_monitor_manager_is_scale_supported (manager,
+                                                    manager->layout_mode,
+                                                    monitor, mode, scale))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static float
+derive_calculated_global_scale (MetaMonitorManager *manager)
+{
+  MetaMonitor *monitor = NULL;
+  float scale;
+  GList *l;
+
+  scale = 1.0;
+  monitor = meta_monitor_manager_get_primary_monitor (manager);
+
+  if (monitor && meta_monitor_is_active (monitor))
+    {
+      scale = calculate_monitor_scale (manager, monitor);
+      if (meta_monitor_manager_is_scale_supported_by_other_monitors (manager,
+                                                                     monitor,
+                                                                     scale))
+        return scale;
+    }
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *other_monitor = l->data;
+      float monitor_scale;
+
+      if (other_monitor == monitor || !meta_monitor_is_active (other_monitor))
+        continue;
+
+      monitor_scale = calculate_monitor_scale (manager, other_monitor);
+      if (meta_monitor_manager_is_scale_supported_by_other_monitors (manager,
+                                                                     other_monitor,
+                                                                     monitor_scale))
+        scale = MAX (scale, monitor_scale);
+    }
+
+  return scale;
+}
+
+static float
+derive_scale_from_config (MetaMonitorManager *manager,
+                          MetaMonitorsConfig *config,
+                          MtkRectangle       *layout)
+{
+  GList *l;
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+      if (mtk_rectangle_equal (layout, &logical_monitor_config->layout))
+        return logical_monitor_config->scale;
+    }
+
+  g_warning ("Missing logical monitor, using scale 1");
+  return 1.0;
+}
+
+static void
+meta_monitor_manager_rebuild_logical_monitors_derived (MetaMonitorManager *manager,
+                                                       MetaMonitorsConfig *config)
+{
+  GList *logical_monitors = NULL;
+  GList *l;
+  int monitor_number;
+  MetaLogicalMonitor *primary_logical_monitor = NULL;
+  gboolean use_global_scale;
+  float global_scale = 0.0;
+  MetaMonitorManagerCapability capabilities;
+
+  monitor_number = 0;
+
+  capabilities = meta_monitor_manager_get_capabilities (manager);
+  use_global_scale =
+    !!(capabilities & META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED);
+
+  if (use_global_scale)
+    {
+      if (config)
+        global_scale = derive_configured_global_scale (manager, config);
+      else
+        global_scale = derive_calculated_global_scale (manager);
+    }
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaLogicalMonitor *logical_monitor;
+      MtkRectangle layout;
+
+      if (!meta_monitor_is_active (monitor))
+        continue;
+
+      meta_monitor_derive_layout (monitor, &layout);
+      logical_monitor = logical_monitor_from_layout (manager, logical_monitors,
+                                                     &layout);
+      if (logical_monitor)
+        {
+          meta_logical_monitor_add_monitor (logical_monitor, monitor);
+        }
+      else
+        {
+          float scale;
+
+          if (use_global_scale)
+            scale = global_scale;
+          else if (config)
+            scale = derive_scale_from_config (manager, config, &layout);
+          else
+            scale = calculate_monitor_scale (manager, monitor);
+
+          g_assert (scale > 0);
+
+          logical_monitor = meta_logical_monitor_new_derived (manager,
+                                                              monitor,
+                                                              &layout,
+                                                              scale,
+                                                              monitor_number);
+          logical_monitors = g_list_append (logical_monitors, logical_monitor);
+          monitor_number++;
+        }
+
+      if (meta_monitor_is_primary (monitor))
+        primary_logical_monitor = logical_monitor;
+    }
+
+  manager->logical_monitors = logical_monitors;
+
+  /*
+   * If no monitor was marked as primary, fall back on marking the first
+   * logical monitor the primary one.
+   */
+  if (!primary_logical_monitor && manager->logical_monitors)
+    primary_logical_monitor = g_list_first (manager->logical_monitors)->data;
+
+  meta_monitor_manager_set_primary_logical_monitor (manager,
+                                                    primary_logical_monitor);
+}
+
+void
+meta_monitor_manager_power_save_mode_changed (MetaMonitorManager        *manager,
+                                              MetaPowerSave              mode,
+                                              MetaPowerSaveChangeReason  reason)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  if (priv->power_save_mode == mode)
+    return;
+
+  priv->power_save_mode = mode;
+  g_signal_emit (manager, signals[POWER_SAVE_MODE_CHANGED], 0, reason);
+}
+
+static void
+power_save_mode_changed (MetaMonitorManager *manager,
+                         GParamSpec         *pspec,
+                         gpointer            user_data)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  MetaMonitorManagerClass *klass;
+  int mode = meta_dbus_display_config_get_power_save_mode (manager->display_config);
+  MetaPowerSaveChangeReason reason;
+
+  if (mode == META_POWER_SAVE_UNSUPPORTED)
+    return;
+
+  /* If DPMS is unsupported, force the property back. */
+  if (priv->power_save_mode == META_POWER_SAVE_UNSUPPORTED)
+    {
+      meta_dbus_display_config_set_power_save_mode (manager->display_config, META_POWER_SAVE_UNSUPPORTED);
+      return;
+    }
+
+  klass = META_MONITOR_MANAGER_GET_CLASS (manager);
+  if (klass->set_power_save_mode)
+    klass->set_power_save_mode (manager, mode);
+
+  reason = META_POWER_SAVE_CHANGE_REASON_MODE_CHANGE;
+  meta_monitor_manager_power_save_mode_changed (manager, mode, reason);
+}
+
+void
+meta_monitor_manager_lid_is_closed_changed (MetaMonitorManager *manager)
+{
+  meta_monitor_manager_ensure_configured (manager);
+}
+
+static void
+lid_is_closed_changed (MetaBackend *backend,
+                       gboolean     lid_is_closed,
+                       gpointer     user_data)
+{
+  MetaMonitorManager *manager = user_data;
+  meta_monitor_manager_lid_is_closed_changed (manager);
+}
+
+static void
+prepare_shutdown (MetaBackend        *backend,
+                  MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  priv->shutting_down = TRUE;
+}
+
+static void
+ensure_hdr_settings (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  MetaOutputColorspace color_space;
+  MetaOutputHdrMetadata hdr_metadata;
+  GList *l;
+
+  if (g_strcmp0 (priv->experimental_hdr, "on") == 0)
+    {
+      color_space = META_OUTPUT_COLORSPACE_BT2020;
+      hdr_metadata = (MetaOutputHdrMetadata) {
+        .active = TRUE,
+        .eotf = META_OUTPUT_HDR_METADATA_EOTF_PQ,
+      };
+
+      meta_topic (META_DEBUG_COLOR,
+                  "MonitorManager: Trying to enabling HDR mode "
+                  "(Colorimetry: bt.2020, TF: PQ, HDR Metadata: Minimal):");
+    }
+  else
+    {
+      color_space = META_OUTPUT_COLORSPACE_DEFAULT;
+      hdr_metadata = (MetaOutputHdrMetadata) {
+        .active = FALSE,
+      };
+
+      meta_topic (META_DEBUG_COLOR,
+                  "MonitorManager: Trying to enable default mode "
+                  "(Colorimetry: default, TF: default, HDR Metadata: None):");
+    }
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      g_autoptr (GError) error = NULL;
+
+      if (!meta_monitor_set_color_space (monitor, color_space, &error))
+        {
+          meta_monitor_set_color_space (monitor,
+                                        META_OUTPUT_COLORSPACE_DEFAULT,
+                                        NULL);
+          meta_monitor_set_hdr_metadata (monitor, &(MetaOutputHdrMetadata) {
+                                           .active = FALSE,
+                                         }, NULL);
+
+          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
+            {
+              meta_topic (META_DEBUG_COLOR,
+                          "MonitorManager: Colorimetry not supported "
+                          "on monitor %s",
+                          meta_monitor_get_display_name (monitor));
+            }
+          else
+            {
+              g_warning ("Failed to set color space on monitor %s: %s",
+                         meta_monitor_get_display_name (monitor), error->message);
+            }
+
+          continue;
+        }
+
+      if (!meta_monitor_set_hdr_metadata (monitor, &hdr_metadata, &error))
+        {
+          meta_monitor_set_color_space (monitor,
+                                        META_OUTPUT_COLORSPACE_DEFAULT,
+                                        NULL);
+          meta_monitor_set_hdr_metadata (monitor, &(MetaOutputHdrMetadata) {
+                                           .active = FALSE,
+                                         }, NULL);
+
+          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
+            {
+              meta_topic (META_DEBUG_COLOR,
+                          "MonitorManager: HDR Metadata not supported "
+                          "on monitor %s",
+                          meta_monitor_get_display_name (monitor));
+            }
+          else
+            {
+              g_warning ("Failed to set HDR metadata on monitor %s: %s",
+                         meta_monitor_get_display_name (monitor),
+                         error->message);
+            }
+
+          continue;
+        }
+
+        meta_topic (META_DEBUG_COLOR,
+                    "MonitorManager: successfully set on monitor %s",
+                    meta_monitor_get_display_name (monitor));
+    }
+}
+
+/**
+ * meta_monitor_manager_is_headless:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns whether the monitor manager is headless, i.e. without
+ * any `MetaLogicalMonitor`s attached to it.
+ *
+ * Returns: %TRUE if no monitors are attached, %FALSE otherwise.
+ */
+gboolean
+meta_monitor_manager_is_headless (MetaMonitorManager *manager)
+{
+  return !manager->logical_monitors;
+}
+
+float
+meta_monitor_manager_calculate_monitor_mode_scale (MetaMonitorManager           *manager,
+                                                   MetaLogicalMonitorLayoutMode  layout_mode,
+                                                   MetaMonitor                  *monitor,
+                                                   MetaMonitorMode              *monitor_mode)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->calculate_monitor_mode_scale (manager,
+                                                      layout_mode,
+                                                      monitor,
+                                                      monitor_mode);
+}
+
+float *
+meta_monitor_manager_calculate_supported_scales (MetaMonitorManager           *manager,
+                                                 MetaLogicalMonitorLayoutMode  layout_mode,
+                                                 MetaMonitor                  *monitor,
+                                                 MetaMonitorMode              *monitor_mode,
+                                                 int                          *n_supported_scales)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->calculate_supported_scales (manager,
+                                                    layout_mode,
+                                                    monitor,
+                                                    monitor_mode,
+                                                    n_supported_scales);
+}
+
+/**
+ * meta_monitor_manager_get_capabilities:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Queries the capabilities of the monitor manager.
+ *
+ * Returns: #MetaMonitorManagerCapability flags representing the capabilities.
+ */
+MetaMonitorManagerCapability
+meta_monitor_manager_get_capabilities (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->get_capabilities (manager);
+}
+
+gboolean
+meta_monitor_manager_get_max_screen_size (MetaMonitorManager *manager,
+                                          int                *max_width,
+                                          int                *max_height)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->get_max_screen_size (manager, max_width, max_height);
+}
+
+
+MetaLogicalMonitorLayoutMode
+meta_monitor_manager_get_default_layout_mode (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->get_default_layout_mode (manager);
+}
+
+static void
+on_virtual_monitor_destroyed (MetaVirtualMonitor *virtual_monitor,
+                              MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  MetaOutput *output;
+
+  output = meta_virtual_monitor_get_output (virtual_monitor);
+  g_message ("Removed virtual monitor %s", meta_output_get_name (output));
+  priv->virtual_monitors = g_list_remove (priv->virtual_monitors,
+                                          virtual_monitor);
+
+  if (!priv->shutting_down)
+    meta_monitor_manager_reload (manager);
+}
+
+MetaVirtualMonitor *
+meta_monitor_manager_create_virtual_monitor (MetaMonitorManager            *manager,
+                                             const MetaVirtualMonitorInfo  *info,
+                                             GError                       **error)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+  MetaVirtualMonitor *virtual_monitor;
+  MetaOutput *output;
+
+  if (!manager_class->create_virtual_monitor)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Backend doesn't support creating virtual monitors");
+      return NULL;
+    }
+
+  virtual_monitor = manager_class->create_virtual_monitor (manager, info,
+                                                           error);
+  if (!virtual_monitor)
+    return NULL;
+
+  g_signal_connect (virtual_monitor, "destroy",
+                    G_CALLBACK (on_virtual_monitor_destroyed),
+                    manager);
+
+  priv->virtual_monitors = g_list_append (priv->virtual_monitors,
+                                          virtual_monitor);
+
+  output = meta_virtual_monitor_get_output (virtual_monitor);
+  g_message ("Added virtual monitor %s", meta_output_get_name (output));
+
+  return virtual_monitor;
+}
+
+static void
+meta_monitor_manager_ensure_initial_config (MetaMonitorManager *manager)
+{
+  META_MONITOR_MANAGER_GET_CLASS (manager)->ensure_initial_config (manager);
+}
+
+static gboolean
+meta_monitor_manager_apply_monitors_config (MetaMonitorManager      *manager,
+                                            MetaMonitorsConfig      *config,
+                                            MetaMonitorsConfigMethod method,
+                                            GError                 **error)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  g_assert (!config ||
+            !(config->flags & META_MONITORS_CONFIG_FLAG_MIGRATED));
+
+  if (!manager_class->apply_monitors_config (manager, config, method, error))
+    return FALSE;
+
+  switch (method)
+    {
+    case META_MONITORS_CONFIG_METHOD_TEMPORARY:
+    case META_MONITORS_CONFIG_METHOD_PERSISTENT:
+      meta_monitor_config_manager_set_current (manager->config_manager, config);
+      break;
+    case META_MONITORS_CONFIG_METHOD_VERIFY:
+      break;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_monitor_manager_has_hotplug_mode_update (MetaMonitorManager *manager)
+{
+  GList *gpus;
+  GList *l;
+
+  gpus = meta_backend_get_gpus (manager->backend);
+  for (l = gpus; l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+
+      if (meta_gpu_has_hotplug_mode_update (gpu))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+should_use_stored_config (MetaMonitorManager *manager)
+{
+  return (manager->in_init ||
+          !meta_monitor_manager_has_hotplug_mode_update (manager));
+}
+
+MetaMonitorsConfig *
+meta_monitor_manager_ensure_configured (MetaMonitorManager *manager)
+{
+  MetaMonitorsConfig *config = NULL;
+  GError *error = NULL;
+  gboolean use_stored_config;
+  MetaMonitorsConfigMethod method;
+  MetaMonitorsConfigMethod fallback_method =
+    META_MONITORS_CONFIG_METHOD_TEMPORARY;
+
+  use_stored_config = should_use_stored_config (manager);
+  if (use_stored_config)
+    method = META_MONITORS_CONFIG_METHOD_PERSISTENT;
+  else
+    method = META_MONITORS_CONFIG_METHOD_TEMPORARY;
+
+  if (use_stored_config)
+    {
+      config = meta_monitor_config_manager_get_stored (manager->config_manager);
+      if (config)
+        {
+          g_autoptr (MetaMonitorsConfig) oriented_config = NULL;
+
+          if (manager->panel_orientation_managed)
+            {
+              oriented_config = meta_monitor_config_manager_create_for_builtin_orientation (
+                manager->config_manager, config);
+
+              if (oriented_config)
+                config = oriented_config;
+            }
+
+          if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                           config,
+                                                           method,
+                                                           &error))
+            {
+              config = NULL;
+              g_warning ("Failed to use stored monitor configuration: %s",
+                         error->message);
+              g_clear_error (&error);
+            }
+          else
+            {
+              g_object_ref (config);
+              goto done;
+            }
+        }
+    }
+
+  if (manager->panel_orientation_managed)
+    {
+      MetaMonitorsConfig *current_config =
+        meta_monitor_config_manager_get_current (manager->config_manager);
+
+      if (current_config)
+        {
+          config = meta_monitor_config_manager_create_for_builtin_orientation (
+            manager->config_manager, current_config);
+        }
+    }
+
+  if (config)
+    {
+      if (meta_monitor_manager_is_config_complete (manager, config))
+        {
+          if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                           config,
+                                                           method,
+                                                           &error))
+            {
+              g_clear_object (&config);
+              g_warning ("Failed to use current monitor configuration: %s",
+                         error->message);
+              g_clear_error (&error);
+            }
+          else
+            {
+              goto done;
+            }
+        }
+    }
+
+  config = meta_monitor_config_manager_create_suggested (manager->config_manager);
+  if (config)
+    {
+      if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                       config,
+                                                       method,
+                                                       &error))
+        {
+          g_clear_object (&config);
+          g_warning ("Failed to use suggested monitor configuration: %s",
+                     error->message);
+          g_clear_error (&error);
+        }
+      else
+        {
+          goto done;
+        }
+    }
+
+  config = meta_monitor_config_manager_get_previous (manager->config_manager);
+  if (config)
+    {
+      g_autoptr (MetaMonitorsConfig) oriented_config = NULL;
+
+      if (manager->panel_orientation_managed)
+        {
+          oriented_config =
+            meta_monitor_config_manager_create_for_builtin_orientation (
+              manager->config_manager, config);
+
+          if (oriented_config)
+            config = oriented_config;
+        }
+
+      config = g_object_ref (config);
+
+      if (meta_monitor_manager_is_config_complete (manager, config))
+        {
+          if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                           config,
+                                                           method,
+                                                           &error))
+            {
+              g_warning ("Failed to use suggested monitor configuration: %s",
+                         error->message);
+              g_clear_error (&error);
+            }
+          else
+            {
+              goto done;
+            }
+        }
+
+      g_clear_object (&config);
+    }
+
+  config = meta_monitor_config_manager_create_linear (manager->config_manager);
+  if (config)
+    {
+      if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                       config,
+                                                       method,
+                                                       &error))
+        {
+          g_clear_object (&config);
+          g_warning ("Failed to use linear monitor configuration: %s",
+                     error->message);
+          g_clear_error (&error);
+        }
+      else
+        {
+          goto done;
+        }
+    }
+
+  config = meta_monitor_config_manager_create_fallback (manager->config_manager);
+  if (config)
+    {
+      if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                       config,
+                                                       fallback_method,
+                                                       &error))
+        {
+          g_clear_object (&config);
+          g_warning ("Failed to use fallback monitor configuration: %s",
+                     error->message);
+          g_clear_error (&error);
+        }
+      else
+        {
+          goto done;
+        }
+    }
+
+done:
+  if (!config)
+    {
+      meta_monitor_manager_apply_monitors_config (manager,
+                                                  NULL,
+                                                  fallback_method,
+                                                  &error);
+      return NULL;
+    }
+
+  g_object_unref (config);
+
+  return config;
+}
+
+static void
+handle_orientation_change (MetaOrientationManager *orientation_manager,
+                           MetaMonitorManager     *manager)
+{
+  MetaOrientation orientation;
+  MetaMonitorTransform transform;
+  MetaMonitorTransform panel_transform;
+  GError *error = NULL;
+  MetaMonitorsConfig *config;
+  MetaMonitor *laptop_panel;
+  MetaLogicalMonitor *laptop_logical_monitor;
+  MetaMonitorsConfig *current_config;
+
+  laptop_panel = meta_monitor_manager_get_laptop_panel (manager);
+  g_return_if_fail (laptop_panel);
+
+  if (!meta_monitor_is_active (laptop_panel))
+    return;
+
+  orientation = meta_orientation_manager_get_orientation (orientation_manager);
+  transform = meta_monitor_transform_from_orientation (orientation);
+
+  laptop_logical_monitor = meta_monitor_get_logical_monitor (laptop_panel);
+  panel_transform =
+    meta_monitor_crtc_to_logical_transform (laptop_panel, transform);
+  if (meta_logical_monitor_get_transform (laptop_logical_monitor) ==
+      panel_transform)
+    return;
+
+  current_config =
+    meta_monitor_config_manager_get_current (manager->config_manager);
+  if (!current_config)
+    return;
+
+  config =
+    meta_monitor_config_manager_create_for_orientation (manager->config_manager,
+                                                        current_config,
+                                                        transform);
+  if (!config)
+    return;
+
+  if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                   config,
+                                                   META_MONITORS_CONFIG_METHOD_TEMPORARY,
+                                                   &error))
+    {
+      g_warning ("Failed to use orientation monitor configuration: %s",
+                 error->message);
+      g_error_free (error);
+    }
+  g_object_unref (config);
+}
+
+/*
+ * Special case for tablets with a native portrait mode and a keyboard dock,
+ * where the device gets docked in landscape mode. For this combo to work
+ * properly with mutter starting while the tablet is docked, we need to take
+ * the accelerometer reported orientation into account (at mutter startup)
+ * even if there is a tablet-mode-switch which indicates that the device is
+ * NOT in tablet-mode (because it is docked).
+ */
+static gboolean
+handle_initial_orientation_change (MetaOrientationManager *orientation_manager,
+                                   MetaMonitorManager     *manager)
+{
+  ClutterBackend *clutter_backend;
+  ClutterSeat *seat;
+  MetaMonitor *monitor;
+  MetaMonitorMode *mode;
+  int width, height;
+
+  clutter_backend = meta_backend_get_clutter_backend (manager->backend);
+  seat = clutter_backend_get_default_seat (clutter_backend);
+
+  /*
+   * This is a workaround to ignore the tablet mode switch on the initial config
+   * of devices with a native portrait mode panel. The touchscreen and
+   * accelerometer requirements for applying the orientation must still be met.
+   */
+  if (!clutter_seat_has_touchscreen (seat) ||
+      !meta_orientation_manager_has_accelerometer (orientation_manager))
+    return FALSE;
+
+  /* Check for a portrait mode panel */
+  monitor = meta_monitor_manager_get_laptop_panel (manager);
+  if (!monitor)
+    return FALSE;
+
+  mode = meta_monitor_get_preferred_mode (monitor);
+  meta_monitor_mode_get_resolution (mode, &width, &height);
+  if (width > height)
+    return FALSE;
+
+  handle_orientation_change (orientation_manager, manager);
+  return TRUE;
+}
+
+static void
+orientation_changed (MetaOrientationManager *orientation_manager,
+                     MetaMonitorManager     *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  if (!priv->initial_orient_change_done)
+    {
+      priv->initial_orient_change_done = TRUE;
+      if (handle_initial_orientation_change (orientation_manager, manager))
+        return;
+    }
+
+  if (!manager->panel_orientation_managed)
+    return;
+
+  handle_orientation_change (orientation_manager, manager);
+}
+
+static void
+experimental_features_changed (MetaSettings           *settings,
+                               MetaExperimentalFeature old_experimental_features,
+                               MetaMonitorManager     *manager)
+{
+  gboolean was_stage_views_scaled;
+  gboolean is_stage_views_scaled;
+  gboolean should_reconfigure = FALSE;
+
+  was_stage_views_scaled =
+    !!(old_experimental_features &
+       META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+  is_stage_views_scaled =
+    meta_settings_is_experimental_feature_enabled (
+      settings,
+      META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+
+  if (is_stage_views_scaled != was_stage_views_scaled)
+    should_reconfigure = TRUE;
+
+  if (should_reconfigure)
+    meta_monitor_manager_reconfigure (manager);
+
+  meta_settings_update_ui_scaling_factor (settings);
+}
+
+static gboolean
+ensure_privacy_screen_settings (MetaMonitorManager *manager)
+{
+  MetaSettings *settings = meta_backend_get_settings (manager->backend);
+  gboolean privacy_screen_enabled;
+  GList *l;
+
+  privacy_screen_enabled = meta_settings_is_privacy_screen_enabled (settings);
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      g_autoptr (GError) error = NULL;
+
+      if (!meta_monitor_set_privacy_screen_enabled (monitor,
+                                                    privacy_screen_enabled,
+                                                    &error))
+        {
+          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
+            continue;
+
+          g_warning ("Failed to set privacy screen setting on monitor %s: %s",
+                     meta_monitor_get_display_name (monitor), error->message);
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+static MetaPrivacyScreenState
+get_global_privacy_screen_state (MetaMonitorManager *manager)
+{
+  MetaPrivacyScreenState global_state = META_PRIVACY_SCREEN_UNAVAILABLE;
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaPrivacyScreenState monitor_state;
+
+      if (!meta_monitor_is_active (monitor))
+        continue;
+
+      monitor_state = meta_monitor_get_privacy_screen_state (monitor);
+      if (monitor_state == META_PRIVACY_SCREEN_UNAVAILABLE)
+        continue;
+
+      if (monitor_state & META_PRIVACY_SCREEN_DISABLED)
+        return META_PRIVACY_SCREEN_DISABLED;
+
+      if (monitor_state & META_PRIVACY_SCREEN_ENABLED)
+        global_state = META_PRIVACY_SCREEN_ENABLED;
+    }
+
+  return global_state;
+}
+
+static gboolean
+privacy_screen_needs_update (MetaMonitorManager *manager)
+{
+  MetaSettings *settings = meta_backend_get_settings (manager->backend);
+  MetaPrivacyScreenState privacy_screen_state =
+    get_global_privacy_screen_state (manager);
+
+  if (privacy_screen_state == META_PRIVACY_SCREEN_UNAVAILABLE)
+    return FALSE;
+
+  return (!!(privacy_screen_state & META_PRIVACY_SCREEN_ENABLED) !=
+      meta_settings_is_privacy_screen_enabled (settings));
+}
+
+static void
+apply_privacy_screen_settings (MetaMonitorManager *manager)
+{
+  if (privacy_screen_needs_update (manager) &&
+      ensure_privacy_screen_settings (manager))
+    {
+      manager->privacy_screen_change_state =
+        META_PRIVACY_SCREEN_CHANGE_STATE_PENDING_SETTING;
+    }
+}
+
+static void
+update_panel_orientation_managed (MetaMonitorManager *manager)
+{
+  MetaOrientationManager *orientation_manager;
+  ClutterBackend *clutter_backend;
+  ClutterSeat *seat;
+  gboolean panel_orientation_managed;
+
+  clutter_backend = meta_backend_get_clutter_backend (manager->backend);
+  seat = clutter_backend_get_default_seat (clutter_backend);
+
+  orientation_manager = meta_backend_get_orientation_manager (manager->backend);
+
+  panel_orientation_managed =
+    (clutter_seat_get_touch_mode (seat) &&
+     meta_orientation_manager_has_accelerometer (orientation_manager) &&
+     meta_monitor_manager_get_laptop_panel (manager));
+
+  if (manager->panel_orientation_managed == panel_orientation_managed)
+    return;
+
+  manager->panel_orientation_managed = panel_orientation_managed;
+  g_object_notify_by_pspec (G_OBJECT (manager),
+                            obj_props[PROP_PANEL_ORIENTATION_MANAGED]);
+
+  meta_dbus_display_config_set_panel_orientation_managed (manager->display_config,
+                                                          manager->panel_orientation_managed);
+
+  /* The orientation may have changed while it was unmanaged */
+  if (panel_orientation_managed)
+    handle_orientation_change (orientation_manager, manager);
+}
+
+static void
+update_has_builtin_panel (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  GList *l;
+  gboolean has_builtin_panel = FALSE;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = META_MONITOR (l->data);
+
+      if (meta_monitor_is_laptop_panel (monitor))
+        {
+          has_builtin_panel = TRUE;
+          break;
+        }
+    }
+
+  if (priv->has_builtin_panel == has_builtin_panel)
+    return;
+
+  priv->has_builtin_panel = has_builtin_panel;
+  g_object_notify_by_pspec (G_OBJECT (manager),
+                            obj_props[PROP_HAS_BUILTIN_PANEL]);
+}
+
+static void
+update_night_light_supported (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  GList *l;
+
+  gboolean night_light_supported = FALSE;
+
+  for (l = meta_backend_get_gpus (manager->backend); l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+      GList *l_crtc;
+
+      for (l_crtc = meta_gpu_get_crtcs (gpu); l_crtc; l_crtc = l_crtc->next)
+        {
+          MetaCrtc *crtc = l_crtc->data;
+
+          if (meta_crtc_get_gamma_lut_size (crtc) > 0)
+            {
+              night_light_supported = TRUE;
+              break;
+            }
+        }
+    }
+
+  if (priv->night_light_supported == night_light_supported)
+    return;
+
+  priv->night_light_supported = night_light_supported;
+  g_object_notify_by_pspec (G_OBJECT (manager),
+                            obj_props[PROP_NIGHT_LIGHT_SUPPORTED]);
+  meta_dbus_display_config_set_night_light_supported (manager->display_config,
+                                                      night_light_supported);
+}
+
+void
+meta_monitor_manager_setup (MetaMonitorManager *manager)
+{
+  MetaMonitorConfigStore *config_store;
+  const MetaMonitorConfigPolicy *policy;
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  manager->in_init = TRUE;
+
+  manager->config_manager = meta_monitor_config_manager_new (manager);
+  config_store =
+    meta_monitor_config_manager_get_store (manager->config_manager);
+  policy = meta_monitor_config_store_get_policy (config_store);
+  meta_dbus_display_config_set_apply_monitors_config_allowed (manager->display_config,
+                                                              policy->enable_dbus);
+
+  meta_dbus_display_config_set_night_light_supported (manager->display_config,
+                                                      priv->night_light_supported);
+
+  meta_monitor_manager_read_current_state (manager);
+
+  meta_monitor_manager_ensure_initial_config (manager);
+
+  if (privacy_screen_needs_update (manager))
+    manager->privacy_screen_change_state = META_PRIVACY_SCREEN_CHANGE_STATE_INIT;
+
+  manager->in_init = FALSE;
+}
+
+static void
+meta_monitor_manager_constructed (GObject *object)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaBackend *backend = manager->backend;
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  manager->display_config = meta_dbus_display_config_skeleton_new ();
+
+  g_signal_connect_object (settings,
+                           "experimental-features-changed",
+                           G_CALLBACK (experimental_features_changed),
+                           manager, 0);
+
+  g_signal_connect_object (settings,
+                           "privacy-screen-changed",
+                           G_CALLBACK (apply_privacy_screen_settings),
+                           manager, G_CONNECT_SWAPPED);
+
+  monitor_manager_setup_dbus_config_handlers (manager);
+
+  g_signal_connect_object (manager->display_config, "notify::power-save-mode",
+                           G_CALLBACK (power_save_mode_changed), manager,
+                           G_CONNECT_SWAPPED);
+
+  g_signal_connect_object (meta_backend_get_orientation_manager (backend),
+                           "orientation-changed",
+                           G_CALLBACK (orientation_changed),
+                           manager, 0);
+
+  g_signal_connect_object (meta_backend_get_orientation_manager (backend),
+                           "notify::has-accelerometer",
+                           G_CALLBACK (update_panel_orientation_managed), manager,
+                           G_CONNECT_SWAPPED);
+
+  g_signal_connect_object (backend,
+                           "lid-is-closed-changed",
+                           G_CALLBACK (lid_is_closed_changed),
+                           manager, 0);
+
+  g_signal_connect (backend, "prepare-shutdown",
+                    G_CALLBACK (prepare_shutdown),
+                    manager);
+
+  g_signal_connect (manager, "notify::experimental-hdr",
+                    G_CALLBACK (ensure_hdr_settings),
+                    NULL);
+
+  manager->current_switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
+
+  initialize_dbus_interface (manager);
+}
+
+static void
+meta_monitor_manager_finalize (GObject *object)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  g_list_free_full (manager->logical_monitors, g_object_unref);
+
+  g_warn_if_fail (!priv->virtual_monitors);
+
+  G_OBJECT_CLASS (meta_monitor_manager_parent_class)->finalize (object);
+}
+
+static void
+meta_monitor_manager_dispose (GObject *object)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  g_clear_handle_id (&manager->dbus_name_id, g_bus_unown_name);
+
+  g_clear_object (&manager->display_config);
+  g_clear_object (&manager->config_manager);
+
+  g_clear_handle_id (&manager->persistent_timeout_id, g_source_remove);
+  g_clear_handle_id (&manager->restore_config_id, g_source_remove);
+  g_clear_handle_id (&priv->switch_config_handle_id, g_source_remove);
+
+  G_OBJECT_CLASS (meta_monitor_manager_parent_class)->dispose (object);
+}
+
+static GBytes *
+meta_monitor_manager_real_read_edid (MetaMonitorManager *manager,
+                                     MetaOutput         *output)
+{
+  return NULL;
+}
+
+static void
+meta_monitor_manager_set_property (GObject      *object,
+                                   guint         prop_id,
+                                   const GValue *value,
+                                   GParamSpec   *pspec)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      manager->backend = g_value_get_object (value);
+      break;
+    case PROP_EXPERIMENTAL_HDR:
+      priv->experimental_hdr = g_value_dup_string (value);
+      break;
+    case PROP_PANEL_ORIENTATION_MANAGED:
+    case PROP_HAS_BUILTIN_PANEL:
+    case PROP_NIGHT_LIGHT_SUPPORTED:
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_monitor_manager_get_property (GObject    *object,
+                                   guint       prop_id,
+                                   GValue     *value,
+                                   GParamSpec *pspec)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      g_value_set_object (value, manager->backend);
+      break;
+    case PROP_PANEL_ORIENTATION_MANAGED:
+      g_value_set_boolean (value, manager->panel_orientation_managed);
+      break;
+    case PROP_HAS_BUILTIN_PANEL:
+      g_value_set_boolean (value, priv->has_builtin_panel);
+      break;
+    case PROP_NIGHT_LIGHT_SUPPORTED:
+      g_value_set_boolean (value, priv->night_light_supported);
+      break;
+    case PROP_EXPERIMENTAL_HDR:
+      g_value_set_string (value, priv->experimental_hdr);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_monitor_manager_class_init (MetaMonitorManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->constructed = meta_monitor_manager_constructed;
+  object_class->dispose = meta_monitor_manager_dispose;
+  object_class->finalize = meta_monitor_manager_finalize;
+  object_class->get_property = meta_monitor_manager_get_property;
+  object_class->set_property = meta_monitor_manager_set_property;
+
+  klass->read_edid = meta_monitor_manager_real_read_edid;
+  klass->read_current_state = meta_monitor_manager_real_read_current_state;
+
+  signals[MONITORS_CHANGED] =
+    g_signal_new ("monitors-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[MONITORS_CHANGED_INTERNAL] =
+    g_signal_new ("monitors-changed-internal",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[POWER_SAVE_MODE_CHANGED] =
+    g_signal_new ("power-save-mode-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  META_TYPE_POWER_SAVE_CHANGE_REASON);
+
+  signals[CONFIRM_DISPLAY_CHANGE] =
+    g_signal_new ("confirm-display-change",
+		  G_TYPE_FROM_CLASS (object_class),
+		  G_SIGNAL_RUN_LAST,
+		  0,
+                  NULL, NULL, NULL,
+		  G_TYPE_NONE, 0);
+
+  /**
+   * MetaMonitorManager::monitor-privacy-screen-changed: (skip)
+   * @monitor_manager: The #MetaMonitorManager
+   * @logical_monitor: The #MetaLogicalMonitor where the privacy screen state
+   *                   changed
+   * @enabled: %TRUE if the privacy screen was enabled, otherwise %FALSE
+   */
+  signals[MONITOR_PRIVACY_SCREEN_CHANGED] =
+    g_signal_new ("monitor-privacy-screen-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 2, META_TYPE_LOGICAL_MONITOR, G_TYPE_BOOLEAN);
+
+  obj_props[PROP_BACKEND] =
+    g_param_spec_object ("backend", NULL, NULL,
+                         META_TYPE_BACKEND,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_PANEL_ORIENTATION_MANAGED] =
+    g_param_spec_boolean ("panel-orientation-managed", NULL, NULL,
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_EXPLICIT_NOTIFY |
+                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_HAS_BUILTIN_PANEL] =
+    g_param_spec_boolean ("has-builtin-panel", NULL, NULL,
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_EXPLICIT_NOTIFY |
+                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_NIGHT_LIGHT_SUPPORTED] =
+    g_param_spec_boolean ("night-light-supported", NULL, NULL,
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_EXPLICIT_NOTIFY |
+                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_EXPERIMENTAL_HDR] =
+    g_param_spec_string ("experimental-hdr", NULL, NULL,
+                         NULL,
+                         G_PARAM_READWRITE |
+                         G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class, PROP_LAST, obj_props);
+}
+
+gboolean
+meta_monitor_has_aspect_as_size (MetaMonitor *monitor)
+{
+  int width_mm;
+  int height_mm;
+
+  meta_monitor_get_physical_dimensions (monitor, &width_mm, &height_mm);
+
+  return (width_mm == 1600 && height_mm == 900) ||
+     (width_mm == 1600 && height_mm == 1000) ||
+     (width_mm == 160 && height_mm == 90) ||
+     (width_mm == 160 && height_mm == 100) ||
+     (width_mm == 16 && height_mm == 9) ||
+     (width_mm == 16 && height_mm == 10);
+}
+
+static const char *
+get_connector_type_name (MetaConnectorType connector_type)
+{
+  switch (connector_type)
+    {
+    case META_CONNECTOR_TYPE_Unknown: return "Unknown";
+    case META_CONNECTOR_TYPE_VGA: return "VGA";
+    case META_CONNECTOR_TYPE_DVII: return "DVII";
+    case META_CONNECTOR_TYPE_DVID: return "DVID";
+    case META_CONNECTOR_TYPE_DVIA: return "DVIA";
+    case META_CONNECTOR_TYPE_Composite: return "Composite";
+    case META_CONNECTOR_TYPE_SVIDEO: return "SVIDEO";
+    case META_CONNECTOR_TYPE_LVDS: return "LVDS";
+    case META_CONNECTOR_TYPE_Component: return "Component";
+    case META_CONNECTOR_TYPE_9PinDIN: return "9PinDIN";
+    case META_CONNECTOR_TYPE_DisplayPort: return "DisplayPort";
+    case META_CONNECTOR_TYPE_HDMIA: return "HDMIA";
+    case META_CONNECTOR_TYPE_HDMIB: return "HDMIB";
+    case META_CONNECTOR_TYPE_TV: return "TV";
+    case META_CONNECTOR_TYPE_eDP: return "eDP";
+    case META_CONNECTOR_TYPE_VIRTUAL: return "VIRTUAL";
+    case META_CONNECTOR_TYPE_DSI: return "DSI";
+    case META_CONNECTOR_TYPE_DPI: return "DPI";
+    case META_CONNECTOR_TYPE_WRITEBACK: return "WRITEBACK";
+    case META_CONNECTOR_TYPE_SPI: return "SPI";
+    case META_CONNECTOR_TYPE_USB: return "USB";
+    default: g_assert_not_reached ();
+    }
+  return NULL;
+}
+
+static GList *
+combine_gpu_lists (MetaMonitorManager    *manager,
+                   GList              * (*list_getter) (MetaGpu *gpu))
+{
+  GList *gpus;
+  GList *list = NULL;
+  GList *l;
+
+  gpus = meta_backend_get_gpus (manager->backend);
+  for (l = gpus; l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+
+      list = g_list_concat (list, g_list_copy (list_getter (gpu)));
+    }
+
+  return list;
+}
+
+static void
+emit_privacy_screen_change (MetaMonitorManager *manager)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaPrivacyScreenState privacy_screen_state;
+      gboolean enabled;
+
+      if (!meta_monitor_is_active (monitor))
+        continue;
+
+      privacy_screen_state = meta_monitor_get_privacy_screen_state (monitor);
+      if (privacy_screen_state == META_PRIVACY_SCREEN_UNAVAILABLE)
+        continue;
+
+      enabled = !!(privacy_screen_state & META_PRIVACY_SCREEN_ENABLED);
+
+      g_signal_emit (manager, signals[MONITOR_PRIVACY_SCREEN_CHANGED], 0,
+                     meta_monitor_get_logical_monitor (monitor), enabled);
+    }
+}
+
+void
+meta_monitor_manager_maybe_emit_privacy_screen_change (MetaMonitorManager *manager)
+{
+  MetaPrivacyScreenChangeState reason = manager->privacy_screen_change_state;
+
+  if (reason == META_PRIVACY_SCREEN_CHANGE_STATE_NONE ||
+      reason == META_PRIVACY_SCREEN_CHANGE_STATE_INIT)
+    return;
+
+  if (reason == META_PRIVACY_SCREEN_CHANGE_STATE_PENDING_HOTKEY)
+    emit_privacy_screen_change (manager);
+
+  if (reason != META_PRIVACY_SCREEN_CHANGE_STATE_PENDING_SETTING)
+    {
+      MetaSettings *settings = meta_backend_get_settings (manager->backend);
+
+      meta_settings_set_privacy_screen_enabled (settings,
+        get_global_privacy_screen_state (manager) ==
+        META_PRIVACY_SCREEN_ENABLED);
+    }
+
+  meta_dbus_display_config_emit_monitors_changed (manager->display_config);
+  manager->privacy_screen_change_state = META_PRIVACY_SCREEN_CHANGE_STATE_NONE;
+}
+
+static gboolean
+meta_monitor_manager_handle_get_resources (MetaDBusDisplayConfig *skeleton,
+                                           GDBusMethodInvocation *invocation,
+                                           MetaMonitorManager    *manager)
+{
+  MetaMonitorManagerClass *manager_class = META_MONITOR_MANAGER_GET_CLASS (manager);
+  GList *combined_modes;
+  GList *combined_outputs;
+  GList *combined_crtcs;
+  GVariantBuilder crtc_builder, output_builder, mode_builder;
+  GList *l;
+  unsigned int i, j;
+  int max_screen_width;
+  int max_screen_height;
+
+  combined_modes = combine_gpu_lists (manager, meta_gpu_get_modes);
+  combined_outputs = combine_gpu_lists (manager, meta_gpu_get_outputs);
+  combined_crtcs = combine_gpu_lists (manager, meta_gpu_get_crtcs);
+
+  g_variant_builder_init (&crtc_builder, G_VARIANT_TYPE ("a(uxiiiiiuaua{sv})"));
+  g_variant_builder_init (&output_builder, G_VARIANT_TYPE ("a(uxiausauaua{sv})"));
+  g_variant_builder_init (&mode_builder, G_VARIANT_TYPE ("a(uxuudu)"));
+
+  for (l = combined_crtcs, i = 0; l; l = l->next, i++)
+    {
+      MetaCrtc *crtc = l->data;
+      GVariantBuilder transforms;
+      const MetaCrtcConfig *crtc_config;
+
+      g_variant_builder_init (&transforms, G_VARIANT_TYPE ("au"));
+      for (j = 0; j <= META_MONITOR_TRANSFORM_FLIPPED_270; j++)
+        {
+          if (meta_crtc_get_all_transforms (crtc) & (1 << j))
+            g_variant_builder_add (&transforms, "u", j);
+        }
+
+      crtc_config = meta_crtc_get_config (crtc);
+      if (crtc_config)
+        {
+          int current_mode_index;
+
+          current_mode_index = g_list_index (combined_modes, crtc_config->mode);
+          g_variant_builder_add (&crtc_builder, "(uxiiiiiuaua{sv})",
+                                 i, /* ID */
+                                 (int64_t) meta_crtc_get_id (crtc),
+                                 (int) roundf (crtc_config->layout.origin.x),
+                                 (int) roundf (crtc_config->layout.origin.y),
+                                 (int) roundf (crtc_config->layout.size.width),
+                                 (int) roundf (crtc_config->layout.size.height),
+                                 current_mode_index,
+                                 (uint32_t) crtc_config->transform,
+                                 &transforms,
+                                 NULL /* properties */);
+        }
+      else
+        {
+          g_variant_builder_add (&crtc_builder, "(uxiiiiiuaua{sv})",
+                                 i, /* ID */
+                                 (int64_t) meta_crtc_get_id (crtc),
+                                 0,
+                                 0,
+                                 0,
+                                 0,
+                                 -1,
+                                 (uint32_t) META_MONITOR_TRANSFORM_NORMAL,
+                                 &transforms,
+                                 NULL /* properties */);
+        }
+    }
+
+  for (l = combined_outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaOutput *output = l->data;
+      const MetaOutputInfo *output_info = meta_output_get_info (output);
+      GVariantBuilder crtcs, modes, clones, properties;
+      GBytes *edid;
+      MetaCrtc *crtc;
+      int crtc_index;
+      int backlight;
+      int min_backlight_step;
+      gboolean is_primary;
+      gboolean is_presentation;
+      const char * connector_type_name;
+      gboolean is_underscanning;
+      gboolean supports_underscanning;
+      gboolean supports_color_transform;
+      const char *vendor;
+      const char *product;
+      const char *serial;
+
+      g_variant_builder_init (&crtcs, G_VARIANT_TYPE ("au"));
+      for (j = 0; j < output_info->n_possible_crtcs; j++)
+        {
+          MetaCrtc *possible_crtc = output_info->possible_crtcs[j];
+          unsigned possible_crtc_index;
+
+          possible_crtc_index = g_list_index (combined_crtcs, possible_crtc);
+          g_variant_builder_add (&crtcs, "u", possible_crtc_index);
+        }
+
+      g_variant_builder_init (&modes, G_VARIANT_TYPE ("au"));
+      for (j = 0; j < output_info->n_modes; j++)
+        {
+          unsigned mode_index;
+
+          mode_index = g_list_index (combined_modes, output_info->modes[j]);
+          g_variant_builder_add (&modes, "u", mode_index);
+        }
+
+      g_variant_builder_init (&clones, G_VARIANT_TYPE ("au"));
+      for (j = 0; j < output_info->n_possible_clones; j++)
+        {
+          unsigned int possible_clone_index;
+
+          possible_clone_index = g_list_index (combined_outputs,
+                                               output_info->possible_clones[j]);
+          g_variant_builder_add (&clones, "u", possible_clone_index);
+        }
+
+      backlight = meta_output_get_backlight (output);
+      min_backlight_step =
+        output_info->backlight_max - output_info->backlight_min
+        ? 100 / (output_info->backlight_max - output_info->backlight_min)
+        : -1;
+      is_primary = meta_output_is_primary (output);
+      is_presentation = meta_output_is_presentation (output);
+      is_underscanning = meta_output_is_underscanning (output);
+      connector_type_name = get_connector_type_name (output_info->connector_type);
+      supports_underscanning = output_info->supports_underscanning;
+      supports_color_transform = output_info->supports_color_transform;
+      vendor = output_info->vendor;
+      product = output_info->product;
+      serial = output_info->serial;
+
+      g_variant_builder_init (&properties, G_VARIANT_TYPE ("a{sv}"));
+      g_variant_builder_add (&properties, "{sv}", "vendor",
+                             g_variant_new_string (vendor ? vendor : "unknown"));
+      g_variant_builder_add (&properties, "{sv}", "product",
+                             g_variant_new_string (product ? product : "unknown"));
+      g_variant_builder_add (&properties, "{sv}", "serial",
+                             g_variant_new_string (serial ? serial : "unknown"));
+      g_variant_builder_add (&properties, "{sv}", "width-mm",
+                             g_variant_new_int32 (output_info->width_mm));
+      g_variant_builder_add (&properties, "{sv}", "height-mm",
+                             g_variant_new_int32 (output_info->height_mm));
+      g_variant_builder_add (&properties, "{sv}", "display-name",
+                             g_variant_new_string (output_info->name));
+      g_variant_builder_add (&properties, "{sv}", "backlight",
+                             g_variant_new_int32 (backlight));
+      g_variant_builder_add (&properties, "{sv}", "min-backlight-step",
+                             g_variant_new_int32 (min_backlight_step));
+      g_variant_builder_add (&properties, "{sv}", "primary",
+                             g_variant_new_boolean (is_primary));
+      g_variant_builder_add (&properties, "{sv}", "presentation",
+                             g_variant_new_boolean (is_presentation));
+      g_variant_builder_add (&properties, "{sv}", "connector-type",
+                             g_variant_new_string (connector_type_name));
+      g_variant_builder_add (&properties, "{sv}", "underscanning",
+                             g_variant_new_boolean (is_underscanning));
+      g_variant_builder_add (&properties, "{sv}", "supports-underscanning",
+                             g_variant_new_boolean (supports_underscanning));
+      g_variant_builder_add (&properties, "{sv}", "supports-color-transform",
+                             g_variant_new_boolean (supports_color_transform));
+
+      edid = manager_class->read_edid (manager, output);
+      if (edid)
+        {
+          g_variant_builder_add (&properties, "{sv}", "edid",
+                                 g_variant_new_from_bytes (G_VARIANT_TYPE ("ay"),
+                                                           edid, TRUE));
+          g_bytes_unref (edid);
+        }
+
+      if (output_info->tile_info.group_id)
+        {
+          GVariant *tile_variant;
+
+          tile_variant = g_variant_new ("(uuuuuuuu)",
+                                        output_info->tile_info.group_id,
+                                        output_info->tile_info.flags,
+                                        output_info->tile_info.max_h_tiles,
+                                        output_info->tile_info.max_v_tiles,
+                                        output_info->tile_info.loc_h_tile,
+                                        output_info->tile_info.loc_v_tile,
+                                        output_info->tile_info.tile_w,
+                                        output_info->tile_info.tile_h);
+          g_variant_builder_add (&properties, "{sv}", "tile", tile_variant);
+        }
+
+      crtc = meta_output_get_assigned_crtc (output);
+      crtc_index = crtc ? g_list_index (combined_crtcs, crtc) : -1;
+      g_variant_builder_add (&output_builder, "(uxiausauaua{sv})",
+                             i, /* ID */
+                             meta_output_get_id (output),
+                             crtc_index,
+                             &crtcs,
+                             meta_output_get_name (output),
+                             &modes,
+                             &clones,
+                             &properties);
+    }
+
+  for (l = combined_modes, i = 0; l; l = l->next, i++)
+    {
+      MetaCrtcMode *mode = l->data;
+      const MetaCrtcModeInfo *crtc_mode_info =
+        meta_crtc_mode_get_info (mode);
+
+      g_variant_builder_add (&mode_builder, "(uxuudu)",
+                             i, /* ID */
+                             (int64_t) meta_crtc_mode_get_id (mode),
+                             (uint32_t) crtc_mode_info->width,
+                             (uint32_t) crtc_mode_info->height,
+                             (double) crtc_mode_info->refresh_rate,
+                             (uint32_t) crtc_mode_info->flags);
+    }
+
+  if (!meta_monitor_manager_get_max_screen_size (manager,
+                                                 &max_screen_width,
+                                                 &max_screen_height))
+    {
+      /* No max screen size, just send something large */
+      max_screen_width = 65535;
+      max_screen_height = 65535;
+    }
+
+  meta_dbus_display_config_complete_get_resources (skeleton,
+                                                   invocation,
+                                                   manager->serial,
+                                                   g_variant_builder_end (&crtc_builder),
+                                                   g_variant_builder_end (&output_builder),
+                                                   g_variant_builder_end (&mode_builder),
+                                                   max_screen_width,
+                                                   max_screen_height);
+
+  g_list_free (combined_modes);
+  g_list_free (combined_outputs);
+  g_list_free (combined_crtcs);
+
+  return TRUE;
+}
+
+static void
+restore_previous_config (MetaMonitorManager *manager)
+{
+  MetaMonitorsConfig *previous_config;
+  GError *error = NULL;
+
+  previous_config =
+    meta_monitor_config_manager_pop_previous (manager->config_manager);
+
+  if (previous_config)
+    {
+      MetaMonitorsConfigMethod method;
+
+      if (manager->panel_orientation_managed)
+        {
+          g_autoptr (MetaMonitorsConfig) oriented_config = NULL;
+
+          oriented_config =
+            meta_monitor_config_manager_create_for_builtin_orientation (
+              manager->config_manager, previous_config);
+
+          if (oriented_config)
+            g_set_object (&previous_config, oriented_config);
+        }
+
+      method = META_MONITORS_CONFIG_METHOD_TEMPORARY;
+      if (meta_monitor_manager_apply_monitors_config (manager,
+                                                      previous_config,
+                                                      method,
+                                                      &error))
+        {
+          g_object_unref (previous_config);
+          return;
+        }
+      else
+        {
+          g_object_unref (previous_config);
+          g_warning ("Failed to restore previous configuration: %s",
+                     error->message);
+          g_error_free (error);
+        }
+    }
+
+  meta_monitor_manager_ensure_configured (manager);
+}
+
+int
+meta_monitor_manager_get_display_configuration_timeout (MetaMonitorManager *manager)
+{
+  return DEFAULT_DISPLAY_CONFIGURATION_TIMEOUT;
+}
+
+static gboolean
+save_config_timeout (gpointer user_data)
+{
+  MetaMonitorManager *manager = user_data;
+
+  restore_previous_config (manager);
+  manager->persistent_timeout_id = 0;
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+request_persistent_confirmation (MetaMonitorManager *manager)
+{
+  int timeout_s;
+
+  timeout_s = meta_monitor_manager_get_display_configuration_timeout (manager);
+  manager->persistent_timeout_id = g_timeout_add_seconds (timeout_s,
+                                                          save_config_timeout,
+                                                          manager);
+  g_source_set_name_by_id (manager->persistent_timeout_id,
+                           "[mutter] save_config_timeout");
+
+  g_signal_emit (manager, signals[CONFIRM_DISPLAY_CHANGE], 0);
+}
+
+#define META_DISPLAY_CONFIG_MODE_FLAGS_PREFERRED (1 << 0)
+#define META_DISPLAY_CONFIG_MODE_FLAGS_CURRENT (1 << 1)
+
+#define MODE_FORMAT "(siiddada{sv})"
+#define MODES_FORMAT "a" MODE_FORMAT
+#define MONITOR_SPEC_FORMAT "(ssss)"
+#define MONITOR_FORMAT "(" MONITOR_SPEC_FORMAT MODES_FORMAT "a{sv})"
+#define MONITORS_FORMAT "a" MONITOR_FORMAT
+
+#define LOGICAL_MONITOR_MONITORS_FORMAT "a" MONITOR_SPEC_FORMAT
+#define LOGICAL_MONITOR_FORMAT "(iidub" LOGICAL_MONITOR_MONITORS_FORMAT "a{sv})"
+#define LOGICAL_MONITORS_FORMAT "a" LOGICAL_MONITOR_FORMAT
+
+static gboolean
+meta_monitor_manager_handle_get_current_state (MetaDBusDisplayConfig *skeleton,
+                                               GDBusMethodInvocation *invocation,
+                                               MetaMonitorManager    *manager)
+{
+  MetaSettings *settings = meta_backend_get_settings (manager->backend);
+  GVariantBuilder monitors_builder;
+  GVariantBuilder logical_monitors_builder;
+  GVariantBuilder properties_builder;
+  GList *l;
+  int i;
+  MetaMonitorManagerCapability capabilities;
+  int ui_scaling_factor;
+  int max_screen_width, max_screen_height;
+
+  g_variant_builder_init (&monitors_builder,
+                          G_VARIANT_TYPE (MONITORS_FORMAT));
+  g_variant_builder_init (&logical_monitors_builder,
+                          G_VARIANT_TYPE (LOGICAL_MONITORS_FORMAT));
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorSpec *monitor_spec = meta_monitor_get_spec (monitor);
+      MetaMonitorMode *current_mode;
+      MetaMonitorMode *preferred_mode;
+      MetaPrivacyScreenState privacy_screen_state;
+      GVariantBuilder modes_builder;
+      GVariantBuilder monitor_properties_builder;
+      GList *k;
+      gboolean is_builtin;
+      const char *display_name;
+
+      current_mode = meta_monitor_get_current_mode (monitor);
+      preferred_mode = meta_monitor_get_preferred_mode (monitor);
+
+      g_variant_builder_init (&modes_builder, G_VARIANT_TYPE (MODES_FORMAT));
+      for (k = meta_monitor_get_modes (monitor); k; k = k->next)
+        {
+          MetaMonitorMode *monitor_mode = k->data;
+          GVariantBuilder supported_scales_builder;
+          const char *mode_id;
+          int mode_width, mode_height;
+          float refresh_rate;
+          float preferred_scale;
+          float *supported_scales;
+          int n_supported_scales;
+          GVariantBuilder mode_properties_builder;
+          MetaCrtcModeFlag mode_flags;
+
+          if (!meta_monitor_mode_should_be_advertised (monitor_mode))
+            continue;
+
+          mode_id = meta_monitor_mode_get_id (monitor_mode);
+          meta_monitor_mode_get_resolution (monitor_mode,
+                                            &mode_width, &mode_height);
+
+          refresh_rate = meta_monitor_mode_get_refresh_rate (monitor_mode);
+
+          preferred_scale =
+            meta_monitor_manager_calculate_monitor_mode_scale (manager,
+                                                               manager->layout_mode,
+                                                               monitor,
+                                                               monitor_mode);
+
+          g_variant_builder_init (&supported_scales_builder,
+                                  G_VARIANT_TYPE ("ad"));
+          supported_scales =
+            meta_monitor_manager_calculate_supported_scales (manager,
+                                                             manager->layout_mode,
+                                                             monitor,
+                                                             monitor_mode,
+                                                             &n_supported_scales);
+          for (i = 0; i < n_supported_scales; i++)
+            g_variant_builder_add (&supported_scales_builder, "d",
+                                   (double) supported_scales[i]);
+          g_free (supported_scales);
+
+          mode_flags = meta_monitor_mode_get_flags (monitor_mode);
+
+          g_variant_builder_init (&mode_properties_builder,
+                                  G_VARIANT_TYPE ("a{sv}"));
+          if (monitor_mode == current_mode)
+            g_variant_builder_add (&mode_properties_builder, "{sv}",
+                                   "is-current",
+                                   g_variant_new_boolean (TRUE));
+          if (monitor_mode == preferred_mode)
+            g_variant_builder_add (&mode_properties_builder, "{sv}",
+                                   "is-preferred",
+                                   g_variant_new_boolean (TRUE));
+          if (mode_flags & META_CRTC_MODE_FLAG_INTERLACE)
+            g_variant_builder_add (&mode_properties_builder, "{sv}",
+                                   "is-interlaced",
+                                   g_variant_new_boolean (TRUE));
+
+          g_variant_builder_add (&modes_builder, MODE_FORMAT,
+                                 mode_id,
+                                 mode_width,
+                                 mode_height,
+                                 refresh_rate,
+                                 (double) preferred_scale,
+                                 &supported_scales_builder,
+                                 &mode_properties_builder);
+        }
+
+      g_variant_builder_init (&monitor_properties_builder,
+                              G_VARIANT_TYPE ("a{sv}"));
+      if (meta_monitor_supports_underscanning (monitor))
+        {
+          gboolean is_underscanning = meta_monitor_is_underscanning (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-underscanning",
+                                 g_variant_new_boolean (is_underscanning));
+        }
+
+      if (meta_monitor_is_vrr_capable (monitor))
+        {
+          gboolean vrr_disallowed = meta_monitor_is_vrr_disallowed (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-vrr-allowed",
+                                 g_variant_new_boolean (!vrr_disallowed));
+        }
+
+      is_builtin = meta_monitor_is_laptop_panel (monitor);
+      g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                             "is-builtin",
+                             g_variant_new_boolean (is_builtin));
+
+      display_name = meta_monitor_get_display_name (monitor);
+      g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                             "display-name",
+                             g_variant_new_string (display_name));
+
+      privacy_screen_state = meta_monitor_get_privacy_screen_state (monitor);
+      if (privacy_screen_state != META_PRIVACY_SCREEN_UNAVAILABLE)
+        {
+          GVariant *state;
+
+          state = g_variant_new ("(bb)",
+            !!(privacy_screen_state & META_PRIVACY_SCREEN_ENABLED),
+            !!(privacy_screen_state & META_PRIVACY_SCREEN_LOCKED));
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "privacy-screen-state", state);
+        }
+
+      g_variant_builder_add (&monitors_builder, MONITOR_FORMAT,
+                             monitor_spec->connector,
+                             monitor_spec->vendor,
+                             monitor_spec->product,
+                             monitor_spec->serial,
+                             &modes_builder,
+                             &monitor_properties_builder);
+    }
+
+  for (l = manager->logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+      GVariantBuilder logical_monitor_monitors_builder;
+      GList *k;
+
+      g_variant_builder_init (&logical_monitor_monitors_builder,
+                              G_VARIANT_TYPE (LOGICAL_MONITOR_MONITORS_FORMAT));
+
+      for (k = logical_monitor->monitors; k; k = k->next)
+        {
+          MetaMonitor *monitor = k->data;
+          MetaMonitorSpec *monitor_spec = meta_monitor_get_spec (monitor);
+
+          g_variant_builder_add (&logical_monitor_monitors_builder,
+                                 MONITOR_SPEC_FORMAT,
+                                 monitor_spec->connector,
+                                 monitor_spec->vendor,
+                                 monitor_spec->product,
+                                 monitor_spec->serial);
+        }
+
+      g_variant_builder_add (&logical_monitors_builder,
+                             LOGICAL_MONITOR_FORMAT,
+                             logical_monitor->rect.x,
+                             logical_monitor->rect.y,
+                             (double) logical_monitor->scale,
+                             logical_monitor->transform,
+                             logical_monitor->is_primary,
+                             &logical_monitor_monitors_builder,
+                             NULL);
+    }
+
+  g_variant_builder_init (&properties_builder, G_VARIANT_TYPE ("a{sv}"));
+  capabilities = meta_monitor_manager_get_capabilities (manager);
+
+  g_variant_builder_add (&properties_builder, "{sv}",
+                         "layout-mode",
+                         g_variant_new_uint32 (manager->layout_mode));
+  if (capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE)
+    {
+      g_variant_builder_add (&properties_builder, "{sv}",
+                             "supports-changing-layout-mode",
+                             g_variant_new_boolean (TRUE));
+    }
+
+  if (capabilities & META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED)
+    {
+      g_variant_builder_add (&properties_builder, "{sv}",
+                             "global-scale-required",
+                             g_variant_new_boolean (TRUE));
+    }
+
+  ui_scaling_factor = meta_settings_get_ui_scaling_factor (settings);
+  g_variant_builder_add (&properties_builder, "{sv}",
+                         "legacy-ui-scaling-factor",
+                         g_variant_new_int32 (ui_scaling_factor));
+
+  if (meta_monitor_manager_get_max_screen_size (manager,
+                                                &max_screen_width,
+                                                &max_screen_height))
+    {
+      GVariantBuilder max_screen_size_builder;
+
+      g_variant_builder_init (&max_screen_size_builder,
+                              G_VARIANT_TYPE ("(ii)"));
+      g_variant_builder_add (&max_screen_size_builder, "i",
+                             max_screen_width);
+      g_variant_builder_add (&max_screen_size_builder, "i",
+                             max_screen_height);
+
+      g_variant_builder_add (&properties_builder, "{sv}",
+                             "max-screen-size",
+                             g_variant_builder_end (&max_screen_size_builder));
+    }
+
+  meta_dbus_display_config_complete_get_current_state (
+    skeleton,
+    invocation,
+    manager->serial,
+    g_variant_builder_end (&monitors_builder),
+    g_variant_builder_end (&logical_monitors_builder),
+    g_variant_builder_end (&properties_builder));
+
+  return TRUE;
+}
+
+#undef MODE_FORMAT
+#undef MODES_FORMAT
+#undef MONITOR_SPEC_FORMAT
+#undef MONITOR_FORMAT
+#undef MONITORS_FORMAT
+#undef LOGICAL_MONITOR_MONITORS_FORMAT
+#undef LOGICAL_MONITOR_FORMAT
+#undef LOGICAL_MONITORS_FORMAT
+
+gboolean
+meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
+                                         MetaLogicalMonitorLayoutMode layout_mode,
+                                         MetaMonitor                 *monitor,
+                                         MetaMonitorMode             *monitor_mode,
+                                         float                        scale)
+{
+  g_autofree float *supported_scales = NULL;
+  int n_supported_scales;
+  int i;
+
+  supported_scales =
+    meta_monitor_manager_calculate_supported_scales (manager,
+                                                     layout_mode,
+                                                     monitor,
+                                                     monitor_mode,
+                                                     &n_supported_scales);
+  for (i = 0; i < n_supported_scales; i++)
+    {
+      if (supported_scales[i] == scale)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+is_global_scale_matching_in_config (MetaMonitorsConfig *config,
+                                    float               scale)
+{
+  GList *l;
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+      if (!G_APPROX_VALUE (logical_monitor_config->scale, scale, FLT_EPSILON))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+meta_monitor_manager_is_scale_supported_for_config (MetaMonitorManager *manager,
+                                                    MetaMonitorsConfig *config,
+                                                    MetaMonitor        *monitor,
+                                                    MetaMonitorMode    *monitor_mode,
+                                                    float               scale)
+{
+  if (meta_monitor_manager_is_scale_supported (manager, config->layout_mode,
+                                               monitor, monitor_mode, scale))
+    {
+      if (meta_monitor_manager_get_capabilities (manager) &
+          META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED)
+        return is_global_scale_matching_in_config (config, scale);
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+meta_monitor_manager_is_config_applicable (MetaMonitorManager *manager,
+                                           MetaMonitorsConfig *config,
+                                           GError            **error)
+{
+  GList *l;
+
+  for (l = config->logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+      float scale = logical_monitor_config->scale;
+      GList *k;
+
+      for (k = logical_monitor_config->monitor_configs; k; k = k->next)
+        {
+          MetaMonitorConfig *monitor_config = k->data;
+          MetaMonitorSpec *monitor_spec = monitor_config->monitor_spec;
+          MetaMonitorModeSpec *mode_spec = monitor_config->mode_spec;
+          MetaMonitor *monitor;
+          MetaMonitorMode *monitor_mode;
+
+          monitor = meta_monitor_manager_get_monitor_from_spec (manager,
+                                                                monitor_spec);
+          if (!monitor)
+            {
+              g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "Specified monitor not found");
+              return FALSE;
+            }
+
+          monitor_mode = meta_monitor_get_mode_from_spec (monitor, mode_spec);
+          if (!monitor_mode)
+            {
+              g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "Specified monitor mode not available");
+              return FALSE;
+            }
+
+          if (!meta_monitor_manager_is_scale_supported_for_config (manager,
+                                                                   config,
+                                                                   monitor,
+                                                                   monitor_mode,
+                                                                   scale))
+            {
+              g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "Scale not supported by backend");
+              return FALSE;
+            }
+
+          if (meta_monitor_is_laptop_panel (monitor) &&
+              meta_backend_is_lid_closed (manager->backend))
+            {
+              g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "Refusing to activate a closed laptop panel");
+              return FALSE;
+            }
+        }
+    }
+
+  return TRUE;
+}
+
+static gboolean
+meta_monitor_manager_is_config_complete (MetaMonitorManager *manager,
+                                         MetaMonitorsConfig *config)
+{
+  MetaMonitorsConfigKey *current_state_key;
+  gboolean is_config_complete;
+
+  current_state_key =
+    meta_create_monitors_config_key_for_current_state (manager);
+  if (!current_state_key)
+    return FALSE;
+
+  is_config_complete = meta_monitors_config_key_equal (current_state_key,
+                                                       config->key);
+  meta_monitors_config_key_free (current_state_key);
+
+  if (!is_config_complete)
+    return FALSE;
+
+  return meta_monitor_manager_is_config_applicable (manager, config, NULL);
+}
+
+static MetaMonitor *
+find_monitor_from_connector (MetaMonitorManager *manager,
+                             char               *connector)
+{
+  GList *monitors;
+  GList *l;
+
+  if (!connector)
+    return NULL;
+
+  monitors = meta_monitor_manager_get_monitors (manager);
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaMonitorSpec *monitor_spec = meta_monitor_get_spec (monitor);
+
+      if (g_str_equal (connector, monitor_spec->connector))
+        return monitor;
+    }
+
+  return NULL;
+}
+
+#define MONITOR_CONFIG_FORMAT "(ssa{sv})"
+#define MONITOR_CONFIGS_FORMAT "a" MONITOR_CONFIG_FORMAT
+
+#define LOGICAL_MONITOR_CONFIG_FORMAT "(iidub" MONITOR_CONFIGS_FORMAT ")"
+
+static MetaMonitorConfig *
+create_monitor_config_from_variant (MetaMonitorManager *manager,
+                                    GVariant           *monitor_config_variant,
+                                    GError            **error)
+{
+
+  MetaMonitorConfig *monitor_config = NULL;
+  g_autofree char *connector = NULL;
+  g_autofree char *mode_id = NULL;
+  MetaMonitorMode *monitor_mode;
+  MetaMonitor *monitor;
+  MetaMonitorSpec *monitor_spec;
+  MetaMonitorModeSpec *monitor_mode_spec;
+  g_autoptr (GVariant) properties_variant = NULL;
+  gboolean enable_underscanning = FALSE;
+  gboolean set_underscanning = FALSE;
+  gboolean allow_vrr = TRUE;
+  gboolean set_allow_vrr = FALSE;
+
+  g_variant_get (monitor_config_variant, "(ss@a{sv})",
+                 &connector,
+                 &mode_id,
+                 &properties_variant);
+
+  monitor = find_monitor_from_connector (manager, connector);
+  if (!monitor)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Invalid connector '%s' specified", connector);
+      return NULL;
+    }
+
+  monitor_mode = meta_monitor_get_mode_from_id (monitor, mode_id);
+  if (!monitor_mode)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Invalid mode '%s' specified", mode_id);
+      return NULL;
+    }
+
+  set_underscanning =
+    g_variant_lookup (properties_variant, "underscanning", "b",
+                      &enable_underscanning);
+  if (set_underscanning)
+    {
+      if (enable_underscanning && !meta_monitor_supports_underscanning (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Underscanning requested but unsupported");
+          return NULL;
+        }
+    }
+
+  set_allow_vrr =
+    g_variant_lookup (properties_variant, "allow_vrr", "b",
+                      &allow_vrr);
+  if (set_allow_vrr)
+    {
+      if (allow_vrr && !meta_monitor_is_vrr_capable (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Variable refresh rate requested but unsupported");
+          return NULL;
+        }
+    }
+
+  monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
+
+  monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
+  *monitor_mode_spec = *meta_monitor_mode_get_spec (monitor_mode);
+
+  monitor_config = g_new0 (MetaMonitorConfig, 1);
+  *monitor_config = (MetaMonitorConfig) {
+    .monitor_spec = monitor_spec,
+    .mode_spec = monitor_mode_spec,
+    .enable_underscanning = enable_underscanning,
+    .disallow_vrr = !allow_vrr,
+  };
+
+  return monitor_config;
+}
+
+static gboolean
+find_monitor_mode_scale (MetaMonitorManager          *manager,
+                         MetaLogicalMonitorLayoutMode layout_mode,
+                         MetaMonitorConfig           *monitor_config,
+                         float                        scale,
+                         float                       *out_scale,
+                         GError                     **error)
+{
+  MetaMonitorSpec *monitor_spec;
+  MetaMonitor *monitor;
+  MetaMonitorModeSpec *monitor_mode_spec;
+  MetaMonitorMode *monitor_mode;
+  g_autofree float *supported_scales = NULL;
+  int n_supported_scales;
+  int i;
+
+  monitor_spec = monitor_config->monitor_spec;
+  monitor = meta_monitor_manager_get_monitor_from_spec (manager,
+                                                        monitor_spec);
+  if (!monitor)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitor not found");
+      return FALSE;
+    }
+
+  monitor_mode_spec = monitor_config->mode_spec;
+  monitor_mode = meta_monitor_get_mode_from_spec (monitor,
+                                                  monitor_mode_spec);
+  if (!monitor_mode)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Monitor mode not found");
+      return FALSE;
+    }
+
+  supported_scales =
+    meta_monitor_manager_calculate_supported_scales (manager, layout_mode,
+                                                     monitor, monitor_mode,
+                                                     &n_supported_scales);
+
+  for (i = 0; i < n_supported_scales; i++)
+    {
+      float supported_scale = supported_scales[i];
+
+      if (fabsf (supported_scale - scale) < FLT_EPSILON)
+        {
+          *out_scale = supported_scale;
+          return TRUE;
+        }
+    }
+
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+               "Scale %g not valid for resolution %dx%d",
+               scale,
+               monitor_mode_spec->width,
+               monitor_mode_spec->height);
+  return FALSE;
+}
+
+static gboolean
+derive_logical_monitor_size (MetaMonitorConfig           *monitor_config,
+                             int                         *out_width,
+                             int                         *out_height,
+                             float                        scale,
+                             MetaMonitorTransform         transform,
+                             MetaLogicalMonitorLayoutMode layout_mode,
+                             GError                     **error)
+{
+  int width, height;
+
+  if (meta_monitor_transform_is_rotated (transform))
+    {
+      width = monitor_config->mode_spec->height;
+      height = monitor_config->mode_spec->width;
+    }
+  else
+    {
+      width = monitor_config->mode_spec->width;
+      height = monitor_config->mode_spec->height;
+    }
+
+  switch (layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      width = roundf (width / scale);
+      height = roundf (height / scale);
+      break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      break;
+    }
+
+  *out_width = width;
+  *out_height = height;
+
+  return TRUE;
+}
+
+static MetaLogicalMonitorConfig *
+create_logical_monitor_config_from_variant (MetaMonitorManager          *manager,
+                                            GVariant                    *logical_monitor_config_variant,
+                                            MetaLogicalMonitorLayoutMode layout_mode,
+                                            GError                     **error)
+{
+  MetaLogicalMonitorConfig *logical_monitor_config;
+  int x, y, width, height;
+  double scale_d;
+  float scale;
+  MetaMonitorTransform transform;
+  gboolean is_primary;
+  GVariantIter *monitor_configs_iter;
+  GList *monitor_configs = NULL;
+  MetaMonitorConfig *monitor_config;
+
+  g_variant_get (logical_monitor_config_variant, LOGICAL_MONITOR_CONFIG_FORMAT,
+                 &x,
+                 &y,
+                 &scale_d,
+                 &transform,
+                 &is_primary,
+                 &monitor_configs_iter);
+  scale = (float) scale_d;
+
+  while (TRUE)
+    {
+      GVariant *monitor_config_variant =
+        g_variant_iter_next_value (monitor_configs_iter);
+      MetaMonitorConfig *monitor_config;
+
+      if (!monitor_config_variant)
+        break;
+
+      monitor_config =
+        create_monitor_config_from_variant (manager,
+                                            monitor_config_variant, error);
+      g_variant_unref (monitor_config_variant);
+
+      if (!monitor_config)
+        goto err;
+
+      if (!meta_verify_monitor_config (monitor_config, error))
+        {
+          meta_monitor_config_free (monitor_config);
+          goto err;
+        }
+
+      monitor_configs = g_list_append (monitor_configs, monitor_config);
+    }
+  g_variant_iter_free (monitor_configs_iter);
+
+  if (!monitor_configs)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Empty logical monitor");
+      goto err;
+    }
+
+  monitor_config = monitor_configs->data;
+  if (!find_monitor_mode_scale (manager,
+                                layout_mode,
+                                monitor_config,
+                                scale,
+                                &scale,
+                                error))
+    goto err;
+
+  if (!derive_logical_monitor_size (monitor_config, &width, &height,
+                                    scale, transform, layout_mode, error))
+    goto err;
+
+  logical_monitor_config = g_new0 (MetaLogicalMonitorConfig, 1);
+  *logical_monitor_config = (MetaLogicalMonitorConfig) {
+    .layout = {
+      .x = x,
+      .y = y,
+      .width = width,
+      .height = height
+    },
+    .transform = transform,
+    .scale = scale,
+    .is_primary = is_primary,
+    .monitor_configs = monitor_configs
+  };
+
+  if (!meta_verify_logical_monitor_config (logical_monitor_config,
+                                           layout_mode,
+                                           manager,
+                                           error))
+    {
+      meta_logical_monitor_config_free (logical_monitor_config);
+      return NULL;
+    }
+
+  return logical_monitor_config;
+
+err:
+  g_list_free_full (monitor_configs, (GDestroyNotify) meta_monitor_config_free);
+  return NULL;
+}
+
+static gboolean
+is_valid_layout_mode (MetaLogicalMonitorLayoutMode layout_mode)
+{
+  switch (layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+meta_monitor_manager_handle_apply_monitors_config (MetaDBusDisplayConfig *skeleton,
+                                                   GDBusMethodInvocation *invocation,
+                                                   guint                  serial,
+                                                   guint                  method,
+                                                   GVariant              *logical_monitor_configs_variant,
+                                                   GVariant              *properties_variant,
+                                                   MetaMonitorManager    *manager)
+{
+  MetaMonitorConfigStore *config_store;
+  const MetaMonitorConfigPolicy *policy;
+  MetaMonitorManagerCapability capabilities;
+  GVariant *layout_mode_variant = NULL;
+  MetaLogicalMonitorLayoutMode layout_mode;
+  GVariantIter logical_monitor_configs_iter;
+  MetaMonitorsConfig *config;
+  GList *logical_monitor_configs = NULL;
+  GError *error = NULL;
+
+  if (serial != manager->serial)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "The requested configuration is based on stale information");
+      return TRUE;
+    }
+
+  config_store =
+    meta_monitor_config_manager_get_store (manager->config_manager);
+  policy = meta_monitor_config_store_get_policy (config_store);
+
+  if (!policy->enable_dbus)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "Monitor configuration via D-Bus is disabled");
+      return TRUE;
+    }
+
+  capabilities = meta_monitor_manager_get_capabilities (manager);
+
+  if (properties_variant)
+    layout_mode_variant = g_variant_lookup_value (properties_variant,
+                                                  "layout-mode",
+                                                  G_VARIANT_TYPE ("u"));
+
+  if (layout_mode_variant &&
+      capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE)
+    {
+      g_variant_get (layout_mode_variant, "u", &layout_mode);
+    }
+  else if (!layout_mode_variant)
+    {
+      layout_mode =
+        meta_monitor_manager_get_default_layout_mode (manager);
+    }
+  else
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Can't set layout mode");
+      return TRUE;
+    }
+
+  if (!is_valid_layout_mode (layout_mode))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "Invalid layout mode specified");
+      return TRUE;
+    }
+
+  g_variant_iter_init (&logical_monitor_configs_iter,
+                       logical_monitor_configs_variant);
+  while (TRUE)
+    {
+      GVariant *logical_monitor_config_variant =
+        g_variant_iter_next_value (&logical_monitor_configs_iter);
+      MetaLogicalMonitorConfig *logical_monitor_config;
+
+      if (!logical_monitor_config_variant)
+        break;
+
+      logical_monitor_config =
+        create_logical_monitor_config_from_variant (manager,
+                                                    logical_monitor_config_variant,
+                                                    layout_mode,
+                                                    &error);
+      g_variant_unref (logical_monitor_config_variant);
+
+      if (!logical_monitor_config)
+        {
+          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                                 G_DBUS_ERROR_INVALID_ARGS,
+                                                 "%s", error->message);
+          g_error_free (error);
+          g_list_free_full (logical_monitor_configs,
+                            (GDestroyNotify) meta_logical_monitor_config_free);
+          return TRUE;
+        }
+
+      logical_monitor_configs = g_list_append (logical_monitor_configs,
+                                               logical_monitor_config);
+    }
+
+  config = meta_monitors_config_new (manager,
+                                     logical_monitor_configs,
+                                     layout_mode,
+                                     META_MONITORS_CONFIG_FLAG_NONE);
+  if (!meta_verify_monitors_config (config, manager, &error))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "%s", error->message);
+      g_error_free (error);
+      g_object_unref (config);
+      return TRUE;
+    }
+
+  if (!meta_monitor_manager_is_config_applicable (manager, config, &error))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "%s", error->message);
+      g_error_free (error);
+      g_object_unref (config);
+      return TRUE;
+    }
+
+  if (method != META_MONITORS_CONFIG_METHOD_VERIFY)
+    {
+      g_clear_handle_id (&manager->restore_config_id, g_source_remove);
+      g_clear_handle_id (&manager->persistent_timeout_id, g_source_remove);
+    }
+
+  if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                   config,
+                                                   method,
+                                                   &error))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "%s", error->message);
+      g_error_free (error);
+      g_object_unref (config);
+      return TRUE;
+    }
+
+  if (method == META_MONITORS_CONFIG_METHOD_PERSISTENT)
+    request_persistent_confirmation (manager);
+
+  meta_dbus_display_config_complete_apply_monitors_config (skeleton, invocation);
+
+  return TRUE;
+}
+
+#undef MONITOR_MODE_SPEC_FORMAT
+#undef MONITOR_CONFIG_FORMAT
+#undef MONITOR_CONFIGS_FORMAT
+#undef LOGICAL_MONITOR_CONFIG_FORMAT
+
+void
+meta_monitor_manager_confirm_configuration (MetaMonitorManager *manager,
+                                            gboolean            ok)
+{
+  if (!manager->persistent_timeout_id)
+    return;
+
+  g_clear_handle_id (&manager->restore_config_id, g_source_remove);
+  g_clear_handle_id (&manager->persistent_timeout_id, g_source_remove);
+
+  if (ok)
+    {
+      meta_monitor_config_manager_save_current (manager->config_manager);
+    }
+  else
+    {
+      manager->restore_config_id =
+        g_idle_add_once ((GSourceOnceFunc) restore_previous_config, manager);
+    }
+}
+
+static gboolean
+meta_monitor_manager_handle_change_backlight  (MetaDBusDisplayConfig *skeleton,
+                                               GDBusMethodInvocation *invocation,
+                                               guint                  serial,
+                                               guint                  output_index,
+                                               gint                   value,
+                                               MetaMonitorManager    *manager)
+{
+  GList *combined_outputs;
+  MetaOutput *output;
+  const MetaOutputInfo *output_info;
+  int new_backlight;
+
+  if (serial != manager->serial)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "The requested configuration is based on stale information");
+      return TRUE;
+    }
+
+  combined_outputs = combine_gpu_lists (manager, meta_gpu_get_outputs);
+
+  if (output_index >= g_list_length (combined_outputs))
+    {
+      g_list_free (combined_outputs);
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Invalid output id");
+      return TRUE;
+    }
+  output = g_list_nth_data (combined_outputs, output_index);
+  g_list_free (combined_outputs);
+
+  if (value < 0 || value > 100)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Invalid backlight value");
+      return TRUE;
+    }
+
+  output_info = meta_output_get_info (output);
+  if (meta_output_get_backlight (output) == -1 ||
+      (output_info->backlight_min == 0 &&
+       output_info->backlight_max == 0))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Output does not support changing backlight");
+      return TRUE;
+    }
+
+  META_MONITOR_MANAGER_GET_CLASS (manager)->change_backlight (manager, output, value);
+
+  new_backlight = meta_output_get_backlight (output);
+  meta_dbus_display_config_complete_change_backlight (skeleton,
+                                                      invocation,
+                                                      new_backlight);
+  return TRUE;
+}
+
+static gboolean
+meta_monitor_manager_handle_get_crtc_gamma  (MetaDBusDisplayConfig *skeleton,
+                                             GDBusMethodInvocation *invocation,
+                                             guint                  serial,
+                                             guint                  crtc_id,
+                                             MetaMonitorManager    *manager)
+{
+  GList *combined_crtcs;
+  MetaCrtc *crtc;
+  g_autoptr (MetaGammaLut) gamma_lut = NULL;
+  GBytes *red_bytes, *green_bytes, *blue_bytes;
+  GVariant *red_v, *green_v, *blue_v;
+
+  if (serial != manager->serial)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "The requested configuration is based on stale information");
+      return TRUE;
+    }
+
+  combined_crtcs = combine_gpu_lists (manager, meta_gpu_get_crtcs);
+  if (crtc_id >= g_list_length (combined_crtcs))
+    {
+      g_list_free (combined_crtcs);
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Invalid crtc id");
+      return TRUE;
+    }
+
+  crtc = g_list_nth_data (combined_crtcs, crtc_id);
+  g_list_free (combined_crtcs);
+
+  gamma_lut = meta_crtc_get_gamma_lut (crtc);
+
+  red_bytes = g_bytes_new_take (g_steal_pointer (&gamma_lut->red),
+                                gamma_lut->size * sizeof (unsigned short));
+  green_bytes = g_bytes_new_take (g_steal_pointer (&gamma_lut->green),
+                                  gamma_lut->size * sizeof (unsigned short));
+  blue_bytes = g_bytes_new_take (g_steal_pointer (&gamma_lut->blue),
+                                 gamma_lut->size * sizeof (unsigned short));
+
+  red_v = g_variant_new_from_bytes (G_VARIANT_TYPE ("aq"), red_bytes, TRUE);
+  green_v = g_variant_new_from_bytes (G_VARIANT_TYPE ("aq"), green_bytes, TRUE);
+  blue_v = g_variant_new_from_bytes (G_VARIANT_TYPE ("aq"), blue_bytes, TRUE);
+
+  meta_dbus_display_config_complete_get_crtc_gamma (skeleton, invocation,
+                                                    red_v, green_v, blue_v);
+
+  g_bytes_unref (red_bytes);
+  g_bytes_unref (green_bytes);
+  g_bytes_unref (blue_bytes);
+
+  return TRUE;
+}
+
+static gboolean
+meta_monitor_manager_handle_set_crtc_gamma  (MetaDBusDisplayConfig *skeleton,
+                                             GDBusMethodInvocation *invocation,
+                                             guint                  serial,
+                                             guint                  crtc_id,
+                                             GVariant              *red_v,
+                                             GVariant              *green_v,
+                                             GVariant              *blue_v,
+                                             MetaMonitorManager    *manager)
+{
+  GList *combined_crtcs;
+  MetaCrtc *crtc;
+  size_t dummy;
+  GBytes *red_bytes, *green_bytes, *blue_bytes;
+  MetaGammaLut lut;
+
+  if (serial != manager->serial)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "The requested configuration is based on stale information");
+      return TRUE;
+    }
+
+  combined_crtcs = combine_gpu_lists (manager, meta_gpu_get_crtcs);
+
+  if (crtc_id >= g_list_length (combined_crtcs))
+    {
+      g_list_free (combined_crtcs);
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Invalid crtc id");
+      return TRUE;
+    }
+
+  crtc = g_list_nth_data (combined_crtcs, crtc_id);
+  g_list_free (combined_crtcs);
+
+  red_bytes = g_variant_get_data_as_bytes (red_v);
+  green_bytes = g_variant_get_data_as_bytes (green_v);
+  blue_bytes = g_variant_get_data_as_bytes (blue_v);
+
+  lut.size = g_bytes_get_size (red_bytes) / sizeof (uint16_t);
+  lut.red = (uint16_t *) g_bytes_get_data (red_bytes, &dummy);
+  lut.green = (uint16_t *) g_bytes_get_data (green_bytes, &dummy);
+  lut.blue = (uint16_t *) g_bytes_get_data (blue_bytes, &dummy);
+
+  meta_crtc_set_gamma_lut (crtc, &lut);
+  meta_dbus_display_config_complete_set_crtc_gamma (skeleton, invocation);
+
+  g_bytes_unref (red_bytes);
+  g_bytes_unref (green_bytes);
+  g_bytes_unref (blue_bytes);
+
+  return TRUE;
+}
+
+static gboolean
+meta_monitor_manager_handle_set_output_ctm  (MetaDBusDisplayConfig *skeleton,
+                                             GDBusMethodInvocation *invocation,
+                                             guint                  serial,
+                                             guint                  output_id,
+                                             GVariant              *ctm_var,
+                                             MetaMonitorManager    *manager)
+{
+  MetaMonitorManagerClass *klass;
+  GList *combined_outputs;
+  MetaOutput *output;
+  MetaOutputCtm ctm;
+  int i;
+
+  if (serial != manager->serial)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "The requested configuration is based on stale information");
+      return TRUE;
+    }
+
+  combined_outputs = combine_gpu_lists (manager, meta_gpu_get_outputs);
+
+  if (output_id >= g_list_length (combined_outputs))
+    {
+      g_list_free (combined_outputs);
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Invalid output id");
+      return TRUE;
+    }
+
+  output = g_list_nth_data (combined_outputs, output_id);
+  g_list_free (combined_outputs);
+
+  if (g_variant_n_children (ctm_var) != 9)
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_INVALID_ARGS,
+                                             "Unexpected color transform matrix variant length");
+      return TRUE;
+    }
+
+  for (i = 0; i < 9; i++)
+    {
+      GVariant *tmp = g_variant_get_child_value (ctm_var, i);
+      ctm.matrix[i] = g_variant_get_uint64 (tmp);
+      g_variant_unref (tmp);
+    }
+
+  klass = META_MONITOR_MANAGER_GET_CLASS (manager);
+  if (klass->set_output_ctm)
+    klass->set_output_ctm (output, &ctm);
+  meta_dbus_display_config_complete_set_output_ctm (skeleton, invocation);
+
+  return TRUE;
+}
+
+static void
+monitor_manager_setup_dbus_config_handlers (MetaMonitorManager *manager)
+{
+  g_signal_connect_object (manager->display_config, "handle-get-resources",
+                           G_CALLBACK (meta_monitor_manager_handle_get_resources),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-change-backlight",
+                           G_CALLBACK (meta_monitor_manager_handle_change_backlight),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-get-crtc-gamma",
+                           G_CALLBACK (meta_monitor_manager_handle_get_crtc_gamma),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-set-crtc-gamma",
+                           G_CALLBACK (meta_monitor_manager_handle_set_crtc_gamma),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-get-current-state",
+                           G_CALLBACK (meta_monitor_manager_handle_get_current_state),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-apply-monitors-config",
+                           G_CALLBACK (meta_monitor_manager_handle_apply_monitors_config),
+                           manager, 0);
+  g_signal_connect_object (manager->display_config, "handle-set-output-ctm",
+                           G_CALLBACK (meta_monitor_manager_handle_set_output_ctm),
+                           manager, 0);
+}
+
+static void
+on_bus_acquired (GDBusConnection *connection,
+                 const char      *name,
+                 gpointer         user_data)
+{
+  MetaMonitorManager *manager = user_data;
+
+  g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (manager->display_config),
+                                    connection,
+                                    "/org/gnome/Mutter/DisplayConfig",
+                                    NULL);
+}
+
+static void
+on_name_acquired (GDBusConnection *connection,
+                  const char      *name,
+                  gpointer         user_data)
+{
+  meta_topic (META_DEBUG_DBUS, "Acquired name %s", name);
+}
+
+static void
+on_name_lost (GDBusConnection *connection,
+              const char      *name,
+              gpointer         user_data)
+{
+  meta_topic (META_DEBUG_DBUS, "Lost or failed to acquire name %s", name);
+}
+
+static void
+initialize_dbus_interface (MetaMonitorManager *manager)
+{
+  MetaContext *context = meta_backend_get_context (manager->backend);
+
+  manager->dbus_name_id =
+    g_bus_own_name (G_BUS_TYPE_SESSION,
+                    "org.gnome.Mutter.DisplayConfig",
+                    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT |
+                    (meta_context_is_replacing (context) ?
+                     G_BUS_NAME_OWNER_FLAGS_REPLACE :
+                     G_BUS_NAME_OWNER_FLAGS_NONE),
+                    on_bus_acquired,
+                    on_name_acquired,
+                    on_name_lost,
+                    g_object_ref (manager),
+                    g_object_unref);
+}
+
+/**
+ * meta_monitor_manager_get_num_logical_monitors:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns the number of `MetaLogicalMonitor`s (can be 0 in case of a
+ * headless setup).
+ *
+ * Returns: the total number of `MetaLogicalMonitor`s.
+ */
+int
+meta_monitor_manager_get_num_logical_monitors (MetaMonitorManager *manager)
+{
+  return g_list_length (manager->logical_monitors);
+}
+
+/**
+ * meta_monitor_manager_get_logical_monitors:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns the list of `MetaLogicalMonitor`s that is handled. See also
+ * meta_monitor_manager_get_num_logical_monitors() if you only need the size of
+ * the list.
+ *
+ * Returns: (transfer none) (nullable): the list of logical monitors.
+ */
+GList *
+meta_monitor_manager_get_logical_monitors (MetaMonitorManager *manager)
+{
+  return manager->logical_monitors;
+}
+
+MetaLogicalMonitor *
+meta_monitor_manager_get_logical_monitor_from_number (MetaMonitorManager *manager,
+                                                      int                 number)
+{
+  g_return_val_if_fail ((unsigned int) number < g_list_length (manager->logical_monitors), NULL);
+
+  return g_list_nth (manager->logical_monitors, number)->data;
+}
+
+MetaLogicalMonitor *
+meta_monitor_manager_get_primary_logical_monitor (MetaMonitorManager *manager)
+{
+  return manager->primary_logical_monitor;
+}
+
+static MetaMonitor *
+find_monitor (MetaMonitorManager *monitor_manager,
+              gboolean (*match_func) (MetaMonitor *monitor))
+{
+  GList *monitors;
+  GList *l;
+
+  monitors = meta_monitor_manager_get_monitors (monitor_manager);
+  for (l = monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+
+      if (match_func (monitor))
+        return monitor;
+    }
+
+  return NULL;
+}
+
+/**
+ * meta_monitor_manager_get_primary_monitor:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns the primary monitor. This can be %NULL (e.g. when running headless).
+ *
+ * Returns: (transfer none) (nullable): The primary #MetaMonitor, or %NULL if
+ *          none.
+ */
+MetaMonitor *
+meta_monitor_manager_get_primary_monitor (MetaMonitorManager *manager)
+{
+  return find_monitor (manager, meta_monitor_is_primary);
+}
+
+/**
+ * meta_monitor_manager_get_laptop_panel:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns the #MetaMonitor that represents the built-in laptop panel (if
+ * applicable).
+ *
+ * Returns: (transfer none) (nullable): The laptop panel, or %NULL if none.
+ */
+MetaMonitor *
+meta_monitor_manager_get_laptop_panel (MetaMonitorManager *manager)
+{
+  return find_monitor (manager, meta_monitor_is_laptop_panel);
+}
+
+MetaMonitor *
+meta_monitor_manager_get_monitor_from_connector (MetaMonitorManager *manager,
+                                                 const char         *connector)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+
+      if (g_str_equal (meta_monitor_get_connector (monitor),
+                       connector))
+        return monitor;
+    }
+
+  return NULL;
+}
+
+MetaMonitor *
+meta_monitor_manager_get_monitor_from_spec (MetaMonitorManager *manager,
+                                            MetaMonitorSpec    *monitor_spec)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+
+      if (meta_monitor_spec_equals (meta_monitor_get_spec (monitor),
+                                    monitor_spec))
+        return monitor;
+    }
+
+  return NULL;
+}
+
+/**
+ * meta_monitor_manager_get_logical_monitor_at:
+ * @manager: A #MetaMonitorManager object
+ * @x: The x-coordinate
+ * @y: The y-coordinate
+ *
+ * Finds the #MetaLogicalMonitor at the given @x and @y coordinates in the
+ * total layout.
+ *
+ * Returns: (transfer none) (nullable): The #MetaLogicalMonitor at the given
+ *          point, or %NULL if none.
+ */
+MetaLogicalMonitor *
+meta_monitor_manager_get_logical_monitor_at (MetaMonitorManager *manager,
+                                             float               x,
+                                             float               y)
+{
+  GList *l;
+
+  for (l = manager->logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+
+      if (META_POINT_IN_RECT (x, y, logical_monitor->rect))
+        return logical_monitor;
+    }
+
+  return NULL;
+}
+
+/**
+ * meta_monitor_manager_get_logical_monitor_from_rect:
+ * @manager: A #MetaMonitorManager object
+ * @rect: The rectangle
+ *
+ * Finds the #MetaLogicalMonitor which contains the center of the given @rect
+ * or which has the largest area in common with the given @rect in the total
+ * layout if the center is not on a monitor.
+ *
+ * Returns: (transfer none) (nullable): The #MetaLogicalMonitor which
+ *          corresponds the most to the given @rect, or %NULL if none.
+ */
+MetaLogicalMonitor *
+meta_monitor_manager_get_logical_monitor_from_rect (MetaMonitorManager *manager,
+                                                    MtkRectangle       *rect)
+{
+  MetaLogicalMonitor *best_logical_monitor;
+  int best_logical_monitor_area;
+  GList *l;
+  int center_x = rect->x + (rect->width / 2);
+  int center_y = rect->y + (rect->height / 2);
+
+  best_logical_monitor = NULL;
+  best_logical_monitor_area = 0;
+
+  for (l = manager->logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+      MtkRectangle intersection;
+      int intersection_area;
+
+      if (META_POINT_IN_RECT (center_x, center_y, logical_monitor->rect))
+        return logical_monitor;
+
+      if (!mtk_rectangle_intersect (&logical_monitor->rect,
+                                    rect,
+                                    &intersection))
+        continue;
+
+      intersection_area = mtk_rectangle_area (&intersection);
+
+      if (intersection_area > best_logical_monitor_area)
+        {
+          best_logical_monitor = logical_monitor;
+          best_logical_monitor_area = intersection_area;
+        }
+    }
+
+  if (!best_logical_monitor)
+    best_logical_monitor = manager->primary_logical_monitor;
+
+  return best_logical_monitor;
+}
+
+/**
+ * meta_monitor_manager_get_highest_scale_from_rect:
+ * @manager: A #MetaMonitorManager object
+ * @rect: The rectangle
+ *
+ * Finds the #MetaLogicalMonitor with the highest scale intersecting @rect.
+ *
+ * Returns: (transfer none) (nullable): the #MetaLogicalMonitor with the
+ *          highest scale intersecting with @rect, or %NULL if none.
+ */
+MetaLogicalMonitor *
+meta_monitor_manager_get_highest_scale_monitor_from_rect (MetaMonitorManager *manager,
+                                                          MtkRectangle       *rect)
+{
+  MetaLogicalMonitor *best_logical_monitor = NULL;
+  GList *l;
+  float best_scale = 0.0;
+
+  for (l = manager->logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+      MtkRectangle intersection;
+      float scale;
+
+      if (!mtk_rectangle_intersect (&logical_monitor->rect,
+                                    rect,
+                                    &intersection))
+        continue;
+
+      scale = meta_logical_monitor_get_scale (logical_monitor);
+
+      if (scale > best_scale)
+        {
+          best_scale = scale;
+          best_logical_monitor = logical_monitor;
+        }
+    }
+
+  return best_logical_monitor;
+}
+
+MetaLogicalMonitor *
+meta_monitor_manager_get_logical_monitor_neighbor (MetaMonitorManager  *manager,
+                                                   MetaLogicalMonitor  *logical_monitor,
+                                                   MetaDisplayDirection direction)
+{
+  GList *l;
+
+  for (l = manager->logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *other = l->data;
+
+      if (meta_logical_monitor_has_neighbor (logical_monitor, other, direction))
+        return other;
+    }
+
+  return NULL;
+}
+
+/**
+ * meta_monitor_manager_get_monitors:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns the list of [class@Meta.Monitor]s. See also
+ * meta_monitor_manager_get_logical_monitors() for a list of
+ * `MetaLogicalMonitor`s.
+ *
+ * Returns: (transfer none) (nullable): the list of [class@Meta.Monitor]s.
+ */
+GList *
+meta_monitor_manager_get_monitors (MetaMonitorManager *manager)
+{
+  return manager->monitors;
+}
+
+void
+meta_monitor_manager_get_screen_size (MetaMonitorManager *manager,
+                                      int                *width,
+                                      int                *height)
+{
+  *width = manager->screen_width;
+  *height = manager->screen_height;
+}
+
+MetaPowerSave
+meta_monitor_manager_get_power_save_mode (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  return priv->power_save_mode;
+}
+
+static void
+destroy_monitor (MetaMonitor *monitor)
+{
+  g_object_run_dispose (G_OBJECT (monitor));
+  g_object_unref (monitor);
+}
+
+static void
+rebuild_monitors (MetaMonitorManager *manager)
+{
+  GList *gpus;
+  GList *l;
+
+  if (manager->monitors)
+    {
+      g_list_free_full (manager->monitors, (GDestroyNotify) destroy_monitor);
+      manager->monitors = NULL;
+    }
+
+  gpus = meta_backend_get_gpus (manager->backend);
+  for (l = gpus; l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+      GList *k;
+
+      for (k = meta_gpu_get_outputs (gpu); k; k = k->next)
+        {
+          MetaOutput *output = k->data;
+          const MetaOutputInfo *output_info = meta_output_get_info (output);
+
+          if (output_info->tile_info.group_id)
+            {
+              if (is_main_tiled_monitor_output (output))
+                {
+                  MetaMonitorTiled *monitor_tiled;
+
+                  monitor_tiled = meta_monitor_tiled_new (manager, output);
+                  manager->monitors = g_list_append (manager->monitors,
+                                                     monitor_tiled);
+                }
+            }
+          else
+            {
+              MetaMonitorNormal *monitor_normal;
+
+              monitor_normal = meta_monitor_normal_new (manager, output);
+              manager->monitors = g_list_append (manager->monitors,
+                                                 monitor_normal);
+            }
+        }
+    }
+
+  for (l = meta_monitor_manager_get_virtual_monitors (manager); l; l = l->next)
+    {
+      MetaVirtualMonitor *virtual_monitor = l->data;
+      MetaOutput *output = meta_virtual_monitor_get_output (virtual_monitor);
+      MetaMonitorNormal *monitor_normal;
+
+      monitor_normal = meta_monitor_normal_new (manager, output);
+      manager->monitors = g_list_append (manager->monitors,
+                                         monitor_normal);
+
+    }
+
+  update_panel_orientation_managed (manager);
+  update_has_builtin_panel (manager);
+  update_night_light_supported (manager);
+}
+
+void
+meta_monitor_manager_tiled_monitor_added (MetaMonitorManager *manager,
+                                          MetaMonitor        *monitor)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  if (manager_class->tiled_monitor_added)
+    manager_class->tiled_monitor_added (manager, monitor);
+}
+
+void
+meta_monitor_manager_tiled_monitor_removed (MetaMonitorManager *manager,
+                                            MetaMonitor        *monitor)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  if (manager_class->tiled_monitor_removed)
+    manager_class->tiled_monitor_removed (manager, monitor);
+}
+
+gboolean
+meta_monitor_manager_is_transform_handled (MetaMonitorManager  *manager,
+                                           MetaCrtc            *crtc,
+                                           MetaMonitorTransform transform)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  return manager_class->is_transform_handled (manager, crtc, transform);
+}
+
+static void
+meta_monitor_manager_real_read_current_state (MetaMonitorManager *manager)
+{
+  GList *l;
+
+  manager->serial++;
+
+  for (l = meta_backend_get_gpus (manager->backend); l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+      GError *error = NULL;
+
+      if (!meta_gpu_read_current (gpu, &error))
+        {
+          g_warning ("Failed to read current monitor state: %s", error->message);
+          g_clear_error (&error);
+        }
+    }
+
+  rebuild_monitors (manager);
+}
+
+void
+meta_monitor_manager_read_current_state (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerClass *manager_class =
+    META_MONITOR_MANAGER_GET_CLASS (manager);
+
+  manager_class->read_current_state (manager);
+}
+
+static void
+meta_monitor_manager_notify_monitors_changed (MetaMonitorManager *manager)
+{
+  meta_backend_monitors_changed (manager->backend);
+
+  g_signal_emit (manager, signals[MONITORS_CHANGED_INTERNAL], 0);
+  g_signal_emit (manager, signals[MONITORS_CHANGED], 0);
+
+  meta_dbus_display_config_emit_monitors_changed (manager->display_config);
+}
+
+static void
+set_logical_monitor_modes (MetaMonitorManager       *manager,
+                           MetaLogicalMonitorConfig *logical_monitor_config)
+{
+  GList *l;
+
+  for (l = logical_monitor_config->monitor_configs; l; l = l->next)
+    {
+      MetaMonitorConfig *monitor_config = l->data;
+      MetaMonitorSpec *monitor_spec;
+      MetaMonitor *monitor;
+      MetaMonitorModeSpec *monitor_mode_spec;
+      MetaMonitorMode *monitor_mode;
+
+      monitor_spec = monitor_config->monitor_spec;
+      monitor = meta_monitor_manager_get_monitor_from_spec (manager,
+                                                            monitor_spec);
+      monitor_mode_spec = monitor_config->mode_spec;
+      monitor_mode = meta_monitor_get_mode_from_spec (monitor,
+                                                      monitor_mode_spec);
+
+      meta_monitor_set_current_mode (monitor, monitor_mode);
+    }
+}
+
+static void
+meta_monitor_manager_update_monitor_modes (MetaMonitorManager *manager,
+                                           MetaMonitorsConfig *config)
+{
+  GList *logical_monitor_configs;
+  GList *l;
+
+  g_list_foreach (manager->monitors,
+                  (GFunc) meta_monitor_set_current_mode,
+                  NULL);
+
+  logical_monitor_configs = config ? config->logical_monitor_configs : NULL;
+  for (l = logical_monitor_configs; l; l = l->next)
+    {
+      MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+      set_logical_monitor_modes (manager, logical_monitor_config);
+    }
+}
+
+void
+meta_monitor_manager_update_logical_state (MetaMonitorManager *manager,
+                                           MetaMonitorsConfig *config)
+{
+  if (config)
+    {
+      manager->layout_mode = config->layout_mode;
+      manager->current_switch_config =
+        meta_monitors_config_get_switch_config (config);
+    }
+  else
+    {
+      manager->layout_mode =
+        meta_monitor_manager_get_default_layout_mode (manager);
+      manager->current_switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
+    }
+
+  meta_monitor_manager_rebuild_logical_monitors (manager, config);
+}
+
+void
+meta_monitor_manager_rebuild (MetaMonitorManager *manager,
+                              MetaMonitorsConfig *config)
+{
+  GList *old_logical_monitors;
+
+  meta_monitor_manager_update_monitor_modes (manager, config);
+
+  if (manager->in_init)
+    return;
+
+  old_logical_monitors = manager->logical_monitors;
+
+  meta_monitor_manager_update_logical_state (manager, config);
+
+  meta_monitor_manager_notify_monitors_changed (manager);
+
+  ensure_privacy_screen_settings (manager);
+
+  ensure_hdr_settings (manager);
+
+  g_list_free_full (old_logical_monitors, g_object_unref);
+}
+
+static void
+meta_monitor_manager_update_monitor_modes_derived (MetaMonitorManager *manager)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+
+      meta_monitor_derive_current_mode (monitor);
+    }
+}
+
+void
+meta_monitor_manager_update_logical_state_derived (MetaMonitorManager *manager,
+                                                   MetaMonitorsConfig *config)
+{
+  if (config)
+    manager->current_switch_config =
+      meta_monitors_config_get_switch_config (config);
+  else
+    manager->current_switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
+
+  manager->layout_mode = META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+
+  meta_monitor_manager_rebuild_logical_monitors_derived (manager, config);
+}
+
+void
+meta_monitor_manager_rebuild_derived (MetaMonitorManager *manager,
+                                      MetaMonitorsConfig *config)
+{
+  GList *old_logical_monitors;
+
+  meta_monitor_manager_update_monitor_modes_derived (manager);
+
+  if (manager->in_init)
+    return;
+
+  old_logical_monitors = manager->logical_monitors;
+
+  meta_monitor_manager_update_logical_state_derived (manager, config);
+
+  meta_monitor_manager_notify_monitors_changed (manager);
+
+  g_list_free_full (old_logical_monitors, g_object_unref);
+}
+
+void
+meta_monitor_manager_reconfigure (MetaMonitorManager *manager)
+{
+  meta_monitor_manager_ensure_configured (manager);
+}
+
+void
+meta_monitor_manager_reload (MetaMonitorManager *manager)
+{
+  meta_monitor_manager_read_current_state (manager);
+  meta_monitor_manager_reconfigure (manager);
+}
+
+static gboolean
+calculate_viewport_matrix (MetaMonitorManager *manager,
+                           MetaLogicalMonitor *logical_monitor,
+                           gfloat              viewport[6])
+{
+  gfloat x, y, width, height;
+
+  x = (float) logical_monitor->rect.x / manager->screen_width;
+  y = (float) logical_monitor->rect.y / manager->screen_height;
+  width  = (float) logical_monitor->rect.width / manager->screen_width;
+  height = (float) logical_monitor->rect.height / manager->screen_height;
+
+  viewport[0] = width;
+  viewport[1] = 0.0f;
+  viewport[2] = x;
+  viewport[3] = 0.0f;
+  viewport[4] = height;
+  viewport[5] = y;
+
+  return TRUE;
+}
+
+static inline void
+multiply_matrix (float a[6],
+		 float b[6],
+		 float res[6])
+{
+  res[0] = a[0] * b[0] + a[1] * b[3];
+  res[1] = a[0] * b[1] + a[1] * b[4];
+  res[2] = a[0] * b[2] + a[1] * b[5] + a[2];
+  res[3] = a[3] * b[0] + a[4] * b[3];
+  res[4] = a[3] * b[1] + a[4] * b[4];
+  res[5] = a[3] * b[2] + a[4] * b[5] + a[5];
+}
+
+gboolean
+meta_monitor_manager_get_monitor_matrix (MetaMonitorManager *manager,
+                                         MetaMonitor        *monitor,
+                                         MetaLogicalMonitor *logical_monitor,
+                                         gfloat              matrix[6])
+{
+  MetaMonitorTransform transform;
+  gfloat viewport[9];
+
+  if (!calculate_viewport_matrix (manager, logical_monitor, viewport))
+    return FALSE;
+
+  /* Get transform corrected for LCD panel-orientation. */
+  transform = logical_monitor->transform;
+  transform = meta_monitor_logical_to_crtc_transform (monitor, transform);
+  multiply_matrix (viewport, transform_matrices[transform],
+                   matrix);
+  return TRUE;
+}
+
+/**
+ * meta_monitor_manager_get_monitor_for_connector:
+ * @manager: A #MetaMonitorManager
+ * @connector: A valid connector name
+ *
+ * Returns: The monitor index or -1 if @id isn't valid or the connector
+ * isn't associated with a logical monitor.
+ */
+gint
+meta_monitor_manager_get_monitor_for_connector (MetaMonitorManager *manager,
+                                                const char         *connector)
+{
+  GList *l;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+
+      if (meta_monitor_is_active (monitor) &&
+          g_str_equal (connector, meta_monitor_get_connector (monitor)))
+        return meta_monitor_get_logical_monitor (monitor)->number;
+    }
+
+  return -1;
+}
+
+/**
+ * meta_monitor_manager_get_is_builtin_display_on:
+ * @manager: A #MetaMonitorManager object
+ *
+ * Returns whether the built-in display (i.e. a laptop panel) is turned on.
+ */
+gboolean
+meta_monitor_manager_get_is_builtin_display_on (MetaMonitorManager *manager)
+{
+  MetaMonitor *laptop_panel;
+
+  g_return_val_if_fail (META_IS_MONITOR_MANAGER (manager), FALSE);
+
+  laptop_panel = meta_monitor_manager_get_laptop_panel (manager);
+  if (!laptop_panel)
+    return FALSE;
+
+  return meta_monitor_is_active (laptop_panel);
+}
+
+void
+meta_monitor_manager_rotate_monitor (MetaMonitorManager *manager)
+{
+  GError *error = NULL;
+  MetaMonitorsConfig *config =
+    meta_monitor_config_manager_create_for_rotate_monitor (manager->config_manager);
+
+  if (!config)
+    return;
+
+  if (!meta_monitor_manager_apply_monitors_config (manager,
+                                                   config,
+                                                   META_MONITORS_CONFIG_METHOD_TEMPORARY,
+                                                   &error))
+    {
+      g_warning ("Failed to use rotate monitor configuration: %s",
+                 error->message);
+      g_error_free (error);
+    }
+  g_object_unref (config);
+}
+
+typedef struct
+{
+  MetaMonitorManager *monitor_manager;
+  MetaMonitorSwitchConfigType config_type;
+} SwitchConfigData;
+
+static gboolean
+switch_config_idle_cb (gpointer user_data)
+{
+  SwitchConfigData *data = user_data;
+  MetaMonitorManager *monitor_manager = data->monitor_manager;
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (monitor_manager);
+  MetaMonitorConfigManager *config_manager = monitor_manager->config_manager;
+  MetaMonitorsConfig *config;
+  g_autoptr (GError) error = NULL;
+
+  priv->switch_config_handle_id = 0;
+
+  config =
+    meta_monitor_config_manager_create_for_switch_config (config_manager,
+                                                          data->config_type);
+  if (!config)
+    return G_SOURCE_REMOVE;
+
+  if (!meta_monitor_manager_apply_monitors_config (monitor_manager,
+                                                   config,
+                                                   META_MONITORS_CONFIG_METHOD_TEMPORARY,
+                                                   &error))
+    {
+      g_warning ("Failed to use switch monitor configuration: %s",
+                 error->message);
+    }
+  else
+    {
+      monitor_manager->current_switch_config = data->config_type;
+    }
+
+  return G_SOURCE_REMOVE;
+}
+
+void
+meta_monitor_manager_switch_config (MetaMonitorManager          *manager,
+                                    MetaMonitorSwitchConfigType  config_type)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  SwitchConfigData *data;
+
+  g_return_if_fail (config_type != META_MONITOR_SWITCH_CONFIG_UNKNOWN);
+
+  data = g_new0 (SwitchConfigData, 1);
+  data->monitor_manager = manager;
+  data->config_type = config_type;
+
+  g_clear_handle_id (&priv->switch_config_handle_id, g_source_remove);
+  priv->switch_config_handle_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
+                                                   switch_config_idle_cb,
+                                                   data,
+                                                   g_free);
+}
+
+gboolean
+meta_monitor_manager_can_switch_config (MetaMonitorManager *manager)
+{
+  return (!meta_backend_is_lid_closed (manager->backend) &&
+          g_list_length (manager->monitors) > 1);
+}
+
+MetaMonitorSwitchConfigType
+meta_monitor_manager_get_switch_config (MetaMonitorManager *manager)
+{
+  return manager->current_switch_config;
+}
+
+MetaMonitorConfigManager *
+meta_monitor_manager_get_config_manager (MetaMonitorManager *manager)
+{
+  return manager->config_manager;
+}
+
+gboolean
+meta_monitor_manager_get_panel_orientation_managed (MetaMonitorManager *manager)
+{
+  g_return_val_if_fail (META_IS_MONITOR_MANAGER (manager), FALSE);
+
+  return manager->panel_orientation_managed;
+}
+
+void
+meta_monitor_manager_post_init (MetaMonitorManager *manager)
+{
+  ClutterBackend *clutter_backend;
+  ClutterSeat *seat;
+
+  if (manager->privacy_screen_change_state ==
+      META_PRIVACY_SCREEN_CHANGE_STATE_INIT)
+    {
+      manager->privacy_screen_change_state =
+        META_PRIVACY_SCREEN_CHANGE_STATE_NONE;
+    }
+
+  apply_privacy_screen_settings (manager);
+
+  clutter_backend = meta_backend_get_clutter_backend (manager->backend);
+  seat = clutter_backend_get_default_seat (clutter_backend);
+
+  g_signal_connect_object (seat, "notify::touch-mode",
+                           G_CALLBACK (update_panel_orientation_managed), manager,
+                           G_CONNECT_SWAPPED);
+}
+
+MetaViewportInfo *
+meta_monitor_manager_get_viewports (MetaMonitorManager *manager)
+{
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaViewportInfo *info;
+  GArray *views, *scales;
+  GList *logical_monitors, *l;
+
+  views = g_array_new (FALSE, FALSE, sizeof (MtkRectangle));
+  scales = g_array_new (FALSE, FALSE, sizeof (float));
+
+  logical_monitors = meta_monitor_manager_get_logical_monitors (manager);
+
+  for (l = logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+      MtkRectangle rect;
+      float scale;
+
+      rect = logical_monitor->rect;
+      g_array_append_val (views, rect);
+
+      scale = logical_monitor->scale;
+      g_array_append_val (scales, scale);
+    }
+
+  info = meta_viewport_info_new ((MtkRectangle *) views->data,
+                                 (float *) scales->data,
+                                 views->len,
+                                 meta_backend_is_stage_views_scaled (backend));
+  g_array_unref (views);
+  g_array_unref (scales);
+
+  return info;
+}
+
+GList *
+meta_monitor_manager_get_virtual_monitors (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+
+  return priv->virtual_monitors;
+}
diff '--color=auto' -uraN a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
--- a/src/backends/meta-monitor.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor.c	2023-10-12 20:59:22.710501037 +0300
@@ -371,6 +371,25 @@
 }
 
 gboolean
+meta_monitor_is_vrr_capable (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_monitor_is_vrr_disallowed (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_vrr_disallowed (output);
+}
+
+gboolean
 meta_monitor_get_max_bpc (MetaMonitor  *monitor,
                           unsigned int *max_bpc)
 {
@@ -1984,7 +2003,6 @@
   i = 0;
   found_one = FALSE;
   base_scaled_w = floorf (width / scale);
-
   do
     {
       for (j = 0; j < 2; j++)
diff '--color=auto' -uraN a/src/backends/meta-monitor.c.orig b/src/backends/meta-monitor.c.orig
--- a/src/backends/meta-monitor.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-monitor.c.orig	2023-10-12 20:59:22.673833913 +0300
@@ -0,0 +1,2352 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2016 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/meta-monitor.h"
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-crtc.h"
+#include "backends/meta-gpu.h"
+#include "backends/meta-monitor-manager-private.h"
+#include "backends/meta-settings-private.h"
+#include "backends/meta-output.h"
+#include "core/boxes-private.h"
+
+#define SCALE_FACTORS_PER_INTEGER 4
+#define SCALE_FACTORS_STEPS (1.0 / (float) SCALE_FACTORS_PER_INTEGER)
+#define MINIMUM_SCALE_FACTOR 1.0f
+#define MAXIMUM_SCALE_FACTOR 4.0f
+#define MINIMUM_LOGICAL_AREA (800 * 480)
+#define MAXIMUM_REFRESH_RATE_DIFF 0.001
+
+typedef struct _MetaMonitorMode
+{
+  MetaMonitor *monitor;
+  char *id;
+  MetaMonitorModeSpec spec;
+  MetaMonitorCrtcMode *crtc_modes;
+} MetaMonitorMode;
+
+typedef struct _MetaMonitorModeTiled
+{
+  MetaMonitorMode parent;
+
+  gboolean is_tiled;
+} MetaMonitorModeTiled;
+
+typedef struct _MetaMonitorPrivate
+{
+  MetaBackend *backend;
+
+  GList *outputs;
+  GList *modes;
+  GHashTable *mode_ids;
+
+  MetaMonitorMode *preferred_mode;
+  MetaMonitorMode *current_mode;
+
+  MetaMonitorSpec *spec;
+
+  MetaLogicalMonitor *logical_monitor;
+
+  /*
+   * The primary or first output for this monitor, 0 if we can't figure out.
+   * It can be matched to a winsys_id of a MetaOutput.
+   *
+   * This is used as an opaque token on reconfiguration when switching from
+   * clone to extended, to decide on what output the windows should go next
+   * (it's an attempt to keep windows on the same monitor, and preferably on
+   * the primary one).
+   */
+  uint64_t winsys_id;
+
+  char *display_name;
+} MetaMonitorPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaMonitor, meta_monitor, G_TYPE_OBJECT)
+
+struct _MetaMonitorNormal
+{
+  MetaMonitor parent;
+};
+
+G_DEFINE_TYPE (MetaMonitorNormal, meta_monitor_normal, META_TYPE_MONITOR)
+
+struct _MetaMonitorTiled
+{
+  MetaMonitor parent;
+
+  MetaMonitorManager *monitor_manager;
+
+  uint32_t tile_group_id;
+
+  /* The tile (0, 0) output. */
+  MetaOutput *origin_output;
+
+  /* The output enabled even when a non-tiled mode is used. */
+  MetaOutput *main_output;
+};
+
+G_DEFINE_TYPE (MetaMonitorTiled, meta_monitor_tiled, META_TYPE_MONITOR)
+
+static void
+meta_monitor_mode_free (MetaMonitorMode *mode);
+
+MetaMonitorSpec *
+meta_monitor_spec_clone (MetaMonitorSpec *monitor_spec)
+{
+  MetaMonitorSpec *new_monitor_spec;
+
+  new_monitor_spec = g_new0 (MetaMonitorSpec, 1);
+  *new_monitor_spec = (MetaMonitorSpec) {
+    .connector = g_strdup (monitor_spec->connector),
+    .vendor = g_strdup (monitor_spec->vendor),
+    .product = g_strdup (monitor_spec->product),
+    .serial = g_strdup (monitor_spec->serial),
+  };
+
+  return new_monitor_spec;
+}
+
+guint
+meta_monitor_spec_hash (gconstpointer key)
+{
+  const MetaMonitorSpec *monitor_spec = key;
+
+  return (g_str_hash (monitor_spec->connector) +
+          g_str_hash (monitor_spec->vendor) +
+          g_str_hash (monitor_spec->product) +
+          g_str_hash (monitor_spec->serial));
+}
+
+gboolean
+meta_monitor_spec_equals (MetaMonitorSpec *monitor_spec,
+                          MetaMonitorSpec *other_monitor_spec)
+{
+  return (g_str_equal (monitor_spec->connector, other_monitor_spec->connector) &&
+          g_str_equal (monitor_spec->vendor, other_monitor_spec->vendor) &&
+          g_str_equal (monitor_spec->product, other_monitor_spec->product) &&
+          g_str_equal (monitor_spec->serial, other_monitor_spec->serial));
+}
+
+int
+meta_monitor_spec_compare (MetaMonitorSpec *monitor_spec_a,
+                           MetaMonitorSpec *monitor_spec_b)
+{
+  int ret;
+
+  ret = strcmp (monitor_spec_a->connector, monitor_spec_b->connector);
+  if (ret != 0)
+    return ret;
+
+  ret = strcmp (monitor_spec_a->vendor, monitor_spec_b->vendor);
+  if (ret != 0)
+    return ret;
+
+  ret = strcmp (monitor_spec_a->product, monitor_spec_b->product);
+  if (ret != 0)
+    return ret;
+
+  return strcmp (monitor_spec_a->serial, monitor_spec_b->serial);
+}
+
+void
+meta_monitor_spec_free (MetaMonitorSpec *monitor_spec)
+{
+  g_free (monitor_spec->connector);
+  g_free (monitor_spec->vendor);
+  g_free (monitor_spec->product);
+  g_free (monitor_spec->serial);
+  g_free (monitor_spec);
+}
+
+static const MetaOutputInfo *
+meta_monitor_get_main_output_info (MetaMonitor *monitor)
+{
+  MetaOutput *output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_get_info (output);
+}
+
+static void
+meta_monitor_generate_spec (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+  MetaMonitorSpec *monitor_spec;
+  const char *vendor;
+  const char *product;
+  const char *serial;
+
+  vendor = output_info->vendor;
+  product = output_info->product;
+  serial = output_info->serial;
+
+  monitor_spec = g_new0 (MetaMonitorSpec, 1);
+  *monitor_spec = (MetaMonitorSpec) {
+    .connector = g_strdup (output_info->name),
+    .vendor = g_strdup (vendor ? vendor : "unknown"),
+    .product = g_strdup (product ? product : "unknown"),
+    .serial = g_strdup (serial ? serial : "unknown"),
+  };
+
+  priv->spec = monitor_spec;
+}
+
+static const double known_diagonals[] = {
+    12.1,
+    13.3,
+    15.6
+};
+
+static char *
+diagonal_to_str (double d)
+{
+  unsigned int i;
+
+  for (i = 0; i < G_N_ELEMENTS (known_diagonals); i++)
+    {
+      double delta;
+
+      delta = fabs(known_diagonals[i] - d);
+      if (delta < 0.1)
+        return g_strdup_printf ("%0.1lf\"", known_diagonals[i]);
+    }
+
+  return g_strdup_printf ("%d\"", (int) (d + 0.5));
+}
+
+static char *
+meta_monitor_make_display_name (MetaMonitor *monitor)
+{
+  MetaBackend *backend = meta_monitor_get_backend (monitor);
+  g_autofree char *inches = NULL;
+  g_autofree char *vendor_name = NULL;
+  const char *vendor = NULL;
+  const char *product_name = NULL;
+  int width_mm;
+  int height_mm;
+
+  meta_monitor_get_physical_dimensions (monitor, &width_mm, &height_mm);
+
+  if (meta_monitor_is_laptop_panel (monitor))
+      return g_strdup (_("Built-in display"));
+
+  if (width_mm > 0 && height_mm > 0)
+    {
+      if (!meta_monitor_has_aspect_as_size (monitor))
+        {
+          double d = sqrt (width_mm * width_mm +
+                           height_mm * height_mm);
+          inches = diagonal_to_str (d / 25.4);
+        }
+      else
+        {
+          product_name = meta_monitor_get_product (monitor);
+        }
+    }
+
+  vendor = meta_monitor_get_vendor (monitor);
+  if (vendor)
+    {
+      vendor_name = meta_backend_get_vendor_name (backend, vendor);
+
+      if (!vendor_name)
+        vendor_name = g_strdup (vendor);
+    }
+  else
+    {
+      if (inches != NULL)
+        vendor_name = g_strdup (_("Unknown"));
+      else
+        vendor_name = g_strdup (_("Unknown Display"));
+    }
+
+  if (inches != NULL)
+    {
+       /**/
+      return g_strdup_printf (C_("This is a monitor vendor name, followed by a "
+                                 "size in inches, like 'Dell 15\"'",
+                                 "%s %s"),
+                              vendor_name, inches);
+    }
+  else if (product_name != NULL)
+    {
+      return g_strdup_printf (C_("This is a monitor vendor name followed by "
+                                 "product/model name where size in inches "
+                                 "could not be calculated, e.g. Dell U2414H",
+                                 "%s %s"),
+                              vendor_name, product_name);
+    }
+  else
+    {
+      return g_strdup (vendor_name);
+    }
+}
+
+MetaBackend *
+meta_monitor_get_backend (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->backend;
+}
+
+GList *
+meta_monitor_get_outputs (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->outputs;
+}
+
+MetaOutput *
+meta_monitor_get_main_output (MetaMonitor *monitor)
+{
+  return META_MONITOR_GET_CLASS (monitor)->get_main_output (monitor);
+}
+
+gboolean
+meta_monitor_is_active (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return !!priv->current_mode;
+}
+
+gboolean
+meta_monitor_is_primary (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_primary (output);
+}
+
+gboolean
+meta_monitor_supports_underscanning (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->supports_underscanning;
+}
+
+gboolean
+meta_monitor_supports_color_transform (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->supports_color_transform;
+}
+
+gboolean
+meta_monitor_is_underscanning (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_underscanning (output);
+}
+
+gboolean
+meta_monitor_is_vrr_capable (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_monitor_is_vrr_disallowed (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_vrr_disallowed (output);
+}
+
+gboolean
+meta_monitor_get_max_bpc (MetaMonitor  *monitor,
+                          unsigned int *max_bpc)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_get_max_bpc (output, max_bpc);
+}
+
+gboolean
+meta_monitor_is_laptop_panel (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  switch (output_info->connector_type)
+    {
+    case META_CONNECTOR_TYPE_eDP:
+    case META_CONNECTOR_TYPE_LVDS:
+    case META_CONNECTOR_TYPE_DSI:
+      return TRUE;
+    default:
+      return FALSE;
+    }
+}
+
+gboolean
+meta_monitor_is_virtual (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->is_virtual;
+}
+
+gboolean
+meta_monitor_is_same_as (MetaMonitor *monitor,
+                         MetaMonitor *other_monitor)
+{
+  const MetaMonitorSpec *spec = meta_monitor_get_spec (monitor);
+  const MetaMonitorSpec *other_spec = meta_monitor_get_spec (other_monitor);
+
+  if ((g_strcmp0 (spec->vendor, "unknown") == 0 ||
+       g_strcmp0 (spec->product, "unknown") == 0 ||
+       g_strcmp0 (spec->serial, "unknown") == 0) &&
+      (g_strcmp0 (other_spec->vendor, "unknown") == 0 ||
+       g_strcmp0 (other_spec->product, "unknown") == 0 ||
+       g_strcmp0 (other_spec->serial, "unknown") == 0))
+    {
+      MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+      MetaMonitorPrivate *other_priv =
+        meta_monitor_get_instance_private (other_monitor);
+
+      return priv->winsys_id == other_priv->winsys_id;
+    }
+
+  if (g_strcmp0 (spec->vendor, other_spec->vendor) != 0)
+    return FALSE;
+
+  if (g_strcmp0 (spec->product, other_spec->product) != 0)
+    return FALSE;
+
+  if (g_strcmp0 (spec->serial, other_spec->serial) != 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+void
+meta_monitor_get_current_resolution (MetaMonitor *monitor,
+                                     int         *width,
+                                     int         *height)
+{
+  MetaMonitorMode *mode = meta_monitor_get_current_mode (monitor);
+
+  *width = mode->spec.width;
+  *height = mode->spec.height;
+}
+
+void
+meta_monitor_derive_layout (MetaMonitor  *monitor,
+                            MtkRectangle *layout)
+{
+  META_MONITOR_GET_CLASS (monitor)->derive_layout (monitor, layout);
+}
+
+void
+meta_monitor_get_physical_dimensions (MetaMonitor *monitor,
+                                      int         *width_mm,
+                                      int         *height_mm)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  *width_mm = output_info->width_mm;
+  *height_mm = output_info->height_mm;
+}
+
+CoglSubpixelOrder
+meta_monitor_get_subpixel_order (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->subpixel_order;
+}
+
+const char *
+meta_monitor_get_connector (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->name;
+}
+
+const char *
+meta_monitor_get_vendor (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vendor;
+}
+
+const char *
+meta_monitor_get_product (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->product;
+}
+
+const char *
+meta_monitor_get_serial (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->serial;
+}
+
+const MetaEdidInfo *
+meta_monitor_get_edid_info (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->edid_info;
+}
+
+const char *
+meta_monitor_get_edid_checksum_md5 (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->edid_checksum_md5;
+}
+
+MetaConnectorType
+meta_monitor_get_connector_type (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->connector_type;
+}
+
+MetaMonitorTransform
+meta_monitor_logical_to_crtc_transform (MetaMonitor          *monitor,
+                                        MetaMonitorTransform  transform)
+{
+  MetaOutput *output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_logical_to_crtc_transform (output, transform);
+}
+
+MetaMonitorTransform
+meta_monitor_crtc_to_logical_transform (MetaMonitor          *monitor,
+                                        MetaMonitorTransform  transform)
+{
+  MetaOutput *output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_crtc_to_logical_transform (output, transform);
+}
+
+static void
+meta_monitor_dispose (GObject *object)
+{
+  MetaMonitor *monitor = META_MONITOR (object);
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  if (priv->outputs)
+    {
+      g_list_foreach (priv->outputs, (GFunc) meta_output_unset_monitor, NULL);
+      g_list_free_full (priv->outputs, g_object_unref);
+      priv->outputs = NULL;
+    }
+
+  G_OBJECT_CLASS (meta_monitor_parent_class)->dispose (object);
+}
+
+static void
+meta_monitor_finalize (GObject *object)
+{
+  MetaMonitor *monitor = META_MONITOR (object);
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  g_hash_table_destroy (priv->mode_ids);
+  g_list_free_full (priv->modes, (GDestroyNotify) meta_monitor_mode_free);
+  meta_monitor_spec_free (priv->spec);
+  g_free (priv->display_name);
+
+  G_OBJECT_CLASS (meta_monitor_parent_class)->finalize (object);
+}
+
+static void
+meta_monitor_init (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  priv->mode_ids = g_hash_table_new (g_str_hash, g_str_equal);
+}
+
+static void
+meta_monitor_class_init (MetaMonitorClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_monitor_dispose;
+  object_class->finalize = meta_monitor_finalize;
+}
+
+static char *
+generate_mode_id (MetaMonitorModeSpec *monitor_mode_spec)
+{
+  gboolean is_interlaced;
+  char rate_str[G_ASCII_DTOSTR_BUF_SIZE];
+
+  is_interlaced = !!(monitor_mode_spec->flags & META_CRTC_MODE_FLAG_INTERLACE);
+  g_ascii_formatd (rate_str, sizeof (rate_str),
+                   "%.3f", monitor_mode_spec->refresh_rate);
+
+  return g_strdup_printf ("%dx%d%s@%s",
+                          monitor_mode_spec->width,
+                          monitor_mode_spec->height,
+                          is_interlaced ? "i" : "",
+                          rate_str);
+}
+
+static gboolean
+meta_monitor_add_mode (MetaMonitor     *monitor,
+                       MetaMonitorMode *monitor_mode,
+                       gboolean         replace)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  MetaMonitorMode *existing_mode;
+
+  existing_mode = g_hash_table_lookup (priv->mode_ids,
+                                       meta_monitor_mode_get_id (monitor_mode));
+  if (existing_mode && !replace)
+    return FALSE;
+
+  if (existing_mode)
+    priv->modes = g_list_remove (priv->modes, existing_mode);
+
+  priv->modes = g_list_append (priv->modes, monitor_mode);
+  g_hash_table_replace (priv->mode_ids, monitor_mode->id, monitor_mode);
+
+  return TRUE;
+}
+
+static MetaMonitorModeSpec
+meta_monitor_create_spec (MetaMonitor  *monitor,
+                          int           width,
+                          int           height,
+                          MetaCrtcMode *crtc_mode)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+  const MetaCrtcModeInfo *crtc_mode_info =
+    meta_crtc_mode_get_info (crtc_mode);
+
+  if (meta_monitor_transform_is_rotated (output_info->panel_orientation_transform))
+    {
+      int temp = width;
+      width = height;
+      height = temp;
+    }
+
+  return (MetaMonitorModeSpec) {
+    .width = width,
+    .height = height,
+    .refresh_rate = crtc_mode_info->refresh_rate,
+    .flags = crtc_mode_info->flags & HANDLED_CRTC_MODE_FLAGS
+  };
+}
+
+/**
+ * meta_monitor_get_gamma_lut_size:
+ * @monitor: The MetaMonitor instance to retrieve the size from.
+ *
+ * Get the size of the look-up tables (LUTs) for the monitor.
+ *
+ * Retrieve the size of the LUT used to implement the encoding or decoding
+ * transfer functions ("gamma", "degamma") for the CRTC or CRTCs that backs
+ * this monitor.
+ *
+ * Returns: The number of look-up table entries possible for the monitor. It is
+ *   assumed that each CRTC of a monitor has identical gamma LUT sizes.
+ */
+size_t
+meta_monitor_get_gamma_lut_size (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+  MetaCrtc *crtc;
+
+  output = meta_monitor_get_main_output (monitor);
+  crtc = meta_output_get_assigned_crtc (output);
+  return meta_crtc_get_gamma_lut_size (crtc);
+}
+
+static gboolean
+set_gamma_lut (MetaMonitor          *monitor,
+               MetaMonitorMode      *mode,
+               MetaMonitorCrtcMode  *monitor_crtc_mode,
+               gpointer              user_data,
+               GError              **error)
+{
+  const MetaGammaLut *lut = user_data;
+  MetaCrtc *crtc;
+
+  crtc = meta_output_get_assigned_crtc (monitor_crtc_mode->output);
+
+  meta_crtc_set_gamma_lut (crtc, lut);
+  return TRUE;
+}
+
+/**
+ * meta_monitor_set_gamma_lut:
+ *
+ * Set a new gamma look-up table (LUT) for the given monitor's CRTCs.
+ */
+void
+meta_monitor_set_gamma_lut (MetaMonitor        *monitor,
+                            const MetaGammaLut *lut)
+{
+  MetaMonitorMode *current_mode;
+
+  current_mode = meta_monitor_get_current_mode (monitor);
+  g_return_if_fail (current_mode);
+
+  meta_monitor_mode_foreach_crtc (monitor,
+                                  current_mode,
+                                  set_gamma_lut,
+                                  (gpointer) lut,
+                                  NULL);
+}
+
+static void
+meta_monitor_normal_generate_modes (MetaMonitorNormal *monitor_normal)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_normal);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaOutput *output;
+  const MetaOutputInfo *output_info;
+  MetaCrtcMode *preferred_mode;
+  MetaCrtcModeFlag preferred_mode_flags;
+  unsigned int i;
+
+  output = meta_monitor_get_main_output (monitor);
+  output_info = meta_output_get_info (output);
+  preferred_mode = output_info->preferred_mode;
+  preferred_mode_flags = meta_crtc_mode_get_info (preferred_mode)->flags;
+
+  for (i = 0; i < output_info->n_modes; i++)
+    {
+      MetaCrtcMode *crtc_mode = output_info->modes[i];
+      const MetaCrtcModeInfo *crtc_mode_info =
+        meta_crtc_mode_get_info (crtc_mode);
+      MetaCrtc *crtc;
+      MetaMonitorMode *mode;
+      gboolean replace;
+
+      mode = g_new0 (MetaMonitorMode, 1);
+      mode->monitor = monitor;
+      mode->spec = meta_monitor_create_spec (monitor,
+                                             crtc_mode_info->width,
+                                             crtc_mode_info->height,
+                                             crtc_mode);
+      mode->id = generate_mode_id (&mode->spec);
+      mode->crtc_modes = g_new (MetaMonitorCrtcMode, 1);
+      mode->crtc_modes[0] = (MetaMonitorCrtcMode) {
+        .output = output,
+        .crtc_mode = crtc_mode
+      };
+
+      /*
+       * We don't distinguish between all available mode flags, just the ones
+       * that are configurable. We still need to pick some mode though, so
+       * prefer ones that has the same set of flags as the preferred mode;
+       * otherwise take the first one in the list. This guarantees that the
+       * preferred mode is always added.
+       */
+      replace = (crtc_mode_info->flags == preferred_mode_flags &&
+                 (!monitor_priv->preferred_mode ||
+                  g_strcmp0 (meta_monitor_mode_get_id (monitor_priv->preferred_mode),
+                             mode->id) != 0));
+
+      if (!meta_monitor_add_mode (monitor, mode, replace))
+        {
+          g_assert (crtc_mode != output_info->preferred_mode);
+          meta_monitor_mode_free (mode);
+          continue;
+        }
+
+      if (crtc_mode == output_info->preferred_mode)
+        monitor_priv->preferred_mode = mode;
+
+      crtc = meta_output_get_assigned_crtc (output);
+      if (crtc)
+        {
+          const MetaCrtcConfig *crtc_config;
+
+          crtc_config = meta_crtc_get_config (crtc);
+          if (crtc_config && crtc_mode == crtc_config->mode)
+            monitor_priv->current_mode = mode;
+        }
+    }
+}
+
+MetaMonitorNormal *
+meta_monitor_normal_new (MetaMonitorManager *monitor_manager,
+                         MetaOutput         *output)
+{
+  MetaMonitorNormal *monitor_normal;
+  MetaMonitor *monitor;
+  MetaMonitorPrivate *monitor_priv;
+
+  monitor_normal = g_object_new (META_TYPE_MONITOR_NORMAL, NULL);
+  monitor = META_MONITOR (monitor_normal);
+  monitor_priv = meta_monitor_get_instance_private (monitor);
+
+  monitor_priv->backend = meta_monitor_manager_get_backend (monitor_manager);
+
+  monitor_priv->outputs = g_list_append (NULL, g_object_ref (output));
+  meta_output_set_monitor (output, monitor);
+
+  monitor_priv->winsys_id = meta_output_get_id (output);
+  meta_monitor_generate_spec (monitor);
+
+  meta_monitor_normal_generate_modes (monitor_normal);
+
+  monitor_priv->display_name = meta_monitor_make_display_name (monitor);
+
+  return monitor_normal;
+}
+
+static MetaOutput *
+meta_monitor_normal_get_main_output (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+
+  return monitor_priv->outputs->data;
+}
+
+static void
+meta_monitor_normal_derive_layout (MetaMonitor  *monitor,
+                                   MtkRectangle *layout)
+{
+  MetaOutput *output;
+  MetaCrtc *crtc;
+  const MetaCrtcConfig *crtc_config;
+
+  output = meta_monitor_get_main_output (monitor);
+  crtc = meta_output_get_assigned_crtc (output);
+  crtc_config = meta_crtc_get_config (crtc);
+
+  g_return_if_fail (crtc_config);
+
+  mtk_rectangle_from_graphene_rect (&crtc_config->layout,
+                                    MTK_ROUNDING_STRATEGY_ROUND,
+                                    layout);
+}
+
+static gboolean
+meta_monitor_normal_get_suggested_position (MetaMonitor *monitor,
+                                            int         *x,
+                                            int         *y)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  if (!output_info->hotplug_mode_update)
+    return FALSE;
+
+  if (output_info->suggested_x < 0 && output_info->suggested_y < 0)
+    return FALSE;
+
+  if (x)
+    *x = output_info->suggested_x;
+
+  if (y)
+    *y = output_info->suggested_y;
+
+  return TRUE;
+}
+
+static void
+meta_monitor_normal_calculate_crtc_pos (MetaMonitor          *monitor,
+                                        MetaMonitorMode      *monitor_mode,
+                                        MetaOutput           *output,
+                                        MetaMonitorTransform  crtc_transform,
+                                        int                  *out_x,
+                                        int                  *out_y)
+{
+  *out_x = 0;
+  *out_y = 0;
+}
+
+static void
+meta_monitor_normal_init (MetaMonitorNormal *monitor)
+{
+}
+
+static void
+meta_monitor_normal_class_init (MetaMonitorNormalClass *klass)
+{
+  MetaMonitorClass *monitor_class = META_MONITOR_CLASS (klass);
+
+  monitor_class->get_main_output = meta_monitor_normal_get_main_output;
+  monitor_class->derive_layout = meta_monitor_normal_derive_layout;
+  monitor_class->calculate_crtc_pos = meta_monitor_normal_calculate_crtc_pos;
+  monitor_class->get_suggested_position = meta_monitor_normal_get_suggested_position;
+}
+
+uint32_t
+meta_monitor_tiled_get_tile_group_id (MetaMonitorTiled *monitor_tiled)
+{
+  return monitor_tiled->tile_group_id;
+}
+
+gboolean
+meta_monitor_get_suggested_position (MetaMonitor *monitor,
+                                     int         *x,
+                                     int         *y)
+{
+  return META_MONITOR_GET_CLASS (monitor)->get_suggested_position (monitor,
+                                                                   x, y);
+}
+
+static void
+add_tiled_monitor_outputs (MetaGpu          *gpu,
+                           MetaMonitorTiled *monitor_tiled)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (META_MONITOR (monitor_tiled));
+  GList *outputs;
+  GList *l;
+
+  outputs = meta_gpu_get_outputs (gpu);
+  for (l = outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+      const MetaOutputInfo *output_info = meta_output_get_info (output);
+      const MetaOutputInfo *origin_output_info;
+
+      if (output_info->tile_info.group_id != monitor_tiled->tile_group_id)
+        continue;
+
+      origin_output_info = meta_output_get_info (monitor_tiled->origin_output);
+      g_warn_if_fail (output_info->subpixel_order ==
+                      origin_output_info->subpixel_order);
+
+      monitor_priv->outputs = g_list_append (monitor_priv->outputs,
+                                             g_object_ref (output));
+
+      meta_output_set_monitor (output, META_MONITOR (monitor_tiled));
+    }
+}
+
+static void
+calculate_tile_coordinate (MetaMonitor         *monitor,
+                           MetaOutput          *output,
+                           MetaMonitorTransform crtc_transform,
+                           int                 *out_x,
+                           int                 *out_y)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  GList *l;
+  int x = 0;
+  int y = 0;
+
+  for (l = monitor_priv->outputs; l; l = l->next)
+    {
+      const MetaOutputInfo *other_output_info = meta_output_get_info (l->data);
+
+      switch (crtc_transform)
+        {
+        case META_MONITOR_TRANSFORM_NORMAL:
+        case META_MONITOR_TRANSFORM_FLIPPED:
+          if ((other_output_info->tile_info.loc_v_tile ==
+               output_info->tile_info.loc_v_tile) &&
+              (other_output_info->tile_info.loc_h_tile <
+               output_info->tile_info.loc_h_tile))
+            x += other_output_info->tile_info.tile_w;
+          if ((other_output_info->tile_info.loc_h_tile ==
+               output_info->tile_info.loc_h_tile) &&
+              (other_output_info->tile_info.loc_v_tile <
+               output_info->tile_info.loc_v_tile))
+            y += other_output_info->tile_info.tile_h;
+          break;
+        case META_MONITOR_TRANSFORM_180:
+        case META_MONITOR_TRANSFORM_FLIPPED_180:
+          if ((other_output_info->tile_info.loc_v_tile ==
+               output_info->tile_info.loc_v_tile) &&
+              (other_output_info->tile_info.loc_h_tile >
+               output_info->tile_info.loc_h_tile))
+            x += other_output_info->tile_info.tile_w;
+          if ((other_output_info->tile_info.loc_h_tile ==
+               output_info->tile_info.loc_h_tile) &&
+              (other_output_info->tile_info.loc_v_tile >
+               output_info->tile_info.loc_v_tile))
+            y += other_output_info->tile_info.tile_h;
+          break;
+        case META_MONITOR_TRANSFORM_270:
+        case META_MONITOR_TRANSFORM_FLIPPED_270:
+          if ((other_output_info->tile_info.loc_v_tile ==
+               output_info->tile_info.loc_v_tile) &&
+              (other_output_info->tile_info.loc_h_tile >
+               output_info->tile_info.loc_h_tile))
+            y += other_output_info->tile_info.tile_w;
+          if ((other_output_info->tile_info.loc_h_tile ==
+               output_info->tile_info.loc_h_tile) &&
+              (other_output_info->tile_info.loc_v_tile >
+               output_info->tile_info.loc_v_tile))
+            x += other_output_info->tile_info.tile_h;
+          break;
+        case META_MONITOR_TRANSFORM_90:
+        case META_MONITOR_TRANSFORM_FLIPPED_90:
+          if ((other_output_info->tile_info.loc_v_tile ==
+               output_info->tile_info.loc_v_tile) &&
+              (other_output_info->tile_info.loc_h_tile <
+               output_info->tile_info.loc_h_tile))
+            y += other_output_info->tile_info.tile_w;
+          if ((other_output_info->tile_info.loc_h_tile ==
+               output_info->tile_info.loc_h_tile) &&
+              (other_output_info->tile_info.loc_v_tile <
+               output_info->tile_info.loc_v_tile))
+            x += other_output_info->tile_info.tile_h;
+          break;
+        }
+    }
+
+  *out_x = x;
+  *out_y = y;
+}
+
+static void
+meta_monitor_tiled_calculate_tiled_size (MetaMonitor *monitor,
+                                         int         *out_width,
+                                         int         *out_height)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  GList *l;
+  int width;
+  int height;
+
+  width = 0;
+  height = 0;
+  for (l = monitor_priv->outputs; l; l = l->next)
+    {
+      const MetaOutputInfo *output_info = meta_output_get_info (l->data);
+
+      if (output_info->tile_info.loc_v_tile == 0)
+        width += output_info->tile_info.tile_w;
+
+      if (output_info->tile_info.loc_h_tile == 0)
+        height += output_info->tile_info.tile_h;
+    }
+
+  *out_width = width;
+  *out_height = height;
+}
+
+static gboolean
+is_monitor_mode_assigned (MetaMonitor     *monitor,
+                          MetaMonitorMode *mode)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  GList *l;
+  int i;
+
+  for (l = priv->outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaOutput *output = l->data;
+      MetaMonitorCrtcMode *monitor_crtc_mode = &mode->crtc_modes[i];
+      MetaCrtc *crtc;
+      const MetaCrtcConfig *crtc_config;
+
+      crtc = meta_output_get_assigned_crtc (output);
+      crtc_config = crtc ? meta_crtc_get_config (crtc) : NULL;
+
+      if (monitor_crtc_mode->crtc_mode &&
+          (!crtc || !crtc_config ||
+           crtc_config->mode != monitor_crtc_mode->crtc_mode))
+        return FALSE;
+      else if (!monitor_crtc_mode->crtc_mode && crtc)
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+is_crtc_mode_tiled (MetaOutput   *output,
+                    MetaCrtcMode *crtc_mode)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  const MetaCrtcModeInfo *crtc_mode_info = meta_crtc_mode_get_info (crtc_mode);
+
+  return (crtc_mode_info->width == (int) output_info->tile_info.tile_w &&
+          crtc_mode_info->height == (int) output_info->tile_info.tile_h);
+}
+
+static MetaCrtcMode *
+find_tiled_crtc_mode (MetaOutput   *output,
+                      MetaCrtcMode *reference_crtc_mode)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  const MetaCrtcModeInfo *reference_crtc_mode_info =
+    meta_crtc_mode_get_info (reference_crtc_mode);
+  MetaCrtcMode *crtc_mode;
+  unsigned int i;
+
+  crtc_mode = output_info->preferred_mode;
+  if (is_crtc_mode_tiled (output, crtc_mode))
+    return crtc_mode;
+
+  for (i = 0; i < output_info->n_modes; i++)
+    {
+      const MetaCrtcModeInfo *crtc_mode_info;
+
+      crtc_mode = output_info->modes[i];
+      crtc_mode_info = meta_crtc_mode_get_info (crtc_mode);
+
+      if (!is_crtc_mode_tiled (output, crtc_mode))
+        continue;
+
+      if (crtc_mode_info->refresh_rate != reference_crtc_mode_info->refresh_rate)
+        continue;
+
+      if (crtc_mode_info->flags != reference_crtc_mode_info->flags)
+        continue;
+
+      return crtc_mode;
+    }
+
+  return NULL;
+}
+
+static MetaMonitorMode *
+create_tiled_monitor_mode (MetaMonitorTiled *monitor_tiled,
+                           MetaCrtcMode     *reference_crtc_mode,
+                           gboolean         *out_is_preferred)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaMonitorModeTiled *mode;
+  int width, height;
+  GList *l;
+  unsigned int i;
+  gboolean is_preferred = TRUE;
+
+  mode = g_new0 (MetaMonitorModeTiled, 1);
+  mode->is_tiled = TRUE;
+  meta_monitor_tiled_calculate_tiled_size (monitor, &width, &height);
+  mode->parent.monitor = monitor;
+  mode->parent.spec =
+    meta_monitor_create_spec (monitor, width, height, reference_crtc_mode);
+  mode->parent.id = generate_mode_id (&mode->parent.spec);
+
+  mode->parent.crtc_modes = g_new0 (MetaMonitorCrtcMode,
+                                    g_list_length (monitor_priv->outputs));
+  for (l = monitor_priv->outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaOutput *output = l->data;
+      const MetaOutputInfo *output_info = meta_output_get_info (output);
+      MetaCrtcMode *tiled_crtc_mode;
+
+      tiled_crtc_mode = find_tiled_crtc_mode (output, reference_crtc_mode);
+      if (!tiled_crtc_mode)
+        {
+          g_warning ("No tiled mode found on %s", meta_output_get_name (output));
+          meta_monitor_mode_free ((MetaMonitorMode *) mode);
+          return NULL;
+        }
+
+      mode->parent.crtc_modes[i] = (MetaMonitorCrtcMode) {
+        .output = output,
+        .crtc_mode = tiled_crtc_mode
+      };
+
+      is_preferred = (is_preferred &&
+                      tiled_crtc_mode == output_info->preferred_mode);
+    }
+
+  *out_is_preferred = is_preferred;
+
+  return (MetaMonitorMode *) mode;
+}
+
+static void
+generate_tiled_monitor_modes (MetaMonitorTiled *monitor_tiled)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaOutput *main_output;
+  const MetaOutputInfo *main_output_info;
+  GList *tiled_modes = NULL;
+  unsigned int i;
+  MetaMonitorMode *best_mode = NULL;
+  GList *l;
+
+  main_output = meta_monitor_get_main_output (META_MONITOR (monitor_tiled));
+  main_output_info = meta_output_get_info (main_output);
+
+  for (i = 0; i < main_output_info->n_modes; i++)
+    {
+      MetaCrtcMode *reference_crtc_mode = main_output_info->modes[i];
+      MetaMonitorMode *mode;
+      gboolean is_preferred;
+
+      if (!is_crtc_mode_tiled (main_output, reference_crtc_mode))
+        continue;
+
+      mode = create_tiled_monitor_mode (monitor_tiled, reference_crtc_mode,
+                                        &is_preferred);
+      if (!mode)
+        continue;
+
+      tiled_modes = g_list_append (tiled_modes, mode);
+
+      if (is_monitor_mode_assigned (monitor, mode))
+        monitor_priv->current_mode = mode;
+
+      if (is_preferred)
+        monitor_priv->preferred_mode = mode;
+    }
+
+  while ((l = tiled_modes))
+    {
+      MetaMonitorMode *mode = l->data;
+
+      tiled_modes = g_list_remove_link (tiled_modes, l);
+
+      if (!meta_monitor_add_mode (monitor, mode, FALSE))
+        {
+          meta_monitor_mode_free (mode);
+          continue;
+        }
+
+      if (!monitor_priv->preferred_mode)
+        {
+          if (!best_mode ||
+              mode->spec.refresh_rate > best_mode->spec.refresh_rate)
+            best_mode = mode;
+        }
+    }
+
+  if (best_mode)
+    monitor_priv->preferred_mode = best_mode;
+}
+
+static MetaMonitorMode *
+create_untiled_monitor_mode (MetaMonitorTiled *monitor_tiled,
+                             MetaOutput       *main_output,
+                             MetaCrtcMode     *crtc_mode)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaMonitorModeTiled *mode;
+  const MetaCrtcModeInfo *crtc_mode_info;
+  GList *l;
+  int i;
+
+  if (is_crtc_mode_tiled (main_output, crtc_mode))
+    return NULL;
+
+  mode = g_new0 (MetaMonitorModeTiled, 1);
+  mode->is_tiled = FALSE;
+  mode->parent.monitor = monitor;
+
+  crtc_mode_info = meta_crtc_mode_get_info (crtc_mode);
+  mode->parent.spec = meta_monitor_create_spec (monitor,
+                                                crtc_mode_info->width,
+                                                crtc_mode_info->height,
+                                                crtc_mode);
+  mode->parent.id = generate_mode_id (&mode->parent.spec);
+  mode->parent.crtc_modes = g_new0 (MetaMonitorCrtcMode,
+                                    g_list_length (monitor_priv->outputs));
+
+  for (l = monitor_priv->outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaOutput *output = l->data;
+
+      if (output == main_output)
+        {
+          mode->parent.crtc_modes[i] = (MetaMonitorCrtcMode) {
+            .output = output,
+            .crtc_mode = crtc_mode
+          };
+        }
+      else
+        {
+          mode->parent.crtc_modes[i] = (MetaMonitorCrtcMode) {
+            .output = output,
+            .crtc_mode = NULL
+          };
+        }
+    }
+
+  return &mode->parent;
+}
+
+static int
+count_untiled_crtc_modes (MetaOutput *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  int count;
+  unsigned int i;
+
+  count = 0;
+  for (i = 0; i < output_info->n_modes; i++)
+    {
+      MetaCrtcMode *crtc_mode = output_info->modes[i];
+
+      if (!is_crtc_mode_tiled (output, crtc_mode))
+        count++;
+    }
+
+  return count;
+}
+
+static MetaOutput *
+find_untiled_output (MetaMonitorTiled *monitor_tiled)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaOutput *best_output;
+  int best_untiled_crtc_mode_count;
+  GList *l;
+
+  best_output = monitor_tiled->origin_output;
+  best_untiled_crtc_mode_count =
+    count_untiled_crtc_modes (monitor_tiled->origin_output);
+
+  for (l = monitor_priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+      int untiled_crtc_mode_count;
+
+      if (output == monitor_tiled->origin_output)
+        continue;
+
+      untiled_crtc_mode_count = count_untiled_crtc_modes (output);
+      if (untiled_crtc_mode_count > best_untiled_crtc_mode_count)
+        {
+          best_untiled_crtc_mode_count = untiled_crtc_mode_count;
+          best_output = output;
+        }
+    }
+
+  return best_output;
+}
+
+static void
+generate_untiled_monitor_modes (MetaMonitorTiled *monitor_tiled)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaOutput *main_output;
+  const MetaOutputInfo *main_output_info;
+  unsigned int i;
+
+  main_output = meta_monitor_get_main_output (monitor);
+  main_output_info = meta_output_get_info (main_output);
+
+  for (i = 0; i < main_output_info->n_modes; i++)
+    {
+      MetaCrtcMode *crtc_mode = main_output_info->modes[i];
+      MetaMonitorMode *mode;
+
+      mode = create_untiled_monitor_mode (monitor_tiled,
+                                          main_output,
+                                          crtc_mode);
+      if (!mode)
+        continue;
+
+      if (!meta_monitor_add_mode (monitor, mode, FALSE))
+        {
+          meta_monitor_mode_free (mode);
+          continue;
+        }
+
+      if (is_monitor_mode_assigned (monitor, mode))
+        {
+          g_assert (!monitor_priv->current_mode);
+          monitor_priv->current_mode = mode;
+        }
+
+      if (!monitor_priv->preferred_mode &&
+          crtc_mode == main_output_info->preferred_mode)
+        monitor_priv->preferred_mode = mode;
+    }
+}
+
+static MetaMonitorMode *
+find_best_mode (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  MetaMonitorMode *best_mode = NULL;
+  GList *l;
+
+  for (l = monitor_priv->modes; l; l = l->next)
+    {
+      MetaMonitorMode *mode = l->data;
+      int area, best_area;
+
+      if (!best_mode)
+        {
+          best_mode = mode;
+          continue;
+        }
+
+      area = mode->spec.width * mode->spec.height;
+      best_area = best_mode->spec.width * best_mode->spec.height;
+      if (area > best_area)
+        {
+          best_mode = mode;
+          continue;
+        }
+
+      if (mode->spec.refresh_rate > best_mode->spec.refresh_rate)
+        {
+          best_mode = mode;
+          continue;
+        }
+    }
+
+  return best_mode;
+}
+
+static void
+meta_monitor_tiled_generate_modes (MetaMonitorTiled *monitor_tiled)
+{
+  MetaMonitor *monitor = META_MONITOR (monitor_tiled);
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+
+  /*
+   * Tiled monitors may look a bit different from each other, depending on the
+   * monitor itself, the driver, etc.
+   *
+   * On some, the tiled modes will be the preferred CRTC modes, and running
+   * untiled is done by only enabling (0, 0) tile. In this case, things are
+   * pretty straight forward.
+   *
+   * Other times a monitor may have some bogus mode preferred on the main tile,
+   * and an untiled mode preferred on the non-main tile, and there seems to be
+   * no guarantee that the (0, 0) tile is the one that should drive the
+   * non-tiled mode.
+   *
+   * To handle both these cases, the following hueristics are implemented:
+   *
+   *  1) Find all the tiled CRTC modes of the (0, 0) tile, and create tiled
+   *     monitor modes for all tiles based on these.
+   *  2) If there is any tiled monitor mode combination where all CRTC modes
+   *     are the preferred ones, that one is marked as preferred.
+   *  3) If there is no preferred mode determined so far, assume the tiled
+   *     monitor mode with the highest refresh rate is preferred.
+   *  4) Find the tile with highest number of untiled CRTC modes available,
+   *     assume this is the one driving the monitor in untiled mode, and
+   *     create monitor modes for all untiled CRTC modes of that tile. If
+   *     there is still no preferred mode, set any untiled mode as preferred
+   *     if the CRTC mode is marked as such.
+   *  5) If at this point there is still no preferred mode, just pick the one
+   *     with the highest number of pixels and highest refresh rate.
+   *
+   * Note that this ignores the preference if the preference is a non-tiled
+   * mode. This seems to be the case on some systems, where the user tends to
+   * manually set up the tiled mode anyway.
+   */
+
+  generate_tiled_monitor_modes (monitor_tiled);
+
+  if (!monitor_priv->preferred_mode)
+    g_warning ("Tiled monitor on %s didn't have any tiled modes",
+               monitor_priv->spec->connector);
+
+  generate_untiled_monitor_modes (monitor_tiled);
+
+  if (!monitor_priv->preferred_mode)
+    {
+      g_warning ("Tiled monitor on %s didn't have a valid preferred mode",
+                 monitor_priv->spec->connector);
+      monitor_priv->preferred_mode = find_best_mode (monitor);
+    }
+}
+
+MetaMonitorTiled *
+meta_monitor_tiled_new (MetaMonitorManager *monitor_manager,
+                        MetaOutput         *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  MetaMonitorTiled *monitor_tiled;
+  MetaMonitor *monitor;
+  MetaMonitorPrivate *monitor_priv;
+
+  monitor_tiled = g_object_new (META_TYPE_MONITOR_TILED, NULL);
+  monitor = META_MONITOR (monitor_tiled);
+  monitor_priv = meta_monitor_get_instance_private (monitor);
+
+  monitor_priv->backend = meta_monitor_manager_get_backend (monitor_manager);
+
+  monitor_tiled->tile_group_id = output_info->tile_info.group_id;
+  monitor_priv->winsys_id = meta_output_get_id (output);
+
+  monitor_tiled->origin_output = output;
+  add_tiled_monitor_outputs (meta_output_get_gpu (output), monitor_tiled);
+
+  monitor_tiled->main_output = find_untiled_output (monitor_tiled);
+
+  meta_monitor_generate_spec (monitor);
+
+  monitor_tiled->monitor_manager = monitor_manager;
+  meta_monitor_manager_tiled_monitor_added (monitor_manager,
+                                            META_MONITOR (monitor_tiled));
+
+  meta_monitor_tiled_generate_modes (monitor_tiled);
+
+  monitor_priv->display_name = meta_monitor_make_display_name (monitor);
+
+  return monitor_tiled;
+}
+
+static MetaOutput *
+meta_monitor_tiled_get_main_output (MetaMonitor *monitor)
+{
+  MetaMonitorTiled *monitor_tiled = META_MONITOR_TILED (monitor);
+
+  return monitor_tiled->main_output;
+}
+
+static void
+meta_monitor_tiled_derive_layout (MetaMonitor  *monitor,
+                                  MtkRectangle *layout)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  GList *l;
+  float min_x, min_y, max_x, max_y;
+
+  min_x = FLT_MAX;
+  min_y = FLT_MAX;
+  max_x = 0.0;
+  max_y = 0.0;
+  for (l = monitor_priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+      MetaCrtc *crtc;
+      const MetaCrtcConfig *crtc_config;
+      const graphene_rect_t *crtc_layout;
+
+      crtc = meta_output_get_assigned_crtc (output);
+      if (!crtc)
+        continue;
+
+      crtc_config = meta_crtc_get_config (crtc);
+      g_return_if_fail (crtc_config);
+
+      crtc_layout = &crtc_config->layout;
+
+      min_x = MIN (crtc_layout->origin.x, min_x);
+      min_y = MIN (crtc_layout->origin.y, min_y);
+      max_x = MAX (crtc_layout->origin.x + crtc_layout->size.width, max_x);
+      max_y = MAX (crtc_layout->origin.y + crtc_layout->size.height, max_y);
+    }
+
+  *layout = (MtkRectangle) {
+    .x = roundf (min_x),
+    .y = roundf (min_y),
+    .width = roundf (max_x - min_x),
+    .height = roundf (max_y - min_y)
+  };
+}
+
+static gboolean
+meta_monitor_tiled_get_suggested_position (MetaMonitor *monitor,
+                                           int         *x,
+                                           int         *y)
+{
+  return FALSE;
+}
+
+static void
+meta_monitor_tiled_calculate_crtc_pos (MetaMonitor          *monitor,
+                                       MetaMonitorMode      *monitor_mode,
+                                       MetaOutput           *output,
+                                       MetaMonitorTransform  crtc_transform,
+                                       int                  *out_x,
+                                       int                  *out_y)
+{
+  MetaMonitorModeTiled *mode_tiled = (MetaMonitorModeTiled *) monitor_mode;
+
+  if (mode_tiled->is_tiled)
+    {
+      calculate_tile_coordinate (monitor, output, crtc_transform,
+                                 out_x, out_y);
+    }
+  else
+    {
+      *out_x = 0;
+      *out_y = 0;
+    }
+}
+
+static void
+meta_monitor_tiled_finalize (GObject *object)
+{
+  MetaMonitorTiled *monitor_tiled = META_MONITOR_TILED (object);
+
+  meta_monitor_manager_tiled_monitor_removed (monitor_tiled->monitor_manager,
+                                              META_MONITOR (monitor_tiled));
+
+  G_OBJECT_CLASS (meta_monitor_tiled_parent_class)->finalize (object);
+}
+
+static void
+meta_monitor_tiled_init (MetaMonitorTiled *monitor)
+{
+}
+
+static void
+meta_monitor_tiled_class_init (MetaMonitorTiledClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  MetaMonitorClass *monitor_class = META_MONITOR_CLASS (klass);
+
+  object_class->finalize = meta_monitor_tiled_finalize;
+
+  monitor_class->get_main_output = meta_monitor_tiled_get_main_output;
+  monitor_class->derive_layout = meta_monitor_tiled_derive_layout;
+  monitor_class->calculate_crtc_pos = meta_monitor_tiled_calculate_crtc_pos;
+  monitor_class->get_suggested_position = meta_monitor_tiled_get_suggested_position;
+}
+
+static void
+meta_monitor_mode_free (MetaMonitorMode *monitor_mode)
+{
+  g_free (monitor_mode->id);
+  g_free (monitor_mode->crtc_modes);
+  g_free (monitor_mode);
+}
+
+MetaMonitorSpec *
+meta_monitor_get_spec (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->spec;
+}
+
+MetaLogicalMonitor *
+meta_monitor_get_logical_monitor (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->logical_monitor;
+}
+
+MetaMonitorMode *
+meta_monitor_get_mode_from_id (MetaMonitor *monitor,
+                               const char  *monitor_mode_id)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return g_hash_table_lookup (priv->mode_ids, monitor_mode_id);
+}
+
+gboolean
+meta_monitor_mode_spec_has_similar_size (MetaMonitorModeSpec *monitor_mode_spec,
+                                         MetaMonitorModeSpec *other_monitor_mode_spec)
+{
+  const float target_ratio = 1.0;
+  /* The a size difference of 15% means e.g. 4K modes matches other 4K modes,
+   * FHD (2K) modes other FHD modes, and HD modes other HD modes, but not each
+   * other.
+   */
+  const float epsilon = 0.15;
+
+  return G_APPROX_VALUE (((float) monitor_mode_spec->width /
+                          other_monitor_mode_spec->width) *
+                         ((float) monitor_mode_spec->height /
+                          other_monitor_mode_spec->height),
+                         target_ratio, epsilon);
+}
+
+static gboolean
+meta_monitor_mode_spec_equals (MetaMonitorModeSpec *monitor_mode_spec,
+                               MetaMonitorModeSpec *other_monitor_mode_spec)
+{
+  return (monitor_mode_spec->width == other_monitor_mode_spec->width &&
+          monitor_mode_spec->height == other_monitor_mode_spec->height &&
+          ABS (monitor_mode_spec->refresh_rate -
+               other_monitor_mode_spec->refresh_rate) < MAXIMUM_REFRESH_RATE_DIFF &&
+          monitor_mode_spec->flags == other_monitor_mode_spec->flags);
+}
+
+MetaMonitorMode *
+meta_monitor_get_mode_from_spec (MetaMonitor         *monitor,
+                                 MetaMonitorModeSpec *monitor_mode_spec)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  GList *l;
+
+  for (l = priv->modes; l; l = l->next)
+    {
+      MetaMonitorMode *monitor_mode = l->data;
+
+      if (meta_monitor_mode_spec_equals (monitor_mode_spec,
+                                         &monitor_mode->spec))
+        return monitor_mode;
+    }
+
+  return NULL;
+}
+
+MetaMonitorMode *
+meta_monitor_get_preferred_mode (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->preferred_mode;
+}
+
+MetaMonitorMode *
+meta_monitor_get_current_mode (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->current_mode;
+}
+
+static gboolean
+is_current_mode_known (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+  MetaCrtc *crtc;
+
+  output = meta_monitor_get_main_output (monitor);
+  crtc = meta_output_get_assigned_crtc (output);
+
+  return (meta_monitor_is_active (monitor) ==
+          (crtc && meta_crtc_get_config (crtc)));
+}
+
+void
+meta_monitor_derive_current_mode (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  MetaMonitorMode *current_mode = NULL;
+  GList *l;
+
+  for (l = priv->modes; l; l = l->next)
+    {
+      MetaMonitorMode *mode = l->data;
+
+      if (is_monitor_mode_assigned (monitor, mode))
+        {
+          current_mode = mode;
+          break;
+        }
+    }
+
+  priv->current_mode = current_mode;
+
+  g_warn_if_fail (is_current_mode_known (monitor));
+}
+
+void
+meta_monitor_set_current_mode (MetaMonitor     *monitor,
+                               MetaMonitorMode *mode)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  priv->current_mode = mode;
+}
+
+GList *
+meta_monitor_get_modes (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  return priv->modes;
+}
+
+void
+meta_monitor_calculate_crtc_pos (MetaMonitor          *monitor,
+                                 MetaMonitorMode      *monitor_mode,
+                                 MetaOutput           *output,
+                                 MetaMonitorTransform  crtc_transform,
+                                 int                  *out_x,
+                                 int                  *out_y)
+{
+  META_MONITOR_GET_CLASS (monitor)->calculate_crtc_pos (monitor,
+                                                        monitor_mode,
+                                                        output,
+                                                        crtc_transform,
+                                                        out_x,
+                                                        out_y);
+}
+
+/*
+ * We choose a default scale factor such that the UI is as big
+ * as it would be on a display with this DPI without scaling.
+ *
+ * Through experiementing, a value of 135 has been found to best
+ * line up with the UI size chosen as default by other operating
+ * systems (macOS, Android, iOS, Windows) and the community-decided
+ * "known-good" scale factors for GNOME for various mobile devices
+ * such as phones, tablets, and laptops
+ */
+#define UI_SCALE_MOBILE_TARGET_DPI 135
+
+/*
+ * People tend to sit further away from larger stationary displays
+ * than they do from mobile displays, so a UI of an identical size to
+ * a mobile device has a smaller angular size and thus seems to be too
+ * small.
+ *
+ * The largest mainstream laptops have screens ~17in, and HiDPI external
+ * monitors start at ~23in, so 20in is a good boundary point
+ */
+#define UI_SCALE_LARGE_TARGET_DPI 110
+#define UI_SCALE_LARGE_MIN_SIZE_INCHES 20
+
+static float
+calculate_scale (MetaMonitor                *monitor,
+                 MetaMonitorMode            *monitor_mode,
+                 MetaMonitorScalesConstraint constraints)
+{
+  int width_px, height_px, width_mm, height_mm;
+  float diag_inches;
+  g_autofree float *scales = NULL;
+  int n_scales;
+  float best_scale, best_dpi;
+  int target_dpi;
+  const float scale_epsilon = 0.2;
+
+  /*
+   * Somebody encoded the aspect ratio (16/9 or 16/10) instead of the physical
+   * size. We'll be unable to select an appropriate scale factor.
+   */
+  if (meta_monitor_has_aspect_as_size (monitor))
+    return 1.0;
+
+  /* Compute display's diagonal size in inches */
+  meta_monitor_get_physical_dimensions (monitor, &width_mm, &height_mm);
+  if (width_mm == 0 || height_mm == 0)
+    return 1.0;
+  diag_inches = sqrtf (width_mm * width_mm + height_mm * height_mm) / 25.4;
+
+  /* Pick the appropriate target DPI based on screen size */
+  if (diag_inches < UI_SCALE_LARGE_MIN_SIZE_INCHES)
+    target_dpi = UI_SCALE_MOBILE_TARGET_DPI;
+  else
+    target_dpi = UI_SCALE_LARGE_TARGET_DPI;
+
+  meta_monitor_mode_get_resolution (monitor_mode, &width_px, &height_px);
+
+  /* We'll only be considering the supported scale factors */
+  scales = meta_monitor_calculate_supported_scales (monitor, monitor_mode,
+                                                    META_MONITOR_SCALES_CONSTRAINT_NONE,
+                                                    &n_scales);
+  best_scale = scales[0];
+  for (int i = 0; i < n_scales; i++)
+    {
+      float width_scaled, height_scaled, diag_scaled, dpi;
+
+      /*
+       * Compute the logical resolution of the display for this
+       * scale factor
+       */
+      width_scaled = (float) width_px / scales[i];
+      height_scaled = (float) height_px / scales[i];
+
+      /* Compute the number of logical pixels across the display's diagonal */
+      diag_scaled = sqrtf (width_scaled * width_scaled +
+                           height_scaled * height_scaled);
+
+      /*
+       * Computes the display's logical DPI - the number of logical pixels
+       * per inch on the display's diagonal
+       */
+      dpi = diag_scaled / diag_inches;
+
+      /* Pick the scale factor whose logical DPI is closest to the optimal value */
+      if (i == 0 || fabsf (dpi - target_dpi) < fabsf (best_dpi - target_dpi))
+        {
+          best_scale = scales[i];
+          best_dpi = dpi;
+        }
+    }
+
+  if (constraints & META_MONITOR_SCALES_CONSTRAINT_NO_FRAC)
+    {
+      best_scale = floorf (MIN (scales[n_scales - 1],
+                                best_scale + 0.25 + scale_epsilon));
+    }
+
+  return best_scale;
+}
+
+float
+meta_monitor_calculate_mode_scale (MetaMonitor                *monitor,
+                                   MetaMonitorMode            *monitor_mode,
+                                   MetaMonitorScalesConstraint constraints)
+{
+  MetaBackend *backend = meta_monitor_get_backend (monitor);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  int global_scaling_factor;
+
+  if (meta_settings_get_global_scaling_factor (settings,
+                                               &global_scaling_factor))
+    return global_scaling_factor;
+
+  return calculate_scale (monitor, monitor_mode, constraints);
+}
+
+static gboolean
+is_logical_size_large_enough (int width,
+                              int height)
+{
+  return width * height >= MINIMUM_LOGICAL_AREA;
+}
+
+static gboolean
+is_scale_valid_for_size (float width,
+                         float height,
+                         float scale)
+{
+  if (scale < MINIMUM_SCALE_FACTOR || scale > MAXIMUM_SCALE_FACTOR)
+    return FALSE;
+
+  return is_logical_size_large_enough (floorf (width / scale),
+                                       floorf (height / scale));
+}
+
+gboolean
+meta_monitor_mode_should_be_advertised (MetaMonitorMode *monitor_mode)
+{
+  MetaMonitorMode *preferred_mode;
+
+  g_return_val_if_fail (monitor_mode != NULL, FALSE);
+
+  preferred_mode = meta_monitor_get_preferred_mode (monitor_mode->monitor);
+  if (monitor_mode->spec.width == preferred_mode->spec.width &&
+      monitor_mode->spec.height == preferred_mode->spec.height)
+    return TRUE;
+
+  return is_logical_size_large_enough (monitor_mode->spec.width,
+                                       monitor_mode->spec.height);
+}
+
+static float
+get_closest_scale_factor_for_resolution (float width,
+                                         float height,
+                                         float scale,
+                                         float threshold)
+{
+  unsigned int i, j;
+  float scaled_h;
+  float scaled_w;
+  float best_scale;
+  int base_scaled_w;
+  gboolean found_one;
+
+  best_scale = 0;
+
+  if (!is_scale_valid_for_size (width, height, scale))
+    return best_scale;
+
+  if (fmodf (width, scale) == 0.0 && fmodf (height, scale) == 0.0)
+    return scale;
+
+  i = 0;
+  found_one = FALSE;
+  base_scaled_w = floorf (width / scale);
+
+  do
+    {
+      for (j = 0; j < 2; j++)
+        {
+          float current_scale;
+          int offset = i * (j ? 1 : -1);
+
+          scaled_w = base_scaled_w + offset;
+          current_scale = width / scaled_w;
+          scaled_h = height / current_scale;
+
+          if (current_scale >= scale + threshold ||
+              current_scale <= scale - threshold ||
+              current_scale < MINIMUM_SCALE_FACTOR ||
+              current_scale > MAXIMUM_SCALE_FACTOR)
+            {
+              return best_scale;
+            }
+
+          if (floorf (scaled_h) == scaled_h)
+            {
+              found_one = TRUE;
+
+              if (fabsf (current_scale - scale) < fabsf (best_scale - scale))
+                best_scale = current_scale;
+            }
+        }
+
+      i++;
+    }
+  while (!found_one);
+
+  return best_scale;
+}
+
+float *
+meta_monitor_calculate_supported_scales (MetaMonitor                 *monitor,
+                                         MetaMonitorMode             *monitor_mode,
+                                         MetaMonitorScalesConstraint  constraints,
+                                         int                         *n_supported_scales)
+{
+  unsigned int i, j;
+  int width, height;
+  GArray *supported_scales;
+
+  supported_scales = g_array_new (FALSE, FALSE, sizeof (float));
+
+  meta_monitor_mode_get_resolution (monitor_mode, &width, &height);
+
+  for (i = floorf (MINIMUM_SCALE_FACTOR);
+       i <= ceilf (MAXIMUM_SCALE_FACTOR);
+       i++)
+    {
+      if (constraints & META_MONITOR_SCALES_CONSTRAINT_NO_FRAC)
+        {
+          if (is_scale_valid_for_size (width, height, i))
+            {
+              float scale = i;
+              g_array_append_val (supported_scales, scale);
+            }
+        }
+      else
+        {
+          float max_bound;
+
+          if (i == floorf (MINIMUM_SCALE_FACTOR) ||
+              i == ceilf (MAXIMUM_SCALE_FACTOR))
+            max_bound = SCALE_FACTORS_STEPS;
+          else
+            max_bound = SCALE_FACTORS_STEPS / 2.0;
+
+          for (j = 0; j < SCALE_FACTORS_PER_INTEGER; j++)
+            {
+              float scale;
+              float scale_value = i + j * SCALE_FACTORS_STEPS;
+
+              scale = get_closest_scale_factor_for_resolution (width, height,
+                                                               scale_value,
+                                                               max_bound);
+              if (scale > 0.0)
+                g_array_append_val (supported_scales, scale);
+            }
+        }
+    }
+
+  if (supported_scales->len == 0)
+    {
+      float fallback_scale;
+
+      fallback_scale = 1.0;
+      g_array_append_val (supported_scales, fallback_scale);
+    }
+
+  *n_supported_scales = supported_scales->len;
+  return (float *) g_array_free (supported_scales, FALSE);
+}
+
+MetaMonitorModeSpec *
+meta_monitor_mode_get_spec (MetaMonitorMode *monitor_mode)
+{
+  return &monitor_mode->spec;
+}
+
+const char *
+meta_monitor_mode_get_id (MetaMonitorMode *monitor_mode)
+{
+  return monitor_mode->id;
+}
+
+void
+meta_monitor_mode_get_resolution (MetaMonitorMode *monitor_mode,
+                                  int             *width,
+                                  int             *height)
+{
+  *width = monitor_mode->spec.width;
+  *height = monitor_mode->spec.height;
+}
+
+float
+meta_monitor_mode_get_refresh_rate (MetaMonitorMode *monitor_mode)
+{
+  return monitor_mode->spec.refresh_rate;
+}
+
+MetaCrtcModeFlag
+meta_monitor_mode_get_flags (MetaMonitorMode *monitor_mode)
+{
+  return monitor_mode->spec.flags;
+}
+
+gboolean
+meta_monitor_mode_foreach_crtc (MetaMonitor          *monitor,
+                                MetaMonitorMode      *mode,
+                                MetaMonitorModeFunc   func,
+                                gpointer              user_data,
+                                GError              **error)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  GList *l;
+  int i;
+
+  for (l = monitor_priv->outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaMonitorCrtcMode *monitor_crtc_mode = &mode->crtc_modes[i];
+
+      if (!monitor_crtc_mode->crtc_mode)
+        continue;
+
+      if (!func (monitor, mode, monitor_crtc_mode, user_data, error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_monitor_mode_foreach_output (MetaMonitor          *monitor,
+                                  MetaMonitorMode      *mode,
+                                  MetaMonitorModeFunc   func,
+                                  gpointer              user_data,
+                                  GError              **error)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+  GList *l;
+  int i;
+
+  for (l = monitor_priv->outputs, i = 0; l; l = l->next, i++)
+    {
+      MetaMonitorCrtcMode *monitor_crtc_mode = &mode->crtc_modes[i];
+
+      if (!func (monitor, mode, monitor_crtc_mode, user_data, error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+const char *
+meta_monitor_get_display_name (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *monitor_priv =
+    meta_monitor_get_instance_private (monitor);
+
+  return monitor_priv->display_name;
+}
+
+void
+meta_monitor_set_logical_monitor (MetaMonitor        *monitor,
+                                  MetaLogicalMonitor *logical_monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  priv->logical_monitor = logical_monitor;
+}
+
+static MetaOutput *
+maybe_get_privacy_screen_output (MetaMonitor *monitor)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+
+  if (priv->outputs && priv->outputs->next)
+      return NULL;
+
+  return meta_monitor_get_main_output (monitor);
+}
+
+MetaPrivacyScreenState
+meta_monitor_get_privacy_screen_state (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = maybe_get_privacy_screen_output (monitor);
+
+  if (!output)
+    return META_PRIVACY_SCREEN_UNAVAILABLE;
+
+  return meta_output_get_privacy_screen_state (output);
+}
+
+gboolean
+meta_monitor_set_privacy_screen_enabled (MetaMonitor  *monitor,
+                                         gboolean      enabled,
+                                         GError      **error)
+{
+  MetaOutput *output;
+
+  output = maybe_get_privacy_screen_output (monitor);
+
+  if (!output)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                           "The privacy screen is not supported by this output");
+      return FALSE;
+    }
+
+  return meta_output_set_privacy_screen_enabled (output, enabled, error);
+}
+
+gboolean
+meta_monitor_set_color_space (MetaMonitor           *monitor,
+                              MetaOutputColorspace   color_space,
+                              GError               **error)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  GList *l;
+
+  for (l = priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+
+      if (!meta_output_is_color_space_supported (output, color_space))
+        {
+          g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                               "The color space is not supported by this monitor");
+          return FALSE;
+        }
+    }
+
+  for (l = priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+
+      meta_output_set_color_space (output, color_space);
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_monitor_set_hdr_metadata (MetaMonitor            *monitor,
+                               MetaOutputHdrMetadata  *metadata,
+                               GError                **error)
+{
+  MetaMonitorPrivate *priv = meta_monitor_get_instance_private (monitor);
+  GList *l;
+
+  for (l = priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+
+      if (!meta_output_is_hdr_metadata_supported (output, metadata->eotf))
+        {
+          g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                               "HDR metadata is not supported by this monitor");
+          return FALSE;
+        }
+    }
+
+  for (l = priv->outputs; l; l = l->next)
+    {
+      MetaOutput *output = l->data;
+
+      meta_output_set_hdr_metadata (output, metadata);
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_parse_monitor_mode (const char *string,
+                         int        *out_width,
+                         int        *out_height,
+                         float      *out_refresh_rate,
+                         float       fallback_refresh_rate)
+{
+  char *ptr = (char *) string;
+  int width, height;
+  float refresh_rate;
+
+  width = g_ascii_strtoull (ptr, &ptr, 10);
+  if (width == 0)
+    return FALSE;
+
+  if (ptr[0] != 'x')
+    return FALSE;
+  ptr++;
+
+  height = g_ascii_strtoull (ptr, &ptr, 10);
+  if (height == 0)
+    return FALSE;
+
+  if (ptr[0] == '\0')
+    {
+      refresh_rate = fallback_refresh_rate;
+      goto out;
+    }
+
+  if (ptr[0] != '@')
+    return FALSE;
+  ptr++;
+
+  refresh_rate = g_ascii_strtod (ptr, &ptr);
+  if (refresh_rate == 0.0)
+    return FALSE;
+
+  if (ptr[0] != '\0')
+    return FALSE;
+
+out:
+  *out_width = width;
+  *out_height = height;
+  *out_refresh_rate = refresh_rate;
+  return TRUE;
+}
diff '--color=auto' -uraN a/src/backends/meta-monitor.h b/src/backends/meta-monitor.h
--- a/src/backends/meta-monitor.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor.h	2023-10-12 20:59:22.677167288 +0300
@@ -118,6 +118,10 @@
 
 gboolean meta_monitor_is_underscanning (MetaMonitor *monitor);
 
+gboolean meta_monitor_is_vrr_capable (MetaMonitor *monitor);
+
+gboolean meta_monitor_is_vrr_disallowed (MetaMonitor *monitor);
+
 gboolean meta_monitor_get_max_bpc (MetaMonitor  *monitor,
                                    unsigned int *max_bpc);
 
diff '--color=auto' -uraN a/src/backends/meta-output.c b/src/backends/meta-output.c
--- a/src/backends/meta-output.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-output.c	2023-10-12 20:59:22.677167288 +0300
@@ -64,6 +64,8 @@
 
   gboolean is_underscanning;
 
+  gboolean is_vrr_disallowed;
+
   gboolean has_max_bpc;
   unsigned int max_bpc;
 
@@ -198,6 +200,22 @@
 }
 
 gboolean
+meta_output_is_vrr_capable (MetaOutput *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_output_is_vrr_disallowed (MetaOutput *output)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  return priv->is_vrr_disallowed;
+}
+
+gboolean
 meta_output_get_max_bpc (MetaOutput   *output,
                          unsigned int *max_bpc)
 {
@@ -268,6 +286,8 @@
   priv->is_presentation = output_assignment->is_presentation;
   priv->is_underscanning = output_assignment->is_underscanning;
 
+  priv->is_vrr_disallowed = output_assignment->is_vrr_disallowed;
+
   priv->has_max_bpc = output_assignment->has_max_bpc;
   if (priv->has_max_bpc)
     priv->max_bpc = output_assignment->max_bpc;
diff '--color=auto' -uraN a/src/backends/meta-output.h b/src/backends/meta-output.h
--- a/src/backends/meta-output.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-output.h	2023-10-12 20:59:22.677167288 +0300
@@ -144,6 +144,8 @@
   gboolean supports_underscanning;
   gboolean supports_color_transform;
 
+  gboolean vrr_capable;
+
   unsigned int max_bpc_min;
   unsigned int max_bpc_max;
 
@@ -228,6 +230,11 @@
 META_EXPORT_TEST
 gboolean meta_output_is_underscanning (MetaOutput *output);
 
+gboolean meta_output_is_vrr_capable (MetaOutput *output);
+
+META_EXPORT_TEST
+gboolean meta_output_is_vrr_disallowed (MetaOutput *output);
+
 META_EXPORT_TEST
 gboolean meta_output_get_max_bpc (MetaOutput   *output,
                                   unsigned int *max_bpc);
diff '--color=auto' -uraN a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
--- a/src/backends/meta-renderer-view.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-renderer-view.c	2023-10-12 20:59:22.677167288 +0300
@@ -33,6 +33,7 @@
 #include "backends/meta-renderer-view.h"
 
 #include "backends/meta-crtc.h"
+#include "backends/meta-output.h"
 #include "backends/meta-renderer.h"
 #include "clutter/clutter-mutter.h"
 #include "compositor/region-utils.h"
@@ -43,6 +44,7 @@
 
   PROP_TRANSFORM,
   PROP_CRTC,
+  PROP_OUTPUT,
 
   PROP_LAST
 };
@@ -54,6 +56,7 @@
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
+  MetaOutput *output;
 } MetaRendererViewPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (MetaRendererView, meta_renderer_view,
@@ -77,6 +80,15 @@
   return priv->crtc;
 }
 
+MetaOutput *
+meta_renderer_view_get_output (MetaRendererView *view)
+{
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->output;
+}
+
 static void
 meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
@@ -151,6 +163,9 @@
     case PROP_CRTC:
       g_value_set_object (value, priv->crtc);
       break;
+    case PROP_OUTPUT:
+      g_value_set_object (value, priv->output);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -175,6 +190,9 @@
     case PROP_CRTC:
       priv->crtc = g_value_get_object (value);
       break;
+    case PROP_OUTPUT:
+      priv->output = g_value_get_object (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -217,6 +235,15 @@
                          G_PARAM_READWRITE |
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_OUTPUT] =
+    g_param_spec_object ("output",
+                         "MetaOutput",
+                         "MetaOutput",
+                         META_TYPE_OUTPUT,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
 
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff '--color=auto' -uraN a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
--- a/src/backends/meta-renderer-view.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-renderer-view.h	2023-10-12 20:59:22.677167288 +0300
@@ -36,3 +36,5 @@
 
 META_EXPORT_TEST
 MetaCrtc *meta_renderer_view_get_crtc (MetaRendererView *view);
+
+MetaOutput *meta_renderer_view_get_output (MetaRendererView *view);
diff '--color=auto' -uraN a/src/backends/meta-settings-private.h b/src/backends/meta-settings-private.h
--- a/src/backends/meta-settings-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-settings-private.h	2023-10-12 21:03:16.293385387 +0300
@@ -29,9 +29,11 @@
 {
   META_EXPERIMENTAL_FEATURE_NONE = 0,
   META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER = (1 << 0),
-  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS  = (1 << 1),
+  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS = (1 << 1),
   META_EXPERIMENTAL_FEATURE_RT_SCHEDULER = (1 << 2),
-  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 4),
+  META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING  = (1 << 5),
 } MetaExperimentalFeature;
 
 typedef enum _MetaXwaylandExtension
@@ -40,6 +42,13 @@
   META_XWAYLAND_EXTENSION_XTEST = (1 << 1),
 } MetaXwaylandExtension;
 
+typedef enum _MetaX11ScaleMode
+{
+  META_X11_SCALE_MODE_NONE = 0,
+  META_X11_SCALE_MODE_UP = 1,
+  META_X11_SCALE_MODE_UI_DOWN = 2,
+} MetaX11ScaleMode;
+
 #define META_TYPE_SETTINGS (meta_settings_get_type ())
 G_DECLARE_FINAL_TYPE (MetaSettings, meta_settings,
                       META, SETTINGS, GObject)
@@ -80,3 +89,8 @@
 
 void meta_settings_set_privacy_screen_enabled (MetaSettings *settings,
                                                gboolean      enabled);
+
+MetaX11ScaleMode meta_settings_get_x11_scale_mode (MetaSettings *settings);
+
+void meta_settings_enable_x11_fractional_scaling (MetaSettings *settings,
+                                                  gboolean      enabled);
diff '--color=auto' -uraN a/src/backends/meta-settings-private.h.orig b/src/backends/meta-settings-private.h.orig
--- a/src/backends/meta-settings-private.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-settings-private.h.orig	2023-10-12 20:59:22.677167288 +0300
@@ -0,0 +1,83 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2017 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <glib-object.h>
+
+#include "meta/meta-settings.h"
+#include "meta/types.h"
+#include "core/util-private.h"
+
+typedef enum _MetaExperimentalFeature
+{
+  META_EXPERIMENTAL_FEATURE_NONE = 0,
+  META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER = (1 << 0),
+  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS = (1 << 1),
+  META_EXPERIMENTAL_FEATURE_RT_SCHEDULER = (1 << 2),
+  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 4),
+} MetaExperimentalFeature;
+
+typedef enum _MetaXwaylandExtension
+{
+  META_XWAYLAND_EXTENSION_SECURITY = (1 << 0),
+  META_XWAYLAND_EXTENSION_XTEST = (1 << 1),
+} MetaXwaylandExtension;
+
+#define META_TYPE_SETTINGS (meta_settings_get_type ())
+G_DECLARE_FINAL_TYPE (MetaSettings, meta_settings,
+                      META, SETTINGS, GObject)
+
+MetaSettings * meta_settings_new (MetaBackend *backend);
+
+void meta_settings_post_init (MetaSettings *settings);
+
+void meta_settings_update_ui_scaling_factor (MetaSettings *settings);
+
+gboolean meta_settings_get_global_scaling_factor (MetaSettings *settings,
+                                                  int          *scaing_factor);
+
+META_EXPORT_TEST
+gboolean meta_settings_is_experimental_feature_enabled (MetaSettings           *settings,
+                                                        MetaExperimentalFeature feature);
+
+MetaExperimentalFeature meta_settings_get_experimental_features (MetaSettings *settings);
+
+META_EXPORT_TEST
+void meta_settings_override_experimental_features (MetaSettings *settings);
+
+META_EXPORT_TEST
+void meta_settings_enable_experimental_feature (MetaSettings           *settings,
+                                                MetaExperimentalFeature feature);
+
+void meta_settings_get_xwayland_grab_patterns (MetaSettings  *settings,
+                                               GPtrArray    **allow_list_patterns,
+                                               GPtrArray    **deny_list_patterns);
+
+gboolean meta_settings_are_xwayland_grabs_allowed (MetaSettings *settings);
+
+int meta_settings_get_xwayland_disable_extensions (MetaSettings *settings);
+
+gboolean meta_settings_are_xwayland_byte_swapped_clients_allowed (MetaSettings *settings);
+
+gboolean meta_settings_is_privacy_screen_enabled (MetaSettings *settings);
+
+void meta_settings_set_privacy_screen_enabled (MetaSettings *settings,
+                                               gboolean      enabled);
diff '--color=auto' -uraN a/src/backends/meta-settings-private.h.rej b/src/backends/meta-settings-private.h.rej
--- a/src/backends/meta-settings-private.h.rej	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-settings-private.h.rej	2023-10-12 20:59:22.710501037 +0300
@@ -0,0 +1,15 @@
+--- src/backends/meta-settings-private.h
++++ src/backends/meta-settings-private.h
+@@ -29,9 +29,10 @@ typedef enum _MetaExperimentalFeature
+ {
+   META_EXPERIMENTAL_FEATURE_NONE = 0,
+   META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER = (1 << 0),
+-  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS  = (1 << 1),
++  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS = (1 << 1),
+   META_EXPERIMENTAL_FEATURE_RT_SCHEDULER = (1 << 2),
+-  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 3),
++  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND = (1 << 3),
++  META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING  = (1 << 4),
+ } MetaExperimentalFeature;
+ 
+ typedef enum _MetaXwaylandExtension
diff '--color=auto' -uraN a/src/backends/meta-settings.c b/src/backends/meta-settings.c
--- a/src/backends/meta-settings.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-settings.c	2023-10-12 21:01:20.838632873 +0300
@@ -37,6 +37,7 @@
   UI_SCALING_FACTOR_CHANGED,
   GLOBAL_SCALING_FACTOR_CHANGED,
   FONT_DPI_CHANGED,
+  X11_SCALE_MODE_CHANGED,
   EXPERIMENTAL_FEATURES_CHANGED,
   PRIVACY_SCREEN_CHANGED,
 
@@ -55,6 +56,7 @@
   GSettings *mutter_settings;
   GSettings *privacy_settings;
   GSettings *wayland_settings;
+  GSettings *x11_settings;
 
   int ui_scaling_factor;
   int global_scaling_factor;
@@ -75,6 +77,8 @@
 
   /* Whether Xwayland should allow X11 clients from different endianness */
   gboolean xwayland_allow_byte_swapped_clients;
+
+  MetaX11ScaleMode x11_scale_mode;
 };
 
 G_DEFINE_TYPE (MetaSettings, meta_settings, G_TYPE_OBJECT)
@@ -84,14 +88,39 @@
 {
   MetaMonitorManager *monitor_manager =
     meta_backend_get_monitor_manager (settings->backend);
-  MetaLogicalMonitor *primary_logical_monitor;
 
-  primary_logical_monitor =
-    meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
-  if (!primary_logical_monitor)
-    return 1;
+  if (!meta_is_wayland_compositor () &&
+      monitor_manager &&
+      (meta_monitor_manager_get_capabilities (monitor_manager) &
+       META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      MetaLogicalMonitorLayoutMode layout_mode =
+        meta_monitor_manager_get_default_layout_mode (monitor_manager);
+
+      if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+        {
+          return
+              ceilf (meta_monitor_manager_get_maximum_crtc_scale (monitor_manager));
+        }
+      else if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL)
+        {
+          return 1.0f;
+        }
+    }
+
+  if (monitor_manager)
+    {
+      MetaLogicalMonitor *primary_logical_monitor;
+
+      primary_logical_monitor =
+        meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
+      if (!primary_logical_monitor)
+        return 1;
+
+      return (int) meta_logical_monitor_get_scale (primary_logical_monitor);
+    }
 
-  return (int) meta_logical_monitor_get_scale (primary_logical_monitor);
+  return 1;
 }
 
 static gboolean
@@ -258,6 +287,76 @@
   settings->experimental_features_overridden = TRUE;
 }
 
+static gboolean
+update_x11_scale_mode (MetaSettings *settings)
+{
+  MetaX11ScaleMode scale_mode;
+
+  if (!(settings->experimental_features &
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    {
+      scale_mode = META_X11_SCALE_MODE_NONE;
+    }
+  else
+    {
+      scale_mode =
+        g_settings_get_enum (settings->x11_settings, "fractional-scale-mode");
+    }
+
+  if (settings->x11_scale_mode != scale_mode)
+    {
+      settings->x11_scale_mode = scale_mode;
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+void meta_settings_enable_x11_fractional_scaling (MetaSettings *settings,
+                                                  gboolean      enable)
+{
+  g_auto(GStrv) existing_features = NULL;
+  gboolean have_fractional_scaling = FALSE;
+  g_autoptr(GVariantBuilder) builder = NULL;
+  MetaExperimentalFeature old_experimental_features;
+
+  if (enable == meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    return;
+
+  /* Change the internal value now, as we don't want to wait for gsettings */
+  old_experimental_features = settings->experimental_features;
+  settings->experimental_features |=
+    META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING;
+
+  update_x11_scale_mode (settings);
+
+  g_signal_emit (settings, signals[EXPERIMENTAL_FEATURES_CHANGED], 0,
+                   (unsigned int) old_experimental_features);
+
+  /* Add or remove the fractional scaling feature from mutter */
+  existing_features = g_settings_get_strv (settings->mutter_settings,
+                                           "experimental-features");
+  builder = g_variant_builder_new (G_VARIANT_TYPE ("as"));
+  for (int i = 0; existing_features[i] != NULL; i++)
+    {
+      if (g_strcmp0 (existing_features[i], "x11-randr-fractional-scaling") == 0)
+        {
+          if (enable)
+            have_fractional_scaling = TRUE;
+          else
+            continue;
+        }
+
+      g_variant_builder_add (builder, "s", existing_features[i]);
+    }
+  if (enable && !have_fractional_scaling)
+    g_variant_builder_add (builder, "s", "x11-randr-fractional-scaling");
+
+  g_settings_set_value (settings->mutter_settings, "experimental-features",
+                        g_variant_builder_end (builder));
+}
+
 void
 meta_settings_enable_experimental_feature (MetaSettings           *settings,
                                            MetaExperimentalFeature feature)
@@ -265,6 +364,9 @@
   g_assert (settings->experimental_features_overridden);
 
   settings->experimental_features |= feature;
+
+  if (update_x11_scale_mode (settings))
+    g_signal_emit (settings, signals[X11_SCALE_MODE_CHANGED], 0, NULL);
 }
 
 static gboolean
@@ -296,6 +398,10 @@
         feature = META_EXPERIMENTAL_FEATURE_RT_SCHEDULER;
       else if (g_str_equal (feature_str, "autoclose-xwayland"))
         feature = META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND;
+      else if (g_str_equal (feature_str, "variable-refresh-rate"))
+        feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
+      else if (g_str_equal (feature_str, "x11-randr-fractional-scaling"))
+        feature = META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING;
 
       if (feature)
         g_message ("Enabling experimental feature '%s'", feature_str);
@@ -308,6 +414,7 @@
   if (features != settings->experimental_features)
     {
       settings->experimental_features = features;
+      update_x11_scale_mode (settings);
       *result = GINT_TO_POINTER (TRUE);
     }
   else
@@ -462,6 +569,18 @@
     }
 }
 
+static void
+x11_settings_changed (GSettings    *wayland_settings,
+                      gchar        *key,
+                      MetaSettings *settings)
+{
+  if (g_str_equal (key, "fractional-scale-mode"))
+    {
+      if (update_x11_scale_mode (settings))
+        g_signal_emit (settings, signals[X11_SCALE_MODE_CHANGED], 0, NULL);
+    }
+}
+
 void
 meta_settings_get_xwayland_grab_patterns (MetaSettings  *settings,
                                           GPtrArray    **allow_list_patterns,
@@ -507,6 +626,12 @@
                           enabled);
 }
 
+MetaX11ScaleMode
+meta_settings_get_x11_scale_mode (MetaSettings *settings)
+{
+  return settings->x11_scale_mode;
+}
+
 MetaSettings *
 meta_settings_new (MetaBackend *backend)
 {
@@ -527,6 +652,7 @@
   g_clear_object (&settings->interface_settings);
   g_clear_object (&settings->privacy_settings);
   g_clear_object (&settings->wayland_settings);
+  g_clear_object (&settings->x11_settings);
   g_clear_pointer (&settings->xwayland_grab_allow_list_patterns,
                    g_ptr_array_unref);
   g_clear_pointer (&settings->xwayland_grab_deny_list_patterns,
@@ -554,6 +680,10 @@
   g_signal_connect (settings->wayland_settings, "changed",
                     G_CALLBACK (wayland_settings_changed),
                     settings);
+  settings->x11_settings = g_settings_new ("org.gnome.mutter.x11");
+  g_signal_connect (settings->x11_settings, "changed",
+                    G_CALLBACK (x11_settings_changed),
+                    settings);
 
   /* Chain up inter-dependent settings. */
   g_signal_connect (settings, "global-scaling-factor-changed",
@@ -619,6 +749,14 @@
                   G_TYPE_FROM_CLASS (object_class),
                   G_SIGNAL_RUN_LAST,
                   0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[X11_SCALE_MODE_CHANGED] =
+    g_signal_new ("x11-scale-mode-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
                   NULL, NULL, NULL,
                   G_TYPE_NONE, 0);
 
diff '--color=auto' -uraN a/src/backends/meta-settings.c.orig b/src/backends/meta-settings.c.orig
--- a/src/backends/meta-settings.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-settings.c.orig	2023-10-12 20:59:22.677167288 +0300
@@ -0,0 +1,642 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2017 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/meta-settings-private.h"
+
+#include <gio/gio.h>
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-logical-monitor.h"
+#include "backends/meta-monitor-manager-private.h"
+
+#ifndef XWAYLAND_GRAB_DEFAULT_ACCESS_RULES
+# warning "XWAYLAND_GRAB_DEFAULT_ACCESS_RULES is not set"
+# define  XWAYLAND_GRAB_DEFAULT_ACCESS_RULES ""
+#endif
+
+enum
+{
+  UI_SCALING_FACTOR_CHANGED,
+  GLOBAL_SCALING_FACTOR_CHANGED,
+  FONT_DPI_CHANGED,
+  EXPERIMENTAL_FEATURES_CHANGED,
+  PRIVACY_SCREEN_CHANGED,
+
+  N_SIGNALS
+};
+
+static guint signals[N_SIGNALS];
+
+struct _MetaSettings
+{
+  GObject parent;
+
+  MetaBackend *backend;
+
+  GSettings *interface_settings;
+  GSettings *mutter_settings;
+  GSettings *privacy_settings;
+  GSettings *wayland_settings;
+
+  int ui_scaling_factor;
+  int global_scaling_factor;
+
+  int font_dpi;
+
+  gboolean privacy_screen;
+
+  MetaExperimentalFeature experimental_features;
+  gboolean experimental_features_overridden;
+
+  gboolean xwayland_allow_grabs;
+  GPtrArray *xwayland_grab_allow_list_patterns;
+  GPtrArray *xwayland_grab_deny_list_patterns;
+
+  /* A bitmask of MetaXwaylandExtension enum */
+  int xwayland_disable_extensions;
+
+  /* Whether Xwayland should allow X11 clients from different endianness */
+  gboolean xwayland_allow_byte_swapped_clients;
+};
+
+G_DEFINE_TYPE (MetaSettings, meta_settings, G_TYPE_OBJECT)
+
+static int
+calculate_ui_scaling_factor (MetaSettings *settings)
+{
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (settings->backend);
+  MetaLogicalMonitor *primary_logical_monitor;
+
+  primary_logical_monitor =
+    meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
+  if (!primary_logical_monitor)
+    return 1;
+
+  return (int) meta_logical_monitor_get_scale (primary_logical_monitor);
+}
+
+static gboolean
+update_ui_scaling_factor (MetaSettings *settings)
+{
+  int ui_scaling_factor;
+
+  if (meta_backend_is_stage_views_scaled (settings->backend))
+    ui_scaling_factor = 1;
+  else
+    ui_scaling_factor = calculate_ui_scaling_factor (settings);
+
+  if (settings->ui_scaling_factor != ui_scaling_factor)
+    {
+      settings->ui_scaling_factor = ui_scaling_factor;
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+}
+
+void
+meta_settings_update_ui_scaling_factor (MetaSettings *settings)
+{
+  if (update_ui_scaling_factor (settings))
+    g_signal_emit (settings, signals[UI_SCALING_FACTOR_CHANGED], 0);
+}
+
+int
+meta_settings_get_ui_scaling_factor (MetaSettings *settings)
+{
+  g_assert (settings->ui_scaling_factor != 0);
+
+  return settings->ui_scaling_factor;
+}
+
+static gboolean
+update_global_scaling_factor (MetaSettings *settings)
+{
+  int global_scaling_factor;
+
+  global_scaling_factor =
+    (int) g_settings_get_uint (settings->interface_settings,
+                               "scaling-factor");
+
+  if (settings->global_scaling_factor != global_scaling_factor)
+    {
+      settings->global_scaling_factor = global_scaling_factor;
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+}
+
+gboolean
+meta_settings_get_global_scaling_factor (MetaSettings *settings,
+                                         int          *out_scaling_factor)
+{
+  if (settings->global_scaling_factor == 0)
+    return FALSE;
+
+  *out_scaling_factor = settings->global_scaling_factor;
+  return TRUE;
+}
+
+static gboolean
+update_font_dpi (MetaSettings *settings)
+{
+  double text_scaling_factor;
+  /* Number of logical pixels on an inch when unscaled */
+  const double dots_per_inch = 96;
+  /* Being based on Xft, API users expect the DPI to be 1/1024th of an inch. */
+  const double xft_factor = 1024;
+  int font_dpi;
+
+  text_scaling_factor = g_settings_get_double (settings->interface_settings,
+                                               "text-scaling-factor");
+  font_dpi = (int) (text_scaling_factor *
+                    dots_per_inch *
+                    xft_factor *
+                    settings->ui_scaling_factor);
+
+  if (font_dpi != settings->font_dpi)
+    {
+      settings->font_dpi = font_dpi;
+
+      g_object_set (clutter_settings_get_default (),
+                    "font-dpi", font_dpi,
+                    NULL);
+
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+}
+
+static void
+meta_settings_update_font_dpi (MetaSettings *settings)
+{
+  if (update_font_dpi (settings))
+    g_signal_emit (settings, signals[FONT_DPI_CHANGED], 0);
+}
+
+int
+meta_settings_get_font_dpi (MetaSettings *settings)
+{
+  g_assert (settings->font_dpi != 0);
+
+  return settings->font_dpi;
+}
+
+static void
+interface_settings_changed (GSettings    *interface_settings,
+                            const char   *key,
+                            MetaSettings *settings)
+{
+  if (g_str_equal (key, "scaling-factor"))
+    {
+      if (update_global_scaling_factor (settings))
+        g_signal_emit (settings, signals[GLOBAL_SCALING_FACTOR_CHANGED], 0);
+    }
+  else if (g_str_equal (key, "text-scaling-factor"))
+    {
+      meta_settings_update_font_dpi (settings);
+    }
+}
+
+static void
+privacy_settings_changed (GSettings    *privacy_settings,
+                          const char   *key,
+                          MetaSettings *settings)
+{
+  if (g_str_equal (key, "privacy-screen"))
+    {
+      gboolean privacy_screen;
+
+      privacy_screen = g_settings_get_boolean (privacy_settings, key);
+
+      if (settings->privacy_screen != privacy_screen)
+        {
+          settings->privacy_screen = privacy_screen;
+          g_signal_emit (settings, signals[PRIVACY_SCREEN_CHANGED], 0);
+        }
+    }
+}
+
+gboolean
+meta_settings_is_experimental_feature_enabled (MetaSettings           *settings,
+                                               MetaExperimentalFeature feature)
+{
+  return !!(settings->experimental_features & feature);
+}
+
+void
+meta_settings_override_experimental_features (MetaSettings *settings)
+{
+  settings->experimental_features = META_EXPERIMENTAL_FEATURE_NONE;
+  settings->experimental_features_overridden = TRUE;
+}
+
+void
+meta_settings_enable_experimental_feature (MetaSettings           *settings,
+                                           MetaExperimentalFeature feature)
+{
+  g_assert (settings->experimental_features_overridden);
+
+  settings->experimental_features |= feature;
+}
+
+static gboolean
+experimental_features_handler (GVariant *features_variant,
+                               gpointer *result,
+                               gpointer  data)
+{
+  MetaSettings *settings = data;
+  GVariantIter features_iter;
+  char *feature_str;
+  MetaExperimentalFeature features = META_EXPERIMENTAL_FEATURE_NONE;
+
+  if (settings->experimental_features_overridden)
+    {
+      *result = GINT_TO_POINTER (FALSE);
+      return TRUE;
+    }
+
+  g_variant_iter_init (&features_iter, features_variant);
+  while (g_variant_iter_loop (&features_iter, "s", &feature_str))
+    {
+      MetaExperimentalFeature feature = META_EXPERIMENTAL_FEATURE_NONE;
+
+      if (g_str_equal (feature_str, "scale-monitor-framebuffer"))
+        feature = META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER;
+      else if (g_str_equal (feature_str, "kms-modifiers"))
+        feature = META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS;
+      else if (g_str_equal (feature_str, "rt-scheduler"))
+        feature = META_EXPERIMENTAL_FEATURE_RT_SCHEDULER;
+      else if (g_str_equal (feature_str, "autoclose-xwayland"))
+        feature = META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND;
+      else if (g_str_equal (feature_str, "variable-refresh-rate"))
+        feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
+
+      if (feature)
+        g_message ("Enabling experimental feature '%s'", feature_str);
+      else
+        g_warning ("Unknown experimental feature '%s'", feature_str);
+
+      features |= feature;
+    }
+
+  if (features != settings->experimental_features)
+    {
+      settings->experimental_features = features;
+      *result = GINT_TO_POINTER (TRUE);
+    }
+  else
+    {
+      *result = GINT_TO_POINTER (FALSE);
+    }
+
+  return TRUE;
+}
+
+static gboolean
+update_experimental_features (MetaSettings *settings)
+{
+  return GPOINTER_TO_INT (g_settings_get_mapped (settings->mutter_settings,
+                                                 "experimental-features",
+                                                 experimental_features_handler,
+                                                 settings));
+}
+
+static void
+mutter_settings_changed (GSettings    *mutter_settings,
+                         gchar        *key,
+                         MetaSettings *settings)
+{
+  MetaExperimentalFeature old_experimental_features;
+
+  if (!g_str_equal (key, "experimental-features"))
+    return;
+
+  old_experimental_features = settings->experimental_features;
+  if (update_experimental_features (settings))
+    g_signal_emit (settings, signals[EXPERIMENTAL_FEATURES_CHANGED], 0,
+                   (unsigned int) old_experimental_features);
+}
+
+static void
+xwayland_grab_list_add_item (MetaSettings *settings,
+                             char         *item)
+{
+  /* If first character is '!', it's a denied value */
+  if (item[0] != '!')
+    g_ptr_array_add (settings->xwayland_grab_allow_list_patterns,
+                     g_pattern_spec_new (item));
+  else if (item[1] != 0)
+    g_ptr_array_add (settings->xwayland_grab_deny_list_patterns,
+                     g_pattern_spec_new (&item[1]));
+}
+
+static gboolean
+xwayland_grab_access_rules_handler (GVariant *variant,
+                                    gpointer *result,
+                                    gpointer  data)
+{
+  MetaSettings *settings = data;
+  GVariantIter iter;
+  char *item;
+
+  /* Create a GPatternSpec for each element */
+  g_variant_iter_init (&iter, variant);
+  while (g_variant_iter_loop (&iter, "s", &item))
+    xwayland_grab_list_add_item (settings, item);
+
+  *result = GINT_TO_POINTER (TRUE);
+
+  return TRUE;
+}
+
+static void
+update_xwayland_grab_access_rules (MetaSettings *settings)
+{
+  gchar **system_defaults;
+  int i;
+
+  /* Free previous patterns and create new arrays */
+  g_clear_pointer (&settings->xwayland_grab_allow_list_patterns,
+                   g_ptr_array_unref);
+  settings->xwayland_grab_allow_list_patterns =
+    g_ptr_array_new_with_free_func ((GDestroyNotify) g_pattern_spec_free);
+
+  g_clear_pointer (&settings->xwayland_grab_deny_list_patterns,
+                   g_ptr_array_unref);
+  settings->xwayland_grab_deny_list_patterns =
+    g_ptr_array_new_with_free_func ((GDestroyNotify) g_pattern_spec_free);
+
+  /* Add system defaults values */
+  system_defaults = g_strsplit (XWAYLAND_GRAB_DEFAULT_ACCESS_RULES, ",", -1);
+  for (i = 0; system_defaults[i]; i++)
+    xwayland_grab_list_add_item (settings, system_defaults[i]);
+  g_strfreev (system_defaults);
+
+  /* Then add gsettings values */
+  g_settings_get_mapped (settings->wayland_settings,
+                         "xwayland-grab-access-rules",
+                         xwayland_grab_access_rules_handler,
+                         settings);
+}
+
+static void
+update_xwayland_allow_grabs (MetaSettings *settings)
+{
+  settings->xwayland_allow_grabs =
+    g_settings_get_boolean (settings->wayland_settings,
+                            "xwayland-allow-grabs");
+}
+
+static void
+update_xwayland_disable_extensions (MetaSettings *settings)
+{
+  settings->xwayland_disable_extensions =
+    g_settings_get_flags (settings->wayland_settings,
+                          "xwayland-disable-extension");
+}
+
+static void
+update_privacy_settings (MetaSettings *settings)
+{
+  privacy_settings_changed (settings->privacy_settings,
+                            "privacy-screen",
+                            settings);
+}
+
+static void
+update_xwayland_allow_byte_swapped_clients (MetaSettings *settings)
+{
+
+  settings->xwayland_allow_byte_swapped_clients =
+    g_settings_get_boolean (settings->wayland_settings,
+                            "xwayland-allow-byte-swapped-clients");
+}
+
+static void
+wayland_settings_changed (GSettings    *wayland_settings,
+                          gchar        *key,
+                          MetaSettings *settings)
+{
+
+  if (g_str_equal (key, "xwayland-allow-grabs"))
+    {
+      update_xwayland_allow_grabs (settings);
+    }
+  else if (g_str_equal (key, "xwayland-grab-access-rules"))
+    {
+      update_xwayland_grab_access_rules (settings);
+    }
+  else if (g_str_equal (key, "xwayland-disable-extension"))
+    {
+      update_xwayland_disable_extensions (settings);
+    }
+  else if (g_str_equal (key, "xwayland-allow-byte-swapped-clients"))
+    {
+      update_xwayland_allow_byte_swapped_clients (settings);
+    }
+}
+
+void
+meta_settings_get_xwayland_grab_patterns (MetaSettings  *settings,
+                                          GPtrArray    **allow_list_patterns,
+                                          GPtrArray    **deny_list_patterns)
+{
+  *allow_list_patterns = settings->xwayland_grab_allow_list_patterns;
+  *deny_list_patterns = settings->xwayland_grab_deny_list_patterns;
+}
+
+gboolean
+meta_settings_are_xwayland_grabs_allowed (MetaSettings *settings)
+{
+  return (settings->xwayland_allow_grabs);
+}
+
+int
+meta_settings_get_xwayland_disable_extensions (MetaSettings *settings)
+{
+  return (settings->xwayland_disable_extensions);
+}
+
+gboolean
+meta_settings_are_xwayland_byte_swapped_clients_allowed (MetaSettings *settings)
+{
+  return settings->xwayland_allow_byte_swapped_clients;
+}
+
+gboolean
+meta_settings_is_privacy_screen_enabled (MetaSettings *settings)
+{
+  return settings->privacy_screen;
+}
+
+void
+meta_settings_set_privacy_screen_enabled (MetaSettings *settings,
+                                          gboolean      enabled)
+{
+  if (settings->privacy_screen == enabled)
+    return;
+
+  settings->privacy_screen = enabled;
+  g_settings_set_boolean (settings->privacy_settings, "privacy-screen",
+                          enabled);
+}
+
+MetaSettings *
+meta_settings_new (MetaBackend *backend)
+{
+  MetaSettings *settings;
+
+  settings = g_object_new (META_TYPE_SETTINGS, NULL);
+  settings->backend = backend;
+
+  return settings;
+}
+
+static void
+meta_settings_dispose (GObject *object)
+{
+  MetaSettings *settings = META_SETTINGS (object);
+
+  g_clear_object (&settings->mutter_settings);
+  g_clear_object (&settings->interface_settings);
+  g_clear_object (&settings->privacy_settings);
+  g_clear_object (&settings->wayland_settings);
+  g_clear_pointer (&settings->xwayland_grab_allow_list_patterns,
+                   g_ptr_array_unref);
+  g_clear_pointer (&settings->xwayland_grab_deny_list_patterns,
+                   g_ptr_array_unref);
+
+  G_OBJECT_CLASS (meta_settings_parent_class)->dispose (object);
+}
+
+static void
+meta_settings_init (MetaSettings *settings)
+{
+  settings->interface_settings = g_settings_new ("org.gnome.desktop.interface");
+  g_signal_connect (settings->interface_settings, "changed",
+                    G_CALLBACK (interface_settings_changed),
+                    settings);
+  settings->privacy_settings = g_settings_new ("org.gnome.desktop.privacy");
+  g_signal_connect (settings->privacy_settings, "changed",
+                    G_CALLBACK (privacy_settings_changed),
+                    settings);
+  settings->mutter_settings = g_settings_new ("org.gnome.mutter");
+  g_signal_connect (settings->mutter_settings, "changed",
+                    G_CALLBACK (mutter_settings_changed),
+                    settings);
+  settings->wayland_settings = g_settings_new ("org.gnome.mutter.wayland");
+  g_signal_connect (settings->wayland_settings, "changed",
+                    G_CALLBACK (wayland_settings_changed),
+                    settings);
+
+  /* Chain up inter-dependent settings. */
+  g_signal_connect (settings, "global-scaling-factor-changed",
+                    G_CALLBACK (meta_settings_update_ui_scaling_factor), NULL);
+  g_signal_connect (settings, "ui-scaling-factor-changed",
+                    G_CALLBACK (meta_settings_update_font_dpi), NULL);
+
+  update_global_scaling_factor (settings);
+  update_experimental_features (settings);
+  update_xwayland_grab_access_rules (settings);
+  update_xwayland_allow_grabs (settings);
+  update_xwayland_disable_extensions (settings);
+  update_privacy_settings (settings);
+  update_xwayland_allow_byte_swapped_clients (settings);
+}
+
+static void
+on_monitors_changed (MetaMonitorManager *monitor_manager,
+                     MetaSettings       *settings)
+{
+  meta_settings_update_ui_scaling_factor (settings);
+}
+
+void
+meta_settings_post_init (MetaSettings *settings)
+{
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (settings->backend);
+
+  update_ui_scaling_factor (settings);
+  update_font_dpi (settings);
+
+  g_signal_connect_object (monitor_manager, "monitors-changed-internal",
+                           G_CALLBACK (on_monitors_changed),
+                           settings, G_CONNECT_AFTER);
+}
+
+static void
+meta_settings_class_init (MetaSettingsClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_settings_dispose;
+
+  signals[UI_SCALING_FACTOR_CHANGED] =
+    g_signal_new ("ui-scaling-factor-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[GLOBAL_SCALING_FACTOR_CHANGED] =
+    g_signal_new ("global-scaling-factor-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[FONT_DPI_CHANGED] =
+    g_signal_new ("font-dpi-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[EXPERIMENTAL_FEATURES_CHANGED] =
+    g_signal_new ("experimental-features-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1, G_TYPE_UINT);
+
+  signals[PRIVACY_SCREEN_CHANGED] =
+    g_signal_new ("privacy-screen-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
diff '--color=auto' -uraN a/src/backends/meta-settings.c.rej b/src/backends/meta-settings.c.rej
--- a/src/backends/meta-settings.c.rej	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/meta-settings.c.rej	2023-10-12 20:59:22.710501037 +0300
@@ -0,0 +1,11 @@
+--- src/backends/meta-settings.c
++++ src/backends/meta-settings.c
+@@ -398,6 +500,8 @@ experimental_features_handler (GVariant *features_variant,
+         feature = META_EXPERIMENTAL_FEATURE_RT_SCHEDULER;
+       else if (g_str_equal (feature_str, "autoclose-xwayland"))
+         feature = META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND;
++      else if (g_str_equal (feature_str, "x11-randr-fractional-scaling"))
++        feature = META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING;
+ 
+       if (feature)
+         g_message ("Enabling experimental feature '%s'", feature_str);
diff '--color=auto' -uraN a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
--- a/src/backends/native/meta-backend-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-backend-native.c	2023-10-12 20:59:22.680500663 +0300
@@ -592,6 +592,9 @@
   if (meta_is_udev_device_disable_modifiers (device))
     flags |= META_KMS_DEVICE_FLAG_DISABLE_MODIFIERS;
 
+  if (meta_is_udev_device_disable_vrr (device))
+    flags |= META_KMS_DEVICE_FLAG_DISABLE_VRR;
+
   if (meta_is_udev_device_preferred_primary (device))
     flags |= META_KMS_DEVICE_FLAG_PREFERRED_PRIMARY;
 
diff '--color=auto' -uraN a/src/backends/native/meta-gpu-kms.c b/src/backends/native/meta-gpu-kms.c
--- a/src/backends/native/meta-gpu-kms.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-gpu-kms.c	2023-10-12 20:59:22.680500663 +0300
@@ -132,6 +132,23 @@
   return !!(flags & META_KMS_DEVICE_FLAG_PLATFORM_DEVICE);
 }
 
+gboolean
+meta_gpu_kms_disable_vrr (MetaGpuKms *gpu_kms)
+{
+  MetaGpu *gpu = META_GPU (gpu_kms);
+  MetaBackend *backend = meta_gpu_get_backend (gpu);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaKmsDeviceFlag flags;
+
+  if (!meta_settings_is_experimental_feature_enabled (
+        settings,
+        META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE))
+    return TRUE;
+
+  flags = meta_kms_device_get_flags (gpu_kms->kms_device);
+  return !!(flags & META_KMS_DEVICE_FLAG_DISABLE_VRR);
+}
+
 static int
 compare_outputs (gconstpointer one,
                  gconstpointer two)
diff '--color=auto' -uraN a/src/backends/native/meta-gpu-kms.h b/src/backends/native/meta-gpu-kms.h
--- a/src/backends/native/meta-gpu-kms.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-gpu-kms.h	2023-10-12 20:59:22.680500663 +0300
@@ -44,6 +44,7 @@
 
 gboolean meta_gpu_kms_is_boot_vga (MetaGpuKms *gpu_kms);
 gboolean meta_gpu_kms_is_platform_device (MetaGpuKms *gpu_kms);
+gboolean meta_gpu_kms_disable_vrr (MetaGpuKms *gpu_kms);
 
 MetaKmsDevice * meta_gpu_kms_get_kms_device (MetaGpuKms *gpu_kms);
 
diff '--color=auto' -uraN a/src/backends/native/meta-kms-connector-private.h b/src/backends/native/meta-kms-connector-private.h
--- a/src/backends/native/meta-kms-connector-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector-private.h	2023-10-12 20:59:22.680500663 +0300
@@ -39,6 +39,7 @@
   META_KMS_CONNECTOR_PROP_MAX_BPC,
   META_KMS_CONNECTOR_PROP_COLORSPACE,
   META_KMS_CONNECTOR_PROP_HDR_OUTPUT_METADATA,
+  META_KMS_CONNECTOR_PROP_VRR_CAPABLE,
   META_KMS_CONNECTOR_N_PROPS
 } MetaKmsConnectorProp;
 
diff '--color=auto' -uraN a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
--- a/src/backends/native/meta-kms-connector.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector.c	2023-10-12 20:59:22.680500663 +0300
@@ -408,6 +408,10 @@
       state->colorspace.supported =
         supported_drm_color_spaces_to_output_color_spaces (prop->supported_variants);
     }
+
+  prop = &props[META_KMS_CONNECTOR_PROP_VRR_CAPABLE];
+  if (prop->prop_id)
+    state->vrr_capable = prop->value;
 }
 
 static CoglSubpixelOrder
@@ -840,6 +844,7 @@
   state = g_new0 (MetaKmsConnectorState, 1);
   state->suggested_x = -1;
   state->suggested_y = -1;
+  state->vrr_capable = FALSE;
 
   return state;
 }
@@ -1013,6 +1018,9 @@
       !hdr_metadata_equal (&state->hdr.value, &new_state->hdr.value))
     return META_KMS_RESOURCE_CHANGE_FULL;
 
+  if (state->vrr_capable != new_state->vrr_capable)
+    return META_KMS_RESOURCE_CHANGE_FULL;
+
   if (state->privacy_screen_state != new_state->privacy_screen_state)
     return META_KMS_RESOURCE_CHANGE_PRIVACY_SCREEN;
 
@@ -1357,6 +1365,11 @@
           .name = "HDR_OUTPUT_METADATA",
           .type = DRM_MODE_PROP_BLOB,
         },
+      [META_KMS_CONNECTOR_PROP_VRR_CAPABLE] =
+        {
+          .name = "vrr_capable",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     },
     .dpms_enum = {
       [META_KMS_CONNECTOR_DPMS_ON] =
diff '--color=auto' -uraN a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
--- a/src/backends/native/meta-kms-connector.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector.h	2023-10-12 20:59:22.680500663 +0300
@@ -69,6 +69,8 @@
     gboolean supported;
     gboolean unknown;
   } hdr;
+
+  gboolean vrr_capable;
 } MetaKmsConnectorState;
 
 META_EXPORT_TEST
diff '--color=auto' -uraN a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
--- a/src/backends/native/meta-kms-crtc-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-crtc-private.h	2023-10-12 20:59:22.680500663 +0300
@@ -28,9 +28,17 @@
   META_KMS_CRTC_PROP_ACTIVE,
   META_KMS_CRTC_PROP_GAMMA_LUT,
   META_KMS_CRTC_PROP_GAMMA_LUT_SIZE,
+  META_KMS_CRTC_PROP_VRR_ENABLED,
   META_KMS_CRTC_N_PROPS
 } MetaKmsCrtcProp;
 
+typedef enum _MetaKmsCrtcVRRMode
+{
+  META_KMS_CRTC_VRR_MODE_DISABLED = 0,
+  META_KMS_CRTC_VRR_MODE_ENABLED,
+  META_KMS_CRTC_VRR_MODE_N_PROPS,
+} MetaKmsCrtcVRRMode;
+
 MetaKmsCrtc * meta_kms_crtc_new (MetaKmsImplDevice  *impl_device,
                                  drmModeCrtc        *drm_crtc,
                                  int                 idx,
diff '--color=auto' -uraN a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
--- a/src/backends/native/meta-kms-crtc.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-crtc.c	2023-10-12 20:59:22.680500663 +0300
@@ -427,6 +427,11 @@
           .name = "GAMMA_LUT_SIZE",
           .type = DRM_MODE_PROP_RANGE,
         },
+      [META_KMS_CRTC_PROP_VRR_ENABLED] =
+        {
+          .name = "VRR_ENABLED",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     }
   };
 }
diff '--color=auto' -uraN a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
--- a/src/backends/native/meta-kms-impl-device-atomic.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-impl-device-atomic.c	2023-10-12 20:59:22.680500663 +0300
@@ -334,6 +334,39 @@
 }
 
 static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     drmModeAtomicReq   *req,
+                     GArray             *blob_ids,
+                     gpointer            update_entry,
+                     gpointer            user_data,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Setting VRR mode to %d on CRTC %u (%s)",
+                  crtc_update->vrr_mode.is_enabled ?
+                    META_KMS_CRTC_VRR_MODE_ENABLED :
+                    META_KMS_CRTC_VRR_MODE_DISABLED,
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              crtc_update->vrr_mode.is_enabled,
+                              error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
 process_mode_set (MetaKmsImplDevice  *impl_device,
                   MetaKmsUpdate      *update,
                   drmModeAtomicReq   *req,
@@ -986,6 +1019,16 @@
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        req,
+                        blob_ids,
+                        meta_kms_update_get_crtc_updates (update),
+                        NULL,
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         req,
diff '--color=auto' -uraN a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
--- a/src/backends/native/meta-kms-impl-device-simple.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-impl-device-simple.c	2023-10-12 20:59:22.683834037 +0300
@@ -180,6 +180,47 @@
 }
 
 static gboolean
+set_crtc_property (MetaKmsImplDevice  *impl_device,
+                   MetaKmsCrtc        *crtc,
+                   MetaKmsCrtcProp     prop,
+                   uint64_t            value,
+                   GError            **error)
+{
+  uint32_t prop_id;
+  int fd;
+  int ret;
+
+  prop_id = meta_kms_crtc_get_prop_id (crtc, prop);
+  if (!prop_id)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Property (%s) not found on CRTC %u",
+                   meta_kms_crtc_get_prop_name (crtc, prop),
+                   meta_kms_crtc_get_id (crtc));
+      return FALSE;
+    }
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+
+  ret = drmModeObjectSetProperty (fd,
+                                  meta_kms_crtc_get_id (crtc),
+                                  DRM_MODE_OBJECT_CRTC,
+                                  prop_id,
+                                  value);
+  if (ret != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-ret),
+                   "Failed to set CRTC %u property %u: %s",
+                   meta_kms_crtc_get_id (crtc),
+                   prop_id,
+                   g_strerror (-ret));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
 process_connector_update (MetaKmsImplDevice  *impl_device,
                           MetaKmsUpdate      *update,
                           gpointer            update_entry,
@@ -268,6 +309,36 @@
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     gpointer            update_entry,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Setting VRR mode to %d on CRTC %u (%s)",
+                  crtc_update->vrr_mode.is_enabled ?
+                    META_KMS_CRTC_VRR_MODE_ENABLED :
+                    META_KMS_CRTC_VRR_MODE_DISABLED,
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              crtc_update->vrr_mode.is_enabled,
+                              error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
 static CachedModeSet *
 cached_mode_set_new (GList                 *connectors,
                      const drmModeModeInfo *drm_mode,
@@ -1522,6 +1593,13 @@
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        meta_kms_update_get_crtc_updates (update),
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_plane_assignments (impl_device, update, &failed_planes, &error))
     goto err;
 
diff '--color=auto' -uraN a/src/backends/native/meta-kms-types.h b/src/backends/native/meta-kms-types.h
--- a/src/backends/native/meta-kms-types.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-types.h	2023-10-12 20:59:22.683834037 +0300
@@ -64,6 +64,7 @@
   META_KMS_DEVICE_FLAG_HAS_ADDFB2 = 1 << 5,
   META_KMS_DEVICE_FLAG_FORCE_LEGACY = 1 << 6,
   META_KMS_DEVICE_FLAG_DISABLE_CLIENT_MODIFIERS = 1 << 7,
+  META_KMS_DEVICE_FLAG_DISABLE_VRR = 1 << 8,
 } MetaKmsDeviceFlag;
 
 typedef enum _MetaKmsResourceChanges
diff '--color=auto' -uraN a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
--- a/src/backends/native/meta-kms-update-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update-private.h	2023-10-12 20:59:22.683834037 +0300
@@ -111,6 +111,16 @@
   } hdr;
 } MetaKmsConnectorUpdate;
 
+typedef struct _MetaKmsCrtcUpdate
+{
+  MetaKmsCrtc *crtc;
+
+  struct {
+    gboolean has_update;
+    gboolean is_enabled;
+  } vrr_mode;
+} MetaKmsCrtcUpdate;
+
 typedef struct _MetaKmsPageFlipListener
 {
   gatomicrefcount ref_count;
@@ -178,6 +188,9 @@
 GList * meta_kms_update_get_connector_updates (MetaKmsUpdate *update);
 
 META_EXPORT_TEST
+GList * meta_kms_update_get_crtc_updates (MetaKmsUpdate *update);
+
+META_EXPORT_TEST
 GList * meta_kms_update_get_crtc_color_updates (MetaKmsUpdate *update);
 
 MetaKmsCustomPageFlip * meta_kms_update_take_custom_page_flip_func (MetaKmsUpdate *update);
diff '--color=auto' -uraN a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
--- a/src/backends/native/meta-kms-update.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update.c	2023-10-12 20:59:22.683834037 +0300
@@ -40,6 +40,7 @@
   GList *mode_sets;
   GList *plane_assignments;
   GList *connector_updates;
+  GList *crtc_updates;
   GList *crtc_color_updates;
 
   MetaKmsCustomPageFlip *custom_page_flip;
@@ -521,6 +522,46 @@
   g_free (color_update);
 }
 
+static MetaKmsCrtcUpdate *
+ensure_crtc_update (MetaKmsUpdate *update,
+                    MetaKmsCrtc   *crtc)
+{
+  GList *l;
+  MetaKmsCrtcUpdate *crtc_update;
+
+  for (l = update->crtc_updates; l; l = l->next)
+    {
+      crtc_update = l->data;
+
+      if (crtc_update->crtc == crtc)
+        return crtc_update;
+    }
+
+  crtc_update = g_new0 (MetaKmsCrtcUpdate, 1);
+  crtc_update->crtc = crtc;
+
+  update->crtc_updates = g_list_prepend (update->crtc_updates,
+                                         crtc_update);
+
+  return crtc_update;
+}
+
+void
+meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                              MetaKmsCrtc   *crtc,
+                              gboolean       enabled)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+
+  g_assert (meta_kms_crtc_get_device (crtc) == update->device);
+
+  crtc_update = ensure_crtc_update (update, crtc);
+  crtc_update->vrr_mode.has_update = TRUE;
+  crtc_update->vrr_mode.is_enabled = enabled;
+
+  update_latch_crtc (update, crtc);
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
@@ -735,6 +776,12 @@
 }
 
 GList *
+meta_kms_update_get_crtc_updates (MetaKmsUpdate *update)
+{
+  return update->crtc_updates;
+}
+
+GList *
 meta_kms_update_get_crtc_color_updates (MetaKmsUpdate *update)
 {
   return update->crtc_color_updates;
@@ -1062,6 +1109,7 @@
   g_list_free_full (update->page_flip_listeners,
                     (GDestroyNotify) meta_kms_page_flip_listener_unref);
   g_list_free_full (update->connector_updates, g_free);
+  g_list_free_full (update->crtc_updates, g_free);
   g_list_free_full (update->crtc_color_updates,
                     (GDestroyNotify) meta_kms_crtc_color_updates_free);
   g_clear_pointer (&update->custom_page_flip, meta_kms_custom_page_flip_free);
diff '--color=auto' -uraN a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
--- a/src/backends/native/meta-kms-update.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update.h	2023-10-12 20:59:22.683834037 +0300
@@ -152,6 +152,10 @@
                                      MetaKmsCrtc        *crtc,
                                      const MetaGammaLut *gamma);
 
+void meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                                   MetaKmsCrtc   *crtc,
+                                   gboolean       enabled);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const int              *rectangles,
                                               int                     n_rectangles);
diff '--color=auto' -uraN a/src/backends/native/meta-monitor-manager-native.c b/src/backends/native/meta-monitor-manager-native.c
--- a/src/backends/native/meta-monitor-manager-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-monitor-manager-native.c	2023-10-12 20:59:22.710501037 +0300
@@ -451,6 +451,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
diff '--color=auto' -uraN a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
--- a/src/backends/native/meta-onscreen-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-onscreen-native.c	2023-10-12 20:59:22.720501162 +0300
@@ -618,6 +618,9 @@
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "FB Copy (secondary GPU)");
 
+  if (renderer_gpu_data->secondary.needs_explicit_sync)
+    cogl_framebuffer_finish (COGL_FRAMEBUFFER (onscreen));
+
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
 
@@ -2035,6 +2038,7 @@
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   MetaGpuKms *gpu_kms;
   uint32_t format;
+  const uint32_t flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING;
 
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
@@ -2046,10 +2050,29 @@
 
   render_device_gbm = META_RENDER_DEVICE_GBM (render_device);
   gbm_device = meta_render_device_gbm_get_gbm_device (render_device_gbm);
-  gbm_surface = gbm_surface_create (gbm_device,
-                                    width, height,
-                                    format,
-                                    GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
+
+  gbm_surface = gbm_surface_create_with_modifiers2 (gbm_device,
+                                                    width, height,
+                                                    format,
+                                                    NULL, 0,
+                                                    flags);
+
+  if (!gbm_surface)
+    {
+      gbm_surface = gbm_surface_create_with_modifiers (gbm_device,
+                                                       width, height,
+                                                       format,
+                                                       NULL, 0);
+    }
+
+  if (!gbm_surface)
+    {
+      gbm_surface = gbm_surface_create (gbm_device,
+                                        width, height,
+                                        format,
+                                        flags);
+    }
+
   if (!gbm_surface)
     {
       g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
diff '--color=auto' -uraN a/src/backends/native/meta-output-kms.c b/src/backends/native/meta-output-kms.c
--- a/src/backends/native/meta-output-kms.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-output-kms.c	2023-10-12 20:59:22.683834037 +0300
@@ -96,6 +96,26 @@
 }
 
 void
+meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                              MetaKmsUpdate *kms_update,
+                              gboolean       enabled)
+{
+  MetaOutput *output = META_OUTPUT (output_kms);
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+
+  g_assert (output_info->vrr_capable);
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+
+  meta_kms_update_set_vrr_mode (kms_update,
+                                kms_crtc,
+                                enabled);
+}
+
+void
 meta_output_kms_set_max_bpc (MetaOutputKms *output_kms,
                              MetaKmsUpdate *kms_update)
 {
@@ -488,6 +508,9 @@
   output_info->supports_underscanning =
     meta_kms_connector_is_underscanning_supported (kms_connector);
 
+  output_info->vrr_capable = (connector_state->vrr_capable &&
+                              !meta_gpu_kms_disable_vrr (gpu_kms));
+
   max_bpc_range = meta_kms_connector_get_max_bpc (kms_connector);
   if (max_bpc_range)
     {
diff '--color=auto' -uraN a/src/backends/native/meta-output-kms.h b/src/backends/native/meta-output-kms.h
--- a/src/backends/native/meta-output-kms.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-output-kms.h	2023-10-12 20:59:22.683834037 +0300
@@ -37,6 +37,10 @@
 void meta_output_kms_set_underscan (MetaOutputKms *output_kms,
                                     MetaKmsUpdate *kms_update);
 
+void meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                                   MetaKmsUpdate *kms_update,
+                                   gboolean       enabled);
+
 void meta_output_kms_set_max_bpc (MetaOutputKms *output_kms,
                                   MetaKmsUpdate *kms_update);
 
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-native-gles3.c b/src/backends/native/meta-renderer-native-gles3.c
--- a/src/backends/native/meta-renderer-native-gles3.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native-gles3.c	2023-10-12 20:59:22.720501162 +0300
@@ -43,6 +43,120 @@
 #error "Somehow included OpenGL headers when we shouldn't have"
 #endif
 
+static GQuark shader_program_quark = 0;
+
+static GLuint
+load_shader (const char *src,
+             GLenum      type)
+{
+  GLuint shader = glCreateShader (type);
+
+  if (shader)
+    {
+      GLint compiled;
+
+      glShaderSource (shader, 1, &src, NULL);
+      glCompileShader (shader);
+      glGetShaderiv (shader, GL_COMPILE_STATUS, &compiled);
+      if (!compiled)
+        {
+          GLchar log[1024];
+
+          glGetShaderInfoLog (shader, sizeof (log) - 1, NULL, log);
+          log[sizeof (log) - 1] = '\0';
+          g_warning ("load_shader compile failed: %s", log);
+          glDeleteShader (shader);
+          shader = 0;
+        }
+    }
+
+  return shader;
+}
+
+static void
+ensure_shader_program (MetaGles3 *gles3)
+{
+  static const char vertex_shader_source[] =
+    "#version 100\n"
+    "attribute vec2 position;\n"
+    "attribute vec2 texcoord;\n"
+    "varying vec2 v_texcoord;\n"
+    "\n"
+    "void main()\n"
+    "{\n"
+    "  gl_Position = vec4(position, 0.0, 1.0);\n"
+    "  v_texcoord = texcoord;\n"
+    "}\n";
+
+  static const char fragment_shader_source[] =
+    "#version 100\n"
+    "#extension GL_OES_EGL_image_external : require\n"
+    "precision mediump float;\n"
+    "uniform samplerExternalOES s_texture;\n"
+    "varying vec2 v_texcoord;\n"
+    "\n"
+    " void main()\n"
+    "{\n"
+    "  gl_FragColor = texture2D(s_texture, v_texcoord);\n"
+    "}\n";
+
+  static const GLfloat box[] =
+    { // position    texcoord
+      -1.0f,  1.0f, 0.0f, 0.0f,
+       1.0f,  1.0f, 1.0f, 0.0f,
+       1.0f, -1.0f, 1.0f, 1.0f,
+      -1.0f, -1.0f, 0.0f, 1.0f,
+    };
+  GLint linked;
+  GLuint vertex_shader, fragment_shader;
+  GLint position_attrib, texcoord_attrib;
+  GLuint shader_program;
+
+  if (!shader_program_quark)
+    shader_program_quark = g_quark_from_static_string ("shader program");
+
+  if (g_object_get_qdata (G_OBJECT (gles3), shader_program_quark))
+    return;
+
+  shader_program = glCreateProgram ();
+  g_return_if_fail (shader_program);
+  g_object_set_qdata_full (G_OBJECT (gles3),
+                           shader_program_quark,
+                           GUINT_TO_POINTER (shader_program),
+                           NULL);
+
+  vertex_shader = load_shader (vertex_shader_source, GL_VERTEX_SHADER);
+  g_return_if_fail (vertex_shader);
+  fragment_shader = load_shader (fragment_shader_source, GL_FRAGMENT_SHADER);
+  g_return_if_fail (fragment_shader);
+
+  GLBAS (gles3, glAttachShader, (shader_program, vertex_shader));
+  GLBAS (gles3, glAttachShader, (shader_program, fragment_shader));
+  GLBAS (gles3, glLinkProgram, (shader_program));
+  GLBAS (gles3, glGetProgramiv, (shader_program, GL_LINK_STATUS, &linked));
+  if (!linked)
+    {
+      GLchar log[1024];
+
+      glGetProgramInfoLog (shader_program, sizeof (log) - 1, NULL, log);
+      log[sizeof (log) - 1] = '\0';
+      g_warning ("Link failed: %s", log);
+      return;
+    }
+
+  GLBAS (gles3, glUseProgram, (shader_program));
+
+  position_attrib = glGetAttribLocation (shader_program, "position");
+  GLBAS (gles3, glEnableVertexAttribArray, (position_attrib));
+  GLBAS (gles3, glVertexAttribPointer,
+    (position_attrib, 2, GL_FLOAT, GL_FALSE, 4 * sizeof (GLfloat), box));
+
+  texcoord_attrib = glGetAttribLocation (shader_program, "texcoord");
+  GLBAS (gles3, glEnableVertexAttribArray, (texcoord_attrib));
+  GLBAS (gles3, glVertexAttribPointer,
+    (texcoord_attrib, 2, GL_FLOAT, GL_FALSE, 4 * sizeof (GLfloat), box + 2));
+}
+
 static void
 paint_egl_image (MetaGles3   *gles3,
                  EGLImageKHR  egl_image,
@@ -50,39 +164,33 @@
                  int          height)
 {
   GLuint texture;
-  GLuint framebuffer;
 
   meta_gles3_clear_error (gles3);
+  ensure_shader_program (gles3);
 
-  GLBAS (gles3, glGenFramebuffers, (1, &framebuffer));
-  GLBAS (gles3, glBindFramebuffer, (GL_READ_FRAMEBUFFER, framebuffer));
+  GLBAS (gles3, glViewport, (0, 0, width, height));
 
   GLBAS (gles3, glActiveTexture, (GL_TEXTURE0));
   GLBAS (gles3, glGenTextures, (1, &texture));
-  GLBAS (gles3, glBindTexture, (GL_TEXTURE_2D, texture));
-  GLEXT (gles3, glEGLImageTargetTexture2DOES, (GL_TEXTURE_2D, egl_image));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+  GLBAS (gles3, glBindTexture, (GL_TEXTURE_EXTERNAL_OES, texture));
+  GLEXT (gles3, glEGLImageTargetTexture2DOES, (GL_TEXTURE_EXTERNAL_OES,
+                                               egl_image));
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_MAG_FILTER,
                                   GL_NEAREST));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_MIN_FILTER,
                                   GL_NEAREST));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
-                                  GL_CLAMP_TO_EDGE));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_WRAP_S,
                                   GL_CLAMP_TO_EDGE));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_R_OES,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_WRAP_T,
                                   GL_CLAMP_TO_EDGE));
 
-  GLBAS (gles3, glFramebufferTexture2D, (GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                                         GL_TEXTURE_2D, texture, 0));
-
-  GLBAS (gles3, glBindFramebuffer, (GL_READ_FRAMEBUFFER, framebuffer));
-  GLBAS (gles3, glBlitFramebuffer, (0, height, width, 0,
-                                    0, 0, width, height,
-                                    GL_COLOR_BUFFER_BIT,
-                                    GL_NEAREST));
+  GLBAS (gles3, glDrawArrays, (GL_TRIANGLE_FAN, 0, 4));
 
   GLBAS (gles3, glDeleteTextures, (1, &texture));
-  GLBAS (gles3, glDeleteFramebuffers, (1, &framebuffer));
 }
 
 gboolean
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
--- a/src/backends/native/meta-renderer-native-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native-private.h	2023-10-12 20:59:22.720501162 +0300
@@ -60,6 +60,7 @@
   struct {
     MetaSharedFramebufferCopyMode copy_mode;
     gboolean has_EGL_EXT_image_dma_buf_import_modifiers;
+    gboolean needs_explicit_sync;
 
     /* For GPU blit mode */
     EGLContext egl_context;
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
--- a/src/backends/native/meta-renderer-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native.c	2023-10-12 20:59:22.720501162 +0300
@@ -1441,6 +1441,7 @@
                               "stage", meta_backend_get_stage (backend),
                               "layout", &view_layout,
                               "crtc", crtc,
+                              "output", output,
                               "scale", scale,
                               "framebuffer", framebuffer,
                               "offscreen", offscreen,
@@ -1567,8 +1568,11 @@
   if (COGL_IS_ONSCREEN (framebuffer))
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+      MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (view);
 
       meta_onscreen_native_before_redraw (onscreen, frame);
+      meta_renderer_view_native_maybe_update_frame_sync_mode (view_native,
+                                                              frame);
     }
 }
 
@@ -1692,6 +1696,7 @@
   CoglContext *cogl_context;
   CoglDisplay *cogl_display;
   const char **missing_gl_extensions;
+  const char *egl_vendor;
 
   egl_display = meta_render_device_get_egl_display (render_device);
   if (egl_display == EGL_NO_DISPLAY)
@@ -1758,6 +1763,11 @@
     meta_egl_has_extensions (egl, egl_display, NULL,
                              "EGL_EXT_image_dma_buf_import_modifiers",
                              NULL);
+
+  egl_vendor = meta_egl_query_string (egl, egl_display, EGL_VENDOR);
+  if (!g_strcmp0 (egl_vendor, "NVIDIA"))
+    renderer_gpu_data->secondary.needs_explicit_sync = TRUE;
+
   ret = TRUE;
 out:
   maybe_restore_cogl_egl_api (renderer_native);
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-native.c.orig b/src/backends/native/meta-renderer-native.c.orig
--- a/src/backends/native/meta-renderer-native.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/backends/native/meta-renderer-native.c.orig	2023-10-12 20:59:22.683834037 +0300
@@ -0,0 +1,2310 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2011 Intel Corporation.
+ * Copyright (C) 2016 Red Hat
+ * Copyright (c) 2018,2019 DisplayLink (UK) Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *   Rob Bradford <rob@linux.intel.com> (from cogl-winsys-egl-kms.c)
+ *   Kristian Høgsberg (from eglkms.c)
+ *   Benjamin Franzke (from eglkms.c)
+ *   Robert Bragg <robert@linux.intel.com> (from cogl-winsys-egl-kms.c)
+ *   Neil Roberts <neil@linux.intel.com> (from cogl-winsys-egl-kms.c)
+ *   Jonas Ådahl <jadahl@redhat.com>
+ *
+ */
+
+#include "config.h"
+
+#include <drm_fourcc.h>
+#include <errno.h>
+#include <gbm.h>
+#include <gio/gio.h>
+#include <glib-object.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "backends/meta-cursor-tracker-private.h"
+#include "backends/meta-gles3.h"
+#include "backends/meta-logical-monitor.h"
+#include "backends/native/meta-backend-native-private.h"
+#include "backends/native/meta-cursor-renderer-native.h"
+#include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-crtc-virtual.h"
+#include "backends/native/meta-device-pool.h"
+#include "backends/native/meta-kms-cursor-manager.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-onscreen-native.h"
+#include "backends/native/meta-output-kms.h"
+#include "backends/native/meta-render-device-gbm.h"
+#include "backends/native/meta-render-device-surfaceless.h"
+#include "backends/native/meta-renderer-native-private.h"
+#include "backends/native/meta-renderer-view-native.h"
+#include "cogl/cogl.h"
+#include "common/meta-cogl-drm-formats.h"
+#include "core/boxes-private.h"
+
+#ifdef HAVE_EGL_DEVICE
+#include "backends/native/meta-render-device-egl-stream.h"
+#endif
+
+#ifndef EGL_DRM_MASTER_FD_EXT
+#define EGL_DRM_MASTER_FD_EXT 0x333C
+#endif
+
+/* added in libdrm 2.4.95 */
+#ifndef DRM_FORMAT_INVALID
+#define DRM_FORMAT_INVALID 0
+#endif
+
+struct _MetaRendererNative
+{
+  MetaRenderer parent;
+
+  MetaGpuKms *primary_gpu_kms;
+
+  MetaGles3 *gles3;
+
+  gboolean use_modifiers;
+  gboolean send_modifiers;
+
+  GHashTable *gpu_datas;
+
+  GList *pending_mode_set_views;
+  gboolean pending_mode_set;
+
+  GList *detached_onscreens;
+  GList *lingering_onscreens;
+  guint release_unused_gpus_idle_id;
+
+  GList *power_save_page_flip_onscreens;
+  guint power_save_page_flip_source_id;
+
+  GHashTable *mode_set_updates;
+};
+
+static void
+initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaRendererNative,
+                         meta_renderer_native,
+                         META_TYPE_RENDERER,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                initable_iface_init))
+
+static const CoglWinsysEGLVtable _cogl_winsys_egl_vtable;
+
+static gboolean
+meta_renderer_native_ensure_gpu_data (MetaRendererNative  *renderer_native,
+                                      MetaGpuKms          *gpu_kms,
+                                      GError             **error);
+
+static void
+meta_renderer_native_queue_modes_reset (MetaRendererNative *renderer_native);
+
+static void
+meta_renderer_native_gpu_data_free (MetaRendererNativeGpuData *renderer_gpu_data)
+{
+  MetaGpuKms *gpu_kms = renderer_gpu_data->gpu_kms;
+
+  if (renderer_gpu_data->secondary.egl_context != EGL_NO_CONTEXT)
+    {
+      MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+      EGLDisplay egl_display =
+        meta_render_device_get_egl_display (render_device);
+      MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+      MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+
+      meta_egl_destroy_context (egl,
+                                egl_display,
+                                renderer_gpu_data->secondary.egl_context,
+                                NULL);
+    }
+
+  if (renderer_gpu_data->crtc_needs_flush_handler_id)
+    {
+      g_clear_signal_handler (&renderer_gpu_data->crtc_needs_flush_handler_id,
+                              meta_gpu_kms_get_kms_device (gpu_kms));
+    }
+
+  g_clear_pointer (&renderer_gpu_data->render_device, g_object_unref);
+  g_free (renderer_gpu_data);
+}
+
+MetaRendererNativeGpuData *
+meta_renderer_native_get_gpu_data (MetaRendererNative *renderer_native,
+                                   MetaGpuKms         *gpu_kms)
+{
+  return g_hash_table_lookup (renderer_native->gpu_datas, gpu_kms);
+}
+
+static MetaRendererNative *
+meta_renderer_native_from_gpu (MetaGpuKms *gpu_kms)
+{
+  MetaBackend *backend = meta_gpu_get_backend (META_GPU (gpu_kms));
+
+  return META_RENDERER_NATIVE (meta_backend_get_renderer (backend));
+}
+
+struct gbm_device *
+meta_gbm_device_from_gpu (MetaGpuKms *gpu_kms)
+{
+  MetaRendererNative *renderer_native = meta_renderer_native_from_gpu (gpu_kms);
+  MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+  MetaRenderDeviceGbm *render_device_gbm;
+
+  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                         gpu_kms);
+  render_device = renderer_gpu_data->render_device;
+
+  if (!META_IS_RENDER_DEVICE_GBM (render_device))
+    return NULL;
+
+  render_device_gbm = META_RENDER_DEVICE_GBM (render_device);
+  return meta_render_device_gbm_get_gbm_device (render_device_gbm);
+}
+
+MetaGpuKms *
+meta_renderer_native_get_primary_gpu (MetaRendererNative *renderer_native)
+{
+  return renderer_native->primary_gpu_kms;
+}
+
+MetaDeviceFile *
+meta_renderer_native_get_primary_device_file (MetaRendererNative *renderer_native)
+{
+  MetaGpuKms *gpu_kms = renderer_native->primary_gpu_kms;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+
+  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                         gpu_kms);
+  render_device = renderer_gpu_data->render_device;
+  return meta_render_device_get_device_file (render_device);
+}
+
+static MetaRendererNativeGpuData *
+meta_create_renderer_native_gpu_data (void)
+{
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data = g_new0 (MetaRendererNativeGpuData, 1);
+  renderer_gpu_data->secondary.egl_context = EGL_NO_CONTEXT;
+
+  return renderer_gpu_data;
+}
+
+MetaEgl *
+meta_renderer_native_get_egl (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+
+  return meta_backend_get_egl (meta_renderer_get_backend (renderer));
+}
+
+gboolean
+meta_renderer_native_send_modifiers (MetaRendererNative *renderer_native)
+{
+  return renderer_native->send_modifiers;
+}
+
+gboolean
+meta_renderer_native_use_modifiers (MetaRendererNative *renderer_native)
+{
+  return renderer_native->use_modifiers;
+}
+
+MetaGles3 *
+meta_renderer_native_get_gles3 (MetaRendererNative *renderer_native)
+{
+  return renderer_native->gles3;
+}
+
+gboolean
+meta_renderer_native_has_pending_mode_sets (MetaRendererNative *renderer_native)
+{
+  return !!renderer_native->pending_mode_set_views;
+}
+
+gboolean
+meta_renderer_native_has_pending_mode_set (MetaRendererNative *renderer_native)
+{
+  return renderer_native->pending_mode_set;
+}
+
+MetaRendererNativeMode
+meta_renderer_native_get_mode (MetaRendererNative *renderer_native)
+{
+  MetaGpuKms *primary_gpu = renderer_native->primary_gpu_kms;
+  MetaRendererNativeGpuData *primary_gpu_data;
+
+  primary_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                        primary_gpu);
+  return primary_gpu_data->mode;
+}
+
+static void
+meta_renderer_native_disconnect (CoglRenderer *cogl_renderer)
+{
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+
+  g_free (cogl_renderer_egl);
+}
+
+static MetaKmsUpdate *
+ensure_mode_set_update (MetaRendererNative *renderer_native,
+                        MetaKmsDevice      *kms_device)
+{
+  MetaKmsUpdate *kms_update;
+
+  kms_update = g_hash_table_lookup (renderer_native->mode_set_updates,
+                                    kms_device);
+  if (kms_update)
+    return kms_update;
+
+  kms_update = meta_kms_update_new (kms_device);
+  g_hash_table_insert (renderer_native->mode_set_updates,
+                       kms_device, kms_update);
+
+  return kms_update;
+}
+
+static gboolean
+meta_renderer_native_connect (CoglRenderer *cogl_renderer,
+                              GError      **error)
+{
+  CoglRendererEGL *cogl_renderer_egl;
+  MetaRendererNative *renderer_native = cogl_renderer->custom_winsys_user_data;
+  MetaGpuKms *gpu_kms;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+
+  cogl_renderer->winsys = g_new0 (CoglRendererEGL, 1);
+  cogl_renderer_egl = cogl_renderer->winsys;
+
+  gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
+  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                         gpu_kms);
+  render_device = renderer_gpu_data->render_device;
+
+  cogl_renderer_egl->platform_vtable = &_cogl_winsys_egl_vtable;
+  cogl_renderer_egl->platform = renderer_gpu_data;
+  cogl_renderer_egl->edpy = meta_render_device_get_egl_display (render_device);
+
+  if (!_cogl_winsys_egl_renderer_connect_common (cogl_renderer, error))
+    goto fail;
+
+  return TRUE;
+
+fail:
+  meta_renderer_native_disconnect (cogl_renderer);
+
+  return FALSE;
+}
+
+static int
+meta_renderer_native_add_egl_config_attributes (CoglDisplay                 *cogl_display,
+                                                const CoglFramebufferConfig *config,
+                                                EGLint                      *attributes)
+{
+  CoglRendererEGL *cogl_renderer_egl = cogl_display->renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  int i = 0;
+
+  switch (renderer_gpu_data->mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+      attributes[i++] = EGL_SURFACE_TYPE;
+      attributes[i++] = EGL_WINDOW_BIT;
+      break;
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+      attributes[i++] = EGL_SURFACE_TYPE;
+      attributes[i++] = EGL_PBUFFER_BIT;
+      break;
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+      attributes[i++] = EGL_SURFACE_TYPE;
+      attributes[i++] = EGL_STREAM_BIT_KHR;
+      break;
+#endif
+    }
+
+  return i;
+}
+
+static gboolean
+choose_egl_config_from_gbm_format (MetaEgl       *egl,
+                                   EGLDisplay     egl_display,
+                                   const EGLint  *attributes,
+                                   uint32_t       gbm_format,
+                                   EGLConfig     *out_config,
+                                   GError       **error)
+{
+  EGLConfig *egl_configs;
+  EGLint n_configs;
+  EGLint i;
+
+  egl_configs = meta_egl_choose_all_configs (egl, egl_display,
+                                             attributes,
+                                             &n_configs,
+                                             error);
+  if (!egl_configs)
+    return FALSE;
+
+  for (i = 0; i < n_configs; i++)
+    {
+      EGLint visual_id;
+
+      if (!meta_egl_get_config_attrib (egl, egl_display,
+                                       egl_configs[i],
+                                       EGL_NATIVE_VISUAL_ID,
+                                       &visual_id,
+                                       error))
+        {
+          g_free (egl_configs);
+          return FALSE;
+        }
+
+      if ((uint32_t) visual_id == gbm_format)
+        {
+          *out_config = egl_configs[i];
+          g_free (egl_configs);
+          return TRUE;
+        }
+    }
+
+  g_free (egl_configs);
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+               "No EGL config matching supported GBM format found");
+  return FALSE;
+}
+
+static gboolean
+meta_renderer_native_choose_egl_config (CoglDisplay  *cogl_display,
+                                        EGLint       *attributes,
+                                        EGLConfig    *out_config,
+                                        GError      **error)
+{
+  CoglRenderer *cogl_renderer = cogl_display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRenderer *renderer = cogl_renderer->custom_winsys_user_data;
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  EGLDisplay egl_display = cogl_renderer_egl->edpy;
+
+  switch (renderer_gpu_data->mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+      {
+        static const uint32_t formats[] = {
+          GBM_FORMAT_XRGB8888,
+          GBM_FORMAT_ARGB8888,
+        };
+        int i;
+
+        for (i = 0; i < G_N_ELEMENTS (formats); i++)
+          {
+            g_clear_error (error);
+
+            if (choose_egl_config_from_gbm_format (egl,
+                                                   egl_display,
+                                                   attributes,
+                                                   formats[i],
+                                                   out_config,
+                                                   error))
+              return TRUE;
+          }
+
+        return FALSE;
+      }
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+      *out_config = EGL_NO_CONFIG_KHR;
+      return TRUE;
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+      return meta_egl_choose_first_config (egl,
+                                           egl_display,
+                                           attributes,
+                                           out_config,
+                                           error);
+#endif
+    }
+
+  return FALSE;
+}
+
+static gboolean
+meta_renderer_native_setup_egl_display (CoglDisplay *cogl_display,
+                                        GError     **error)
+{
+  CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
+  CoglRendererEGL *cogl_renderer_egl = cogl_display->renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+
+  cogl_display_egl->platform = renderer_native;
+
+  /* Force a full modeset / drmModeSetCrtc on
+   * the first swap buffers call.
+   */
+  meta_renderer_native_queue_modes_reset (renderer_native);
+
+  return TRUE;
+}
+
+static void
+meta_renderer_native_destroy_egl_display (CoglDisplay *cogl_display)
+{
+}
+
+static EGLSurface
+create_dummy_pbuffer_surface (CoglRenderer  *cogl_renderer,
+                              EGLDisplay     egl_display,
+                              GError       **error)
+{
+  MetaRenderer *renderer = cogl_renderer->custom_winsys_user_data;
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  EGLConfig pbuffer_config;
+  static const EGLint pbuffer_config_attribs[] = {
+    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
+    EGL_RED_SIZE, 1,
+    EGL_GREEN_SIZE, 1,
+    EGL_BLUE_SIZE, 1,
+    EGL_ALPHA_SIZE, 0,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+    EGL_NONE
+  };
+  static const EGLint pbuffer_attribs[] = {
+    EGL_WIDTH, 16,
+    EGL_HEIGHT, 16,
+    EGL_NONE
+  };
+
+  if (!meta_egl_choose_first_config (egl, egl_display, pbuffer_config_attribs,
+                                     &pbuffer_config, error))
+    return EGL_NO_SURFACE;
+
+  return meta_egl_create_pbuffer_surface (egl, egl_display,
+                                          pbuffer_config, pbuffer_attribs,
+                                          error);
+}
+
+static gboolean
+meta_renderer_native_egl_context_created (CoglDisplay *cogl_display,
+                                          GError     **error)
+{
+  CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
+  CoglRenderer *cogl_renderer = cogl_display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+
+  if ((cogl_renderer_egl->private_features &
+       COGL_EGL_WINSYS_FEATURE_SURFACELESS_CONTEXT) == 0)
+    {
+      cogl_display_egl->dummy_surface =
+        create_dummy_pbuffer_surface (cogl_renderer,
+                                      cogl_renderer_egl->edpy,
+                                      error);
+      if (cogl_display_egl->dummy_surface == EGL_NO_SURFACE)
+        return FALSE;
+    }
+
+  if (!_cogl_winsys_egl_make_current (cogl_display,
+                                      cogl_display_egl->dummy_surface,
+                                      cogl_display_egl->dummy_surface,
+                                      cogl_display_egl->egl_context))
+    {
+      g_set_error (error, COGL_WINSYS_ERROR,
+                   COGL_WINSYS_ERROR_CREATE_CONTEXT,
+                   "Failed to make context current");
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+meta_renderer_native_egl_cleanup_context (CoglDisplay *cogl_display)
+{
+  CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
+  CoglRenderer *cogl_renderer = cogl_display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+
+  if (cogl_display_egl->dummy_surface != EGL_NO_SURFACE)
+    {
+      meta_egl_destroy_surface (egl,
+                                cogl_renderer_egl->edpy,
+                                cogl_display_egl->dummy_surface,
+                                NULL);
+      cogl_display_egl->dummy_surface = EGL_NO_SURFACE;
+    }
+}
+
+static CoglContext *
+cogl_context_from_renderer_native (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  ClutterBackend *clutter_backend;
+
+  clutter_backend = meta_backend_get_clutter_backend (backend);
+  if (!clutter_backend)
+    return NULL;
+
+  return clutter_backend_get_cogl_context (clutter_backend);
+}
+
+CoglFramebuffer *
+meta_renderer_native_create_dma_buf_framebuffer (MetaRendererNative  *renderer_native,
+                                                 int                  dmabuf_fd,
+                                                 uint32_t             width,
+                                                 uint32_t             height,
+                                                 uint32_t             stride,
+                                                 uint32_t             offset,
+                                                 uint64_t             modifier,
+                                                 uint32_t             drm_format,
+                                                 GError             **error)
+{
+  CoglContext *cogl_context =
+    cogl_context_from_renderer_native (renderer_native);
+  CoglDisplay *cogl_display = cogl_context->display;
+  CoglRenderer *cogl_renderer = cogl_display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  EGLDisplay egl_display = cogl_renderer_egl->edpy;
+  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+  EGLImageKHR egl_image;
+  uint32_t strides[1];
+  uint32_t offsets[1];
+  uint64_t modifiers[1];
+  CoglPixelFormat cogl_format;
+  CoglEglImageFlags flags;
+  CoglTexture2D *cogl_tex;
+  CoglOffscreen *cogl_fbo;
+  int ret;
+
+  ret = meta_cogl_pixel_format_from_drm_format (drm_format, &cogl_format, NULL);
+  g_assert (ret);
+
+  strides[0] = stride;
+  offsets[0] = offset;
+  modifiers[0] = modifier;
+  egl_image = meta_egl_create_dmabuf_image (egl,
+                                            egl_display,
+                                            width,
+                                            height,
+                                            drm_format,
+                                            1 /* n_planes */,
+                                            &dmabuf_fd,
+                                            strides,
+                                            offsets,
+                                            modifiers,
+                                            error);
+  if (egl_image == EGL_NO_IMAGE_KHR)
+    return NULL;
+
+  flags = COGL_EGL_IMAGE_FLAG_NO_GET_DATA;
+  cogl_tex = cogl_egl_texture_2d_new_from_image (cogl_context,
+                                                 width,
+                                                 height,
+                                                 cogl_format,
+                                                 egl_image,
+                                                 flags,
+                                                 error);
+
+  meta_egl_destroy_image (egl, egl_display, egl_image, NULL);
+
+  if (!cogl_tex)
+    return NULL;
+
+  cogl_fbo = cogl_offscreen_new_with_texture (COGL_TEXTURE (cogl_tex));
+  cogl_object_unref (cogl_tex);
+
+  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (cogl_fbo), error))
+    {
+      g_object_unref (cogl_fbo);
+      return NULL;
+    }
+
+  return COGL_FRAMEBUFFER (cogl_fbo);
+}
+
+static void
+configure_disabled_crtcs (MetaKmsDevice      *kms_device,
+                          MetaRendererNative *renderer_native)
+{
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (kms_device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+      MetaKmsUpdate *kms_update;
+
+      if (meta_crtc_get_config (META_CRTC (crtc_kms)))
+        continue;
+
+      if (!meta_kms_crtc_is_active (kms_crtc))
+        continue;
+
+      kms_update = ensure_mode_set_update (renderer_native, kms_device);
+      meta_kms_update_mode_set (kms_update, kms_crtc, NULL, NULL);
+    }
+}
+
+static gboolean
+dummy_power_save_page_flip_cb (gpointer user_data)
+{
+  MetaRendererNative *renderer_native = user_data;
+
+  g_list_foreach (renderer_native->power_save_page_flip_onscreens,
+                  (GFunc) meta_onscreen_native_dummy_power_save_page_flip,
+                  NULL);
+  g_clear_list (&renderer_native->power_save_page_flip_onscreens,
+                g_object_unref);
+  renderer_native->power_save_page_flip_source_id = 0;
+
+  return G_SOURCE_REMOVE;
+}
+
+void
+meta_renderer_native_queue_power_save_page_flip (MetaRendererNative *renderer_native,
+                                                 CoglOnscreen       *onscreen)
+{
+  const unsigned int timeout_ms = 100;
+
+  if (!renderer_native->power_save_page_flip_source_id)
+    {
+      renderer_native->power_save_page_flip_source_id =
+        g_timeout_add (timeout_ms,
+                       dummy_power_save_page_flip_cb,
+                       renderer_native);
+    }
+
+  renderer_native->power_save_page_flip_onscreens =
+    g_list_prepend (renderer_native->power_save_page_flip_onscreens,
+                    g_object_ref (onscreen));
+}
+
+static gboolean
+is_gpu_unused (gpointer key,
+               gpointer value,
+               gpointer user_data)
+{
+  GHashTable *used_gpus = user_data;
+
+  return !g_hash_table_contains (used_gpus, key);
+}
+
+static void
+free_unused_gpu_datas (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  g_autoptr (GHashTable) used_gpus = NULL;
+  GList *l;
+
+  used_gpus = g_hash_table_new (NULL, NULL);
+  g_hash_table_add (used_gpus, renderer_native->primary_gpu_kms);
+
+  for (l = meta_renderer_get_views (renderer); l; l = l->next)
+    {
+      MetaRendererView *view = l->data;
+      MetaCrtc *crtc = meta_renderer_view_get_crtc (view);
+      MetaGpu *gpu;
+
+      gpu = meta_crtc_get_gpu (crtc);
+      if (!gpu)
+        continue;
+
+      g_hash_table_add (used_gpus, gpu);
+    }
+
+  for (l = renderer_native->lingering_onscreens; l; l = l->next)
+    {
+      MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (l->data);
+      MetaCrtc *crtc = meta_onscreen_native_get_crtc (onscreen_native);
+
+      g_hash_table_add (used_gpus, meta_crtc_get_gpu (crtc));
+    }
+
+  g_hash_table_foreach_remove (renderer_native->gpu_datas,
+                               is_gpu_unused,
+                               used_gpus);
+}
+
+static gboolean
+release_unused_gpus_idle (gpointer user_data)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (user_data);
+
+  renderer_native->release_unused_gpus_idle_id = 0;
+  free_unused_gpu_datas (renderer_native);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+old_onscreen_freed (gpointer  user_data,
+                    GObject  *freed_onscreen)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (user_data);
+
+  renderer_native->lingering_onscreens =
+    g_list_remove (renderer_native->lingering_onscreens, freed_onscreen);
+
+  if (!renderer_native->release_unused_gpus_idle_id)
+    {
+      renderer_native->release_unused_gpus_idle_id =
+        g_idle_add (release_unused_gpus_idle, renderer_native);
+    }
+}
+
+static void
+clear_detached_onscreens (MetaRendererNative *renderer_native)
+{
+  GList *l;
+
+  for (l = renderer_native->detached_onscreens; l; l = l->next)
+    {
+      CoglOnscreen *onscreen;
+
+      if (!COGL_IS_ONSCREEN (l->data))
+        continue;
+
+      onscreen = COGL_ONSCREEN (l->data);
+      g_object_weak_ref (G_OBJECT (onscreen),
+                         old_onscreen_freed,
+                         renderer_native);
+      renderer_native->lingering_onscreens =
+        g_list_prepend (renderer_native->lingering_onscreens, onscreen);
+    }
+
+  g_clear_list (&renderer_native->detached_onscreens,
+                g_object_unref);
+}
+
+static void
+mode_sets_update_result_feedback (const MetaKmsFeedback *kms_feedback,
+                                  gpointer               user_data)
+{
+  const GError *feedback_error;
+
+  feedback_error = meta_kms_feedback_get_error (kms_feedback);
+  if (feedback_error &&
+      !g_error_matches (feedback_error,
+                        G_IO_ERROR,
+                        G_IO_ERROR_PERMISSION_DENIED))
+    g_warning ("Failed to post KMS update: %s", feedback_error->message);
+}
+
+static const MetaKmsResultListenerVtable mode_sets_result_listener_vtable = {
+  .feedback = mode_sets_update_result_feedback,
+};
+
+static void
+post_mode_set_updates (MetaRendererNative *renderer_native)
+{
+  GHashTableIter iter;
+  gpointer key, value;
+
+  g_hash_table_iter_init (&iter, renderer_native->mode_set_updates);
+  while (g_hash_table_iter_next (&iter, &key, &value))
+    {
+      MetaKmsDevice *kms_device = META_KMS_DEVICE (key);
+      MetaKmsUpdate *kms_update = value;
+      g_autoptr (MetaKmsFeedback) feedback = NULL;
+
+      g_hash_table_iter_steal (&iter);
+
+      meta_kms_update_add_result_listener (kms_update,
+                                           &mode_sets_result_listener_vtable,
+                                           NULL,
+                                           NULL,
+                                           NULL);
+
+      feedback =
+        meta_kms_device_process_update_sync (kms_device, kms_update,
+                                             META_KMS_UPDATE_FLAG_MODE_SET);
+    }
+}
+
+void
+meta_renderer_native_post_mode_set_updates (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaKms *kms = meta_backend_native_get_kms (META_BACKEND_NATIVE (backend));
+
+  renderer_native->pending_mode_set = FALSE;
+
+  g_list_foreach (meta_kms_get_devices (kms),
+                  (GFunc) configure_disabled_crtcs,
+                  renderer_native);
+
+  post_mode_set_updates (renderer_native);
+
+  clear_detached_onscreens (renderer_native);
+
+  meta_kms_notify_modes_set (kms);
+
+  free_unused_gpu_datas (renderer_native);
+}
+
+void
+meta_renderer_native_queue_mode_set_update (MetaRendererNative *renderer_native,
+                                            MetaKmsUpdate      *new_kms_update)
+{
+  MetaKmsDevice *kms_device = meta_kms_update_get_device (new_kms_update);
+  MetaKmsUpdate *kms_update;
+
+  kms_update = g_hash_table_lookup (renderer_native->mode_set_updates,
+                                    kms_device);
+  if (!kms_update)
+    {
+      g_hash_table_insert (renderer_native->mode_set_updates,
+                           kms_device, new_kms_update);
+      return;
+    }
+
+  meta_kms_update_merge_from (kms_update, new_kms_update);
+  meta_kms_update_free (new_kms_update);
+}
+
+static void
+unset_disabled_crtcs (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  GList *l;
+
+  meta_topic (META_DEBUG_KMS, "Disabling all disabled CRTCs");
+
+  for (l = meta_backend_get_gpus (backend); l; l = l->next)
+    {
+      MetaGpu *gpu = l->data;
+      MetaKmsDevice *kms_device =
+        meta_gpu_kms_get_kms_device (META_GPU_KMS (gpu));
+      GList *k;
+      g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
+      MetaKmsUpdate *kms_update = NULL;
+
+      for (k = meta_gpu_get_crtcs (gpu); k; k = k->next)
+        {
+          MetaCrtc *crtc = k->data;
+
+          if (meta_crtc_get_config (crtc))
+            continue;
+
+          kms_update = ensure_mode_set_update (renderer_native, kms_device);
+          meta_crtc_kms_set_mode (META_CRTC_KMS (crtc), kms_update);
+        }
+    }
+
+  post_mode_set_updates (renderer_native);
+}
+
+static CoglDmaBufHandle *
+meta_renderer_native_create_dma_buf (CoglRenderer     *cogl_renderer,
+                                     CoglPixelFormat   format,
+                                     int               width,
+                                     int               height,
+                                     GError          **error)
+{
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+
+  switch (renderer_gpu_data->mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+      {
+        MetaRenderDevice *render_device;
+        MetaDrmBufferFlags flags;
+        g_autoptr (MetaDrmBuffer) buffer = NULL;
+        int dmabuf_fd;
+        uint32_t stride;
+        uint32_t offset;
+        uint32_t bpp;
+        uint64_t modifier;
+        uint32_t drm_format;
+        CoglFramebuffer *dmabuf_fb;
+        CoglDmaBufHandle *dmabuf_handle;
+
+        if (!meta_drm_format_from_cogl_pixel_format (format, &drm_format))
+          {
+            g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                         "Native renderer doesn't support creating DMA buffer with format %s",
+                         cogl_pixel_format_to_string (format));
+            return NULL;
+          }
+
+        render_device = renderer_gpu_data->render_device;
+        flags = META_DRM_BUFFER_FLAG_NONE;
+        buffer = meta_render_device_allocate_dma_buf (render_device,
+                                                      width, height,
+                                                      drm_format,
+                                                      flags,
+                                                      error);
+        if (!buffer)
+          return NULL;
+
+        dmabuf_fd = meta_drm_buffer_export_fd (buffer, error);
+        if (dmabuf_fd == -1)
+          return NULL;
+
+        stride = meta_drm_buffer_get_stride (buffer);
+        offset = meta_drm_buffer_get_offset (buffer, 0);
+        bpp = meta_drm_buffer_get_bpp (buffer);
+        modifier = meta_drm_buffer_get_modifier (buffer);
+
+        dmabuf_fb =
+          meta_renderer_native_create_dma_buf_framebuffer (renderer_native,
+                                                           dmabuf_fd,
+                                                           width, height,
+                                                           stride,
+                                                           offset,
+                                                           modifier,
+                                                           drm_format,
+                                                           error);
+
+        if (!dmabuf_fb)
+          {
+            close (dmabuf_fd);
+            return NULL;
+          }
+
+        dmabuf_handle =
+          cogl_dma_buf_handle_new (dmabuf_fb, dmabuf_fd,
+                                   width, height, stride, offset, bpp,
+                                   g_steal_pointer (&buffer),
+                                   g_object_unref);
+        g_object_unref (dmabuf_fb);
+        return dmabuf_handle;
+      }
+      break;
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+#endif
+      break;
+    }
+
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_UNKNOWN,
+               "Current mode does not support exporting DMA buffers");
+
+  return NULL;
+}
+
+static gboolean
+meta_renderer_native_is_dma_buf_supported (CoglRenderer *cogl_renderer)
+{
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+
+  switch (renderer_gpu_data->mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+      return meta_render_device_is_hardware_accelerated (render_device);
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+#endif
+      return FALSE;
+    }
+
+  g_assert_not_reached ();
+}
+
+static gboolean
+meta_renderer_native_init_egl_context (CoglContext *cogl_context,
+                                       GError     **error)
+{
+#ifdef HAVE_EGL_DEVICE
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+#endif
+
+  COGL_FLAGS_SET (cogl_context->winsys_features,
+                  COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT,
+                  TRUE);
+  COGL_FLAGS_SET (cogl_context->winsys_features,
+                  COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT,
+                  TRUE);
+
+#ifdef HAVE_EGL_DEVICE
+  if (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_EGL_DEVICE)
+    COGL_FLAGS_SET (cogl_context->features,
+                    COGL_FEATURE_ID_TEXTURE_EGL_IMAGE_EXTERNAL, TRUE);
+#endif
+
+  return TRUE;
+}
+
+static const CoglWinsysEGLVtable
+_cogl_winsys_egl_vtable = {
+  .add_config_attributes = meta_renderer_native_add_egl_config_attributes,
+  .choose_config = meta_renderer_native_choose_egl_config,
+  .display_setup = meta_renderer_native_setup_egl_display,
+  .display_destroy = meta_renderer_native_destroy_egl_display,
+  .context_created = meta_renderer_native_egl_context_created,
+  .cleanup_context = meta_renderer_native_egl_cleanup_context,
+  .context_init = meta_renderer_native_init_egl_context
+};
+
+static void
+meta_renderer_native_queue_modes_reset (MetaRendererNative *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaKms *kms = meta_backend_native_get_kms (META_BACKEND_NATIVE (backend));
+  MetaKmsCursorManager *kms_cursor_manager = meta_kms_get_cursor_manager (kms);
+  GList *l;
+  g_autoptr (GArray) crtc_layouts = NULL;
+
+  crtc_layouts = g_array_new (FALSE, TRUE, sizeof (MetaKmsCrtcLayout));
+
+  g_clear_list (&renderer_native->pending_mode_set_views, NULL);
+  for (l = meta_renderer_get_views (renderer); l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      CoglFramebuffer *framebuffer =
+        clutter_stage_view_get_onscreen (stage_view);
+
+      if (COGL_IS_ONSCREEN (framebuffer))
+        {
+          MetaOnscreenNative *onscreen_native =
+            META_ONSCREEN_NATIVE (framebuffer);
+          MetaCrtc *crtc;
+          MetaKmsCrtc *kms_crtc;
+          MtkRectangle view_layout;
+          float view_scale;
+          MetaKmsCrtcLayout crtc_layout;
+
+          renderer_native->pending_mode_set_views =
+            g_list_prepend (renderer_native->pending_mode_set_views,
+                            stage_view);
+          meta_onscreen_native_invalidate (onscreen_native);
+          crtc = meta_onscreen_native_get_crtc (onscreen_native);
+          kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+
+          clutter_stage_view_get_layout (stage_view, &view_layout);
+          view_scale = clutter_stage_view_get_scale (stage_view);
+
+          crtc_layout = (MetaKmsCrtcLayout) {
+            .crtc = kms_crtc,
+            .layout = GRAPHENE_RECT_INIT (view_layout.x,
+                                          view_layout.y,
+                                          view_layout.width,
+                                          view_layout.height),
+            .scale = view_scale,
+          };
+          g_array_append_val (crtc_layouts, crtc_layout);
+        }
+    }
+  renderer_native->pending_mode_set = TRUE;
+
+  meta_kms_cursor_manager_update_crtc_layout (kms_cursor_manager, crtc_layouts);
+
+  meta_topic (META_DEBUG_KMS, "Queue mode set");
+}
+
+void
+meta_renderer_native_notify_mode_sets_reset (MetaRendererNative *renderer_native)
+{
+  renderer_native->pending_mode_set = FALSE;
+}
+
+gboolean
+meta_renderer_native_pop_pending_mode_set (MetaRendererNative *renderer_native,
+                                           MetaRendererView   *view)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaPowerSave power_save_mode;
+  GList *link;
+
+  g_assert (META_IS_RENDERER_VIEW (view));
+
+  power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
+  if (power_save_mode != META_POWER_SAVE_ON)
+    return FALSE;
+
+  link = g_list_find (renderer_native->pending_mode_set_views, view);
+  if (!link)
+    return FALSE;
+
+  renderer_native->pending_mode_set_views =
+    g_list_delete_link (renderer_native->pending_mode_set_views, link);
+  return TRUE;
+}
+
+static CoglOffscreen *
+meta_renderer_native_create_offscreen (MetaRendererNative    *renderer,
+                                       CoglContext           *context,
+                                       gint                   view_width,
+                                       gint                   view_height,
+                                       GError               **error)
+{
+  CoglOffscreen *fb;
+  CoglTexture2D *tex;
+
+  tex = cogl_texture_2d_new_with_size (context, view_width, view_height);
+  cogl_primitive_texture_set_auto_mipmap (COGL_PRIMITIVE_TEXTURE (tex), FALSE);
+
+  if (!cogl_texture_allocate (COGL_TEXTURE (tex), error))
+    {
+      cogl_object_unref (tex);
+      return FALSE;
+    }
+
+  fb = cogl_offscreen_new_with_texture (COGL_TEXTURE (tex));
+  cogl_object_unref (tex);
+  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (fb), error))
+    {
+      g_object_unref (fb);
+      return FALSE;
+    }
+
+  return fb;
+}
+
+static const CoglWinsysVtable *
+get_native_cogl_winsys_vtable (CoglRenderer *cogl_renderer)
+{
+  static gboolean vtable_inited = FALSE;
+  static CoglWinsysVtable vtable;
+
+  if (!vtable_inited)
+    {
+      /* The this winsys is a subclass of the EGL winsys so we
+         start by copying its vtable */
+
+      vtable = *_cogl_winsys_egl_get_vtable ();
+
+      vtable.id = COGL_WINSYS_ID_CUSTOM;
+      vtable.name = "EGL_KMS";
+
+      vtable.renderer_connect = meta_renderer_native_connect;
+      vtable.renderer_disconnect = meta_renderer_native_disconnect;
+      vtable.renderer_create_dma_buf = meta_renderer_native_create_dma_buf;
+      vtable.renderer_is_dma_buf_supported =
+        meta_renderer_native_is_dma_buf_supported;
+
+      vtable_inited = TRUE;
+    }
+
+  return &vtable;
+}
+
+static CoglRenderer *
+meta_renderer_native_create_cogl_renderer (MetaRenderer *renderer)
+{
+  CoglRenderer *cogl_renderer;
+
+  cogl_renderer = cogl_renderer_new ();
+  cogl_renderer_set_custom_winsys (cogl_renderer,
+                                   get_native_cogl_winsys_vtable,
+                                   renderer);
+  return cogl_renderer;
+}
+
+static MetaMonitorTransform
+calculate_view_transform (MetaMonitorManager *monitor_manager,
+                          MetaLogicalMonitor *logical_monitor,
+                          MetaOutput         *output,
+                          MetaCrtc           *crtc)
+{
+  MetaMonitorTransform crtc_transform;
+
+  crtc = meta_output_get_assigned_crtc (output);
+  crtc_transform =
+    meta_output_logical_to_crtc_transform (output, logical_monitor->transform);
+
+  if (meta_monitor_manager_is_transform_handled (monitor_manager,
+                                                 crtc,
+                                                 crtc_transform))
+    return META_MONITOR_TRANSFORM_NORMAL;
+  else
+    return crtc_transform;
+}
+
+static gboolean
+should_force_shadow_fb (MetaRendererNative *renderer_native,
+                        MetaGpuKms         *primary_gpu)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  CoglContext *cogl_context =
+    cogl_context_from_renderer_native (renderer_native);
+  MetaKmsDevice *kms_device = meta_gpu_kms_get_kms_device (primary_gpu);
+
+  if (meta_renderer_is_hardware_accelerated (renderer))
+    return FALSE;
+
+  if (!cogl_has_feature (cogl_context, COGL_FEATURE_ID_BLIT_FRAMEBUFFER))
+    return FALSE;
+
+  return meta_kms_device_prefers_shadow_buffer (kms_device);
+}
+
+static CoglFramebuffer *
+create_fallback_offscreen (MetaRendererNative *renderer_native,
+                           CoglContext        *cogl_context,
+                           int                 width,
+                           int                 height)
+{
+  CoglOffscreen *fallback_offscreen;
+  GError *error = NULL;
+
+  fallback_offscreen = meta_renderer_native_create_offscreen (renderer_native,
+                                                              cogl_context,
+                                                              width,
+                                                              height,
+                                                              &error);
+  if (!fallback_offscreen)
+    {
+      g_error ("Failed to create fallback offscreen framebuffer: %s",
+               error->message);
+    }
+
+  return COGL_FRAMEBUFFER (fallback_offscreen);
+}
+
+static MetaRendererView *
+meta_renderer_native_create_view (MetaRenderer       *renderer,
+                                  MetaLogicalMonitor *logical_monitor,
+                                  MetaOutput         *output,
+                                  MetaCrtc           *crtc)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  CoglContext *cogl_context =
+    cogl_context_from_renderer_native (renderer_native);
+  CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
+  const MetaCrtcConfig *crtc_config;
+  const MetaCrtcModeInfo *crtc_mode_info;
+  MetaMonitorTransform view_transform;
+  g_autoptr (CoglFramebuffer) framebuffer = NULL;
+  g_autoptr (CoglOffscreen) offscreen = NULL;
+  gboolean use_shadowfb;
+  float scale;
+  int onscreen_width;
+  int onscreen_height;
+  MtkRectangle view_layout;
+  MetaRendererViewNative *view_native;
+  EGLSurface egl_surface;
+  GError *error = NULL;
+
+  crtc_config = meta_crtc_get_config (crtc);
+  crtc_mode_info = meta_crtc_mode_get_info (crtc_config->mode);
+  onscreen_width = crtc_mode_info->width;
+  onscreen_height = crtc_mode_info->height;
+
+  if (META_IS_CRTC_KMS (crtc))
+    {
+      MetaGpuKms *gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
+      g_autoptr (MetaOnscreenNative) onscreen_native = NULL;
+
+      if (!meta_renderer_native_ensure_gpu_data (renderer_native,
+                                                 gpu_kms,
+                                                 &error))
+        {
+          g_warning ("Failed to create secondary GPU data for %s: %s",
+                      meta_gpu_kms_get_file_path (gpu_kms),
+                      error->message);
+          use_shadowfb = FALSE;
+          framebuffer = create_fallback_offscreen (renderer_native,
+                                                   cogl_context,
+                                                   onscreen_width,
+                                                   onscreen_height);
+        }
+      else
+        {
+          MetaGpuKms *primary_gpu_kms = renderer_native->primary_gpu_kms;
+
+          onscreen_native = meta_onscreen_native_new (renderer_native,
+                                                      primary_gpu_kms,
+                                                      output,
+                                                      crtc,
+                                                      cogl_context,
+                                                      onscreen_width,
+                                                      onscreen_height);
+
+          if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (onscreen_native), &error))
+            {
+              g_warning ("Failed to allocate onscreen framebuffer for %s: %s",
+                         meta_gpu_kms_get_file_path (gpu_kms),
+                         error->message);
+              use_shadowfb = FALSE;
+              framebuffer = create_fallback_offscreen (renderer_native,
+                                                       cogl_context,
+                                                       onscreen_width,
+                                                       onscreen_height);
+            }
+          else
+            {
+              use_shadowfb = should_force_shadow_fb (renderer_native,
+                                                     primary_gpu_kms);
+              framebuffer =
+                COGL_FRAMEBUFFER (g_steal_pointer (&onscreen_native));
+            }
+        }
+    }
+  else
+    {
+      CoglOffscreen *virtual_onscreen;
+
+      g_assert (META_IS_CRTC_VIRTUAL (crtc));
+
+      virtual_onscreen = meta_renderer_native_create_offscreen (renderer_native,
+                                                                cogl_context,
+                                                                onscreen_width,
+                                                                onscreen_height,
+                                                                &error);
+      if (!virtual_onscreen)
+        g_error ("Failed to allocate back buffer texture: %s", error->message);
+      use_shadowfb = FALSE;
+      framebuffer = COGL_FRAMEBUFFER (virtual_onscreen);
+    }
+
+  view_transform = calculate_view_transform (monitor_manager,
+                                             logical_monitor,
+                                             output,
+                                             crtc);
+  if (view_transform != META_MONITOR_TRANSFORM_NORMAL)
+    {
+      int offscreen_width;
+      int offscreen_height;
+
+      if (meta_monitor_transform_is_rotated (view_transform))
+        {
+          offscreen_width = onscreen_height;
+          offscreen_height = onscreen_width;
+        }
+      else
+        {
+          offscreen_width = onscreen_width;
+          offscreen_height = onscreen_height;
+        }
+
+      offscreen = meta_renderer_native_create_offscreen (renderer_native,
+                                                         cogl_context,
+                                                         offscreen_width,
+                                                         offscreen_height,
+                                                         &error);
+      if (!offscreen)
+        g_error ("Failed to allocate back buffer texture: %s", error->message);
+    }
+
+  if (meta_backend_is_stage_views_scaled (backend))
+    scale = meta_logical_monitor_get_scale (logical_monitor);
+  else
+    scale = 1.0;
+
+  mtk_rectangle_from_graphene_rect (&crtc_config->layout,
+                                    MTK_ROUNDING_STRATEGY_ROUND,
+                                    &view_layout);
+  view_native = g_object_new (META_TYPE_RENDERER_VIEW_NATIVE,
+                              "name", meta_output_get_name (output),
+                              "stage", meta_backend_get_stage (backend),
+                              "layout", &view_layout,
+                              "crtc", crtc,
+                              "output", output,
+                              "scale", scale,
+                              "framebuffer", framebuffer,
+                              "offscreen", offscreen,
+                              "use-shadowfb", use_shadowfb,
+                              "transform", view_transform,
+                              "refresh-rate", crtc_mode_info->refresh_rate,
+                              "vblank-duration-us", crtc_mode_info->vblank_duration_us,
+                              NULL);
+
+  if (META_IS_ONSCREEN_NATIVE (framebuffer))
+    {
+      CoglDisplayEGL *cogl_display_egl;
+      CoglOnscreenEgl *onscreen_egl;
+
+      meta_onscreen_native_set_view (COGL_ONSCREEN (framebuffer),
+                                     META_RENDERER_VIEW (view_native));
+
+      /* Ensure we don't point to stale surfaces when creating the offscreen */
+      cogl_display_egl = cogl_display->winsys;
+      onscreen_egl = COGL_ONSCREEN_EGL (framebuffer);
+      egl_surface = cogl_onscreen_egl_get_egl_surface (onscreen_egl);
+      _cogl_winsys_egl_make_current (cogl_display,
+                                     egl_surface,
+                                     egl_surface,
+                                     cogl_display_egl->egl_context);
+    }
+
+  return META_RENDERER_VIEW (view_native);
+}
+
+static void
+detach_onscreens (MetaRenderer *renderer)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  GList *views;
+  GList *l;
+
+  views = meta_renderer_get_views (renderer);
+  for (l = views; l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      CoglFramebuffer *onscreen = clutter_stage_view_get_onscreen (stage_view);
+
+      if (META_IS_ONSCREEN_NATIVE (onscreen))
+        meta_onscreen_native_detach (META_ONSCREEN_NATIVE (onscreen));
+
+      renderer_native->detached_onscreens =
+        g_list_prepend (renderer_native->detached_onscreens,
+                        g_object_ref (onscreen));
+    }
+}
+
+static void
+meta_renderer_native_rebuild_views (MetaRenderer *renderer)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
+  MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  MetaRendererClass *parent_renderer_class =
+    META_RENDERER_CLASS (meta_renderer_native_parent_class);
+
+  meta_kms_discard_pending_page_flips (kms);
+  g_hash_table_remove_all (renderer_native->mode_set_updates);
+
+  detach_onscreens (renderer);
+
+  parent_renderer_class->rebuild_views (renderer);
+
+  meta_renderer_native_queue_modes_reset (META_RENDERER_NATIVE (renderer));
+}
+
+static void
+meta_renderer_native_resume (MetaRenderer *renderer)
+{
+  GList *l;
+
+  for (l = meta_renderer_get_views (renderer); l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      CoglFramebuffer *framebuffer;
+
+      framebuffer = clutter_stage_view_get_onscreen (stage_view);
+      if (!META_IS_ONSCREEN_NATIVE (framebuffer))
+        continue;
+
+      meta_onscreen_native_invalidate (META_ONSCREEN_NATIVE (framebuffer));
+    }
+}
+
+void
+meta_renderer_native_prepare_frame (MetaRendererNative *renderer_native,
+                                    MetaRendererView   *view,
+                                    ClutterFrame       *frame)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  CoglFramebuffer *framebuffer =
+    clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
+  MetaPowerSave power_save_mode;
+
+  power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
+  if (power_save_mode != META_POWER_SAVE_ON)
+    return;
+
+  if (COGL_IS_ONSCREEN (framebuffer))
+    {
+      CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+
+      meta_onscreen_native_prepare_frame (onscreen, frame);
+    }
+}
+
+void
+meta_renderer_native_before_redraw (MetaRendererNative *renderer_native,
+                                    MetaRendererView   *view,
+                                    ClutterFrame       *frame)
+{
+  CoglFramebuffer *framebuffer =
+    clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
+
+  if (COGL_IS_ONSCREEN (framebuffer))
+    {
+      CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+      MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (view);
+
+      meta_onscreen_native_before_redraw (onscreen, frame);
+      meta_renderer_view_native_maybe_update_frame_sync_mode (view_native,
+                                                              frame);
+    }
+}
+
+void
+meta_renderer_native_finish_frame (MetaRendererNative *renderer_native,
+                                   MetaRendererView   *view,
+                                   ClutterFrame       *frame)
+{
+  if (!clutter_frame_has_result (frame))
+    {
+      CoglFramebuffer *framebuffer =
+        clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
+
+      if (COGL_IS_ONSCREEN (framebuffer))
+        {
+          CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+
+          meta_onscreen_native_finish_frame (onscreen, frame);
+        }
+    }
+}
+
+static gboolean
+create_secondary_egl_config (MetaEgl               *egl,
+                             MetaRendererNativeMode mode,
+                             EGLDisplay             egl_display,
+                             EGLConfig             *egl_config,
+                             GError               **error)
+{
+  EGLint attributes[] = {
+    EGL_RED_SIZE, 1,
+    EGL_GREEN_SIZE, 1,
+    EGL_BLUE_SIZE, 1,
+    EGL_ALPHA_SIZE, EGL_DONT_CARE,
+    EGL_BUFFER_SIZE, EGL_DONT_CARE,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+    EGL_NONE
+  };
+
+  switch (mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+      return choose_egl_config_from_gbm_format (egl,
+                                                egl_display,
+                                                attributes,
+                                                GBM_FORMAT_XRGB8888,
+                                                egl_config,
+                                                error);
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+      return meta_egl_choose_first_config (egl,
+                                           egl_display,
+                                           attributes,
+                                           egl_config,
+                                           error);
+#endif
+    }
+
+  return FALSE;
+}
+
+static EGLContext
+create_secondary_egl_context (MetaEgl   *egl,
+                              EGLDisplay egl_display,
+                              EGLConfig  egl_config,
+                              GError   **error)
+{
+  EGLint attributes[] = {
+    EGL_CONTEXT_CLIENT_VERSION, 3,
+    EGL_NONE
+  };
+
+  return meta_egl_create_context (egl,
+                                  egl_display,
+                                  egl_config,
+                                  EGL_NO_CONTEXT,
+                                  attributes,
+                                  error);
+}
+
+static void
+meta_renderer_native_ensure_gles3 (MetaRendererNative *renderer_native)
+{
+  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+
+  if (renderer_native->gles3)
+    return;
+
+  renderer_native->gles3 = meta_gles3_new (egl);
+}
+
+static void
+maybe_restore_cogl_egl_api (MetaRendererNative *renderer_native)
+{
+  CoglContext *cogl_context;
+  CoglDisplay *cogl_display;
+  CoglRenderer *cogl_renderer;
+
+  cogl_context = cogl_context_from_renderer_native (renderer_native);
+  if (!cogl_context)
+    return;
+
+  cogl_display = cogl_context_get_display (cogl_context);
+  cogl_renderer = cogl_display_get_renderer (cogl_display);
+  cogl_renderer_bind_api (cogl_renderer);
+}
+
+static gboolean
+init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
+                             GError                   **error)
+{
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+  gboolean ret = FALSE;
+  EGLDisplay egl_display;
+  EGLConfig egl_config;
+  EGLContext egl_context;
+  CoglContext *cogl_context;
+  CoglDisplay *cogl_display;
+  const char **missing_gl_extensions;
+
+  egl_display = meta_render_device_get_egl_display (render_device);
+  if (egl_display == EGL_NO_DISPLAY)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "No EGL display");
+      goto out;
+    }
+
+  if (!meta_render_device_is_hardware_accelerated (render_device))
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Not hardware accelerated");
+      goto out;
+    }
+
+  meta_egl_bind_api (egl, EGL_OPENGL_ES_API, NULL);
+
+  if (!create_secondary_egl_config (egl, renderer_gpu_data->mode, egl_display,
+                                    &egl_config, error))
+    goto out;
+
+  egl_context = create_secondary_egl_context (egl, egl_display, egl_config,
+                                              error);
+  if (egl_context == EGL_NO_CONTEXT)
+    goto out;
+
+  meta_renderer_native_ensure_gles3 (renderer_native);
+
+  if (!meta_egl_make_current (egl,
+                              egl_display,
+                              EGL_NO_SURFACE,
+                              EGL_NO_SURFACE,
+                              egl_context,
+                              error))
+    {
+      meta_egl_destroy_context (egl, egl_display, egl_context, NULL);
+      goto out;
+    }
+
+  if (!meta_gles3_has_extensions (renderer_native->gles3,
+                                  &missing_gl_extensions,
+                                  "GL_OES_EGL_image_external",
+                                  NULL))
+    {
+      char *missing_gl_extensions_str;
+
+      missing_gl_extensions_str = g_strjoinv (", ",
+                                              (char **) missing_gl_extensions);
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Missing OpenGL ES extensions: %s",
+                   missing_gl_extensions_str);
+      g_free (missing_gl_extensions_str);
+      g_free (missing_gl_extensions);
+
+      goto out;
+    }
+
+  renderer_gpu_data->secondary.egl_context = egl_context;
+  renderer_gpu_data->secondary.egl_config = egl_config;
+  renderer_gpu_data->secondary.copy_mode = META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU;
+
+  renderer_gpu_data->secondary.has_EGL_EXT_image_dma_buf_import_modifiers =
+    meta_egl_has_extensions (egl, egl_display, NULL,
+                             "EGL_EXT_image_dma_buf_import_modifiers",
+                             NULL);
+  ret = TRUE;
+out:
+  maybe_restore_cogl_egl_api (renderer_native);
+  cogl_context = cogl_context_from_renderer_native (renderer_native);
+  if (cogl_context)
+    {
+      cogl_display = cogl_context_get_display (cogl_context);
+      _cogl_winsys_egl_ensure_current (cogl_display);
+    }
+  return ret;
+}
+
+static void
+init_secondary_gpu_data_cpu (MetaRendererNativeGpuData *renderer_gpu_data)
+{
+  /* First try ZERO, it automatically falls back to PRIMARY as needed */
+  renderer_gpu_data->secondary.copy_mode =
+    META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO;
+}
+
+static void
+init_secondary_gpu_data (MetaRendererNativeGpuData *renderer_gpu_data)
+{
+  GError *error = NULL;
+
+  if (init_secondary_gpu_data_gpu (renderer_gpu_data, &error))
+    return;
+
+  g_message ("Failed to initialize accelerated iGPU/dGPU framebuffer sharing: %s",
+             error->message);
+  g_error_free (error);
+
+  init_secondary_gpu_data_cpu (renderer_gpu_data);
+}
+
+static gboolean
+gpu_kms_is_hardware_rendering (MetaRendererNative *renderer_native,
+                               MetaGpuKms         *gpu_kms)
+{
+  MetaRendererNativeGpuData *data;
+
+  data = meta_renderer_native_get_gpu_data (renderer_native, gpu_kms);
+  return meta_render_device_is_hardware_accelerated (data->render_device);
+}
+
+static MetaRendererNativeGpuData *
+create_renderer_gpu_data_gbm (MetaRendererNative *renderer_native,
+                              MetaRenderDevice   *render_device,
+                              MetaGpuKms         *gpu_kms)
+{
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data = meta_create_renderer_native_gpu_data ();
+  renderer_gpu_data->renderer_native = renderer_native;
+  renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_GBM;
+  renderer_gpu_data->render_device = render_device;
+  renderer_gpu_data->gpu_kms = gpu_kms;
+
+  init_secondary_gpu_data (renderer_gpu_data);
+  return renderer_gpu_data;
+}
+
+static MetaRendererNativeGpuData *
+create_renderer_gpu_data_surfaceless (MetaRendererNative  *renderer_native,
+                                      GError             **error)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaRenderDeviceSurfaceless *render_device_surfaceless;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  render_device_surfaceless = meta_render_device_surfaceless_new (backend,
+                                                                  error);
+  if (!render_device_surfaceless)
+    return NULL;
+
+  renderer_gpu_data = meta_create_renderer_native_gpu_data ();
+  renderer_gpu_data->renderer_native = renderer_native;
+  renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_SURFACELESS;
+  renderer_gpu_data->render_device =
+    META_RENDER_DEVICE (render_device_surfaceless);
+
+  return renderer_gpu_data;
+}
+
+#ifdef HAVE_EGL_DEVICE
+static MetaRendererNativeGpuData *
+create_renderer_gpu_data_egl_device (MetaRendererNative  *renderer_native,
+                                     MetaRenderDevice    *render_device,
+                                     MetaGpuKms          *gpu_kms)
+{
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data = meta_create_renderer_native_gpu_data ();
+  renderer_gpu_data->renderer_native = renderer_native;
+  renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_EGL_DEVICE;
+  renderer_gpu_data->render_device = render_device;
+  renderer_gpu_data->gpu_kms = gpu_kms;
+
+  return renderer_gpu_data;
+}
+#endif /* HAVE_EGL_DEVICE */
+
+static void
+on_crtc_needs_flush (MetaKmsDevice *kms_device,
+                     MetaKmsCrtc   *kms_crtc,
+                     MetaRenderer  *renderer)
+{
+  MetaCrtc *crtc = META_CRTC (meta_crtc_kms_from_kms_crtc (kms_crtc));
+  MetaRendererView *view;
+
+  view = meta_renderer_get_view_for_crtc (renderer, crtc);
+  if (view)
+    clutter_stage_view_schedule_update (CLUTTER_STAGE_VIEW (view));
+}
+
+static MetaRendererNativeGpuData *
+meta_renderer_native_create_renderer_gpu_data (MetaRendererNative  *renderer_native,
+                                               MetaGpuKms          *gpu_kms,
+                                               GError             **error)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
+  const char *device_path;
+  MetaRenderDevice *render_device;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  if (!gpu_kms)
+    return create_renderer_gpu_data_surfaceless (renderer_native, error);
+
+  device_path = meta_gpu_kms_get_file_path (gpu_kms);
+  render_device = meta_backend_native_take_render_device (backend_native,
+                                                          device_path,
+                                                          error);
+  if (!render_device)
+    {
+      return NULL;
+    }
+
+  if (META_IS_RENDER_DEVICE_GBM (render_device))
+    {
+      renderer_gpu_data = create_renderer_gpu_data_gbm (renderer_native,
+                                                        render_device,
+                                                        gpu_kms);
+    }
+#ifdef HAVE_EGL_DEVICE
+  else if (META_IS_RENDER_DEVICE_EGL_STREAM (render_device))
+    {
+      renderer_gpu_data = create_renderer_gpu_data_egl_device (renderer_native,
+                                                               render_device,
+                                                               gpu_kms);
+    }
+#endif
+  else
+    {
+      g_assert_not_reached ();
+      return NULL;
+    }
+
+  renderer_gpu_data->crtc_needs_flush_handler_id =
+    g_signal_connect (meta_gpu_kms_get_kms_device (gpu_kms),
+                      "crtc-needs-flush",
+                      G_CALLBACK (on_crtc_needs_flush),
+                      renderer_native);
+  return renderer_gpu_data;
+}
+
+static const char *
+renderer_data_mode_to_string (MetaRendererNativeMode mode)
+{
+  switch (mode)
+    {
+    case META_RENDERER_NATIVE_MODE_GBM:
+      return "gbm";
+    case META_RENDERER_NATIVE_MODE_SURFACELESS:
+      return "surfaceless";
+#ifdef HAVE_EGL_DEVICE
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+      return "egldevice";
+#endif
+    }
+
+  g_assert_not_reached ();
+}
+
+static gboolean
+create_renderer_gpu_data (MetaRendererNative  *renderer_native,
+                          MetaGpuKms          *gpu_kms,
+                          GError             **error)
+{
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data =
+    meta_renderer_native_create_renderer_gpu_data (renderer_native,
+                                                   gpu_kms,
+                                                   error);
+  if (!renderer_gpu_data)
+    return FALSE;
+
+  if (gpu_kms)
+    {
+      g_message ("Created %s renderer for '%s'",
+                 renderer_data_mode_to_string (renderer_gpu_data->mode),
+                 meta_gpu_kms_get_file_path (gpu_kms));
+    }
+  else
+    {
+      g_message ("Created %s renderer without GPU",
+                 renderer_data_mode_to_string (renderer_gpu_data->mode));
+    }
+
+  g_hash_table_insert (renderer_native->gpu_datas,
+                       gpu_kms,
+                       renderer_gpu_data);
+
+  return TRUE;
+}
+
+static gboolean
+meta_renderer_native_ensure_gpu_data (MetaRendererNative  *renderer_native,
+                                      MetaGpuKms          *gpu_kms,
+                                      GError             **error)
+{
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data = g_hash_table_lookup (renderer_native->gpu_datas, gpu_kms);
+  if (renderer_gpu_data)
+    return TRUE;
+
+  return create_renderer_gpu_data (renderer_native, gpu_kms, error);
+}
+
+static void
+on_gpu_added (MetaBackendNative  *backend_native,
+              MetaGpuKms         *gpu_kms,
+              MetaRendererNative *renderer_native)
+{
+  MetaBackend *backend = META_BACKEND (backend_native);
+  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
+  CoglContext *cogl_context = clutter_backend_get_cogl_context (clutter_backend);
+  CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
+  GError *error = NULL;
+
+  if (!create_renderer_gpu_data (renderer_native, gpu_kms, &error))
+    {
+      g_warning ("on_gpu_added: could not create gpu_data for gpu %s: %s",
+                 meta_gpu_kms_get_file_path (gpu_kms), error->message);
+      g_clear_error (&error);
+    }
+
+  _cogl_winsys_egl_ensure_current (cogl_display);
+}
+
+static void
+on_power_save_mode_changed (MetaMonitorManager        *monitor_manager,
+                            MetaPowerSaveChangeReason  reason,
+                            MetaRendererNative        *renderer_native)
+{
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
+  MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  MetaPowerSave power_save_mode;
+
+  power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
+  if (power_save_mode == META_POWER_SAVE_ON &&
+      reason == META_POWER_SAVE_CHANGE_REASON_MODE_CHANGE)
+    meta_renderer_native_queue_modes_reset (renderer_native);
+  else
+    meta_kms_discard_pending_page_flips (kms);
+}
+
+void
+meta_renderer_native_reset_modes (MetaRendererNative *renderer_native)
+{
+  unset_disabled_crtcs (renderer_native);
+}
+
+static MetaGpuKms *
+choose_primary_gpu_unchecked (MetaBackend        *backend,
+                              MetaRendererNative *renderer_native)
+{
+  GList *gpus = meta_backend_get_gpus (backend);
+  GList *l;
+  int allow_sw;
+
+  /*
+   * Check first hardware rendering devices, and if none found,
+   * then software rendering devices.
+   */
+  for (allow_sw = 0; allow_sw < 2; allow_sw++)
+  {
+    /* First check if one was explicitly configured. */
+    for (l = gpus; l; l = l->next)
+      {
+        MetaGpuKms *gpu_kms = META_GPU_KMS (l->data);
+        MetaKmsDevice *kms_device = meta_gpu_kms_get_kms_device (gpu_kms);
+
+        if (meta_kms_device_get_flags (kms_device) &
+            META_KMS_DEVICE_FLAG_PREFERRED_PRIMARY)
+          {
+            g_message ("GPU %s selected primary given udev rule",
+                       meta_gpu_kms_get_file_path (gpu_kms));
+            return gpu_kms;
+          }
+      }
+
+    /* Prefer a platform device */
+    for (l = gpus; l; l = l->next)
+      {
+        MetaGpuKms *gpu_kms = META_GPU_KMS (l->data);
+
+        if (meta_gpu_kms_is_platform_device (gpu_kms) &&
+            (allow_sw == 1 ||
+             gpu_kms_is_hardware_rendering (renderer_native, gpu_kms)))
+          {
+            g_message ("Integrated GPU %s selected as primary",
+                       meta_gpu_kms_get_file_path (gpu_kms));
+            return gpu_kms;
+          }
+      }
+
+    /* Otherwise a device we booted with */
+    for (l = gpus; l; l = l->next)
+      {
+        MetaGpuKms *gpu_kms = META_GPU_KMS (l->data);
+
+        if (meta_gpu_kms_is_boot_vga (gpu_kms) &&
+            (allow_sw == 1 ||
+             gpu_kms_is_hardware_rendering (renderer_native, gpu_kms)))
+          {
+            g_message ("Boot VGA GPU %s selected as primary",
+                       meta_gpu_kms_get_file_path (gpu_kms));
+            return gpu_kms;
+          }
+      }
+
+    /* Fall back to any device */
+    for (l = gpus; l; l = l->next)
+      {
+        MetaGpuKms *gpu_kms = META_GPU_KMS (l->data);
+
+        if (allow_sw == 1 ||
+            gpu_kms_is_hardware_rendering (renderer_native, gpu_kms))
+          {
+            g_message ("GPU %s selected as primary",
+                       meta_gpu_kms_get_file_path (gpu_kms));
+            return gpu_kms;
+          }
+      }
+  }
+
+  g_assert_not_reached ();
+  return NULL;
+}
+
+static MetaGpuKms *
+choose_primary_gpu (MetaBackend         *backend,
+                    MetaRendererNative  *renderer_native,
+                    GError             **error)
+{
+  MetaGpuKms *gpu_kms;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+
+  gpu_kms = choose_primary_gpu_unchecked (backend, renderer_native);
+  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                         gpu_kms);
+  render_device = renderer_gpu_data->render_device;
+  if (meta_render_device_get_egl_display (render_device) == EGL_NO_DISPLAY)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "The GPU %s chosen as primary is not supported by EGL.",
+                   meta_gpu_kms_get_file_path (gpu_kms));
+      return NULL;
+    }
+
+  return gpu_kms;
+}
+
+static gboolean
+meta_renderer_native_initable_init (GInitable     *initable,
+                                    GCancellable  *cancellable,
+                                    GError       **error)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (initable);
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  GList *gpus;
+  GList *l;
+
+  gpus = meta_backend_get_gpus (backend);
+  if (gpus)
+    {
+      MetaKmsDevice *kms_device;
+      MetaKmsDeviceFlag flags;
+      const char *kms_modifiers_debug_env;
+
+      for (l = gpus; l; l = l->next)
+        {
+          MetaGpuKms *gpu_kms = META_GPU_KMS (l->data);
+
+          if (!create_renderer_gpu_data (renderer_native, gpu_kms, error))
+            return FALSE;
+        }
+
+      renderer_native->primary_gpu_kms = choose_primary_gpu (backend,
+                                                             renderer_native,
+                                                             error);
+      if (!renderer_native->primary_gpu_kms)
+        return FALSE;
+
+      kms_device = meta_gpu_kms_get_kms_device (renderer_native->primary_gpu_kms);
+      flags = meta_kms_device_get_flags (kms_device);
+
+      kms_modifiers_debug_env = g_getenv ("MUTTER_DEBUG_USE_KMS_MODIFIERS");
+      if (kms_modifiers_debug_env)
+        {
+          renderer_native->use_modifiers =
+            g_strcmp0 (kms_modifiers_debug_env, "1") == 0;
+        }
+      else
+        {
+          renderer_native->use_modifiers =
+            !(flags & META_KMS_DEVICE_FLAG_DISABLE_MODIFIERS) &&
+            flags & META_KMS_DEVICE_FLAG_HAS_ADDFB2;
+        }
+
+      meta_topic (META_DEBUG_KMS, "Usage of KMS modifiers is %s",
+                  renderer_native->use_modifiers ? "enabled" : "disabled");
+
+      kms_modifiers_debug_env = g_getenv ("MUTTER_DEBUG_SEND_KMS_MODIFIERS");
+      if (kms_modifiers_debug_env)
+        {
+          renderer_native->send_modifiers =
+            g_strcmp0 (kms_modifiers_debug_env, "1") == 0;
+        }
+      else
+        {
+          renderer_native->send_modifiers =
+            !(flags & META_KMS_DEVICE_FLAG_DISABLE_CLIENT_MODIFIERS) &&
+            flags & META_KMS_DEVICE_FLAG_HAS_ADDFB2;
+        }
+
+      meta_topic (META_DEBUG_KMS, "Sending KMS modifiers to clients is %s",
+                  renderer_native->send_modifiers ? "enabled" : "disabled");
+    }
+  else
+    {
+      if (!create_renderer_gpu_data (renderer_native, NULL, error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_iface->init = meta_renderer_native_initable_init;
+}
+
+static void
+meta_renderer_native_finalize (GObject *object)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (object);
+
+  g_clear_list (&renderer_native->power_save_page_flip_onscreens,
+                g_object_unref);
+  g_clear_handle_id (&renderer_native->power_save_page_flip_source_id,
+                     g_source_remove);
+
+  g_list_free (renderer_native->pending_mode_set_views);
+  g_hash_table_unref (renderer_native->mode_set_updates);
+
+  g_clear_handle_id (&renderer_native->release_unused_gpus_idle_id,
+                     g_source_remove);
+  clear_detached_onscreens (renderer_native);
+
+  g_hash_table_destroy (renderer_native->gpu_datas);
+  g_clear_object (&renderer_native->gles3);
+
+  G_OBJECT_CLASS (meta_renderer_native_parent_class)->finalize (object);
+}
+
+static void
+meta_renderer_native_constructed (GObject *object)
+{
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (object);
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+
+  if (meta_settings_is_experimental_feature_enabled (
+        settings, META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS))
+    renderer_native->use_modifiers = TRUE;
+
+  g_signal_connect (backend, "gpu-added",
+                    G_CALLBACK (on_gpu_added), renderer_native);
+  g_signal_connect (monitor_manager, "power-save-mode-changed",
+                    G_CALLBACK (on_power_save_mode_changed), renderer_native);
+
+  G_OBJECT_CLASS (meta_renderer_native_parent_class)->constructed (object);
+}
+
+static void
+meta_renderer_native_init (MetaRendererNative *renderer_native)
+{
+  renderer_native->gpu_datas =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) meta_renderer_native_gpu_data_free);
+  renderer_native->mode_set_updates =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) meta_kms_update_free);
+}
+
+static void
+meta_renderer_native_class_init (MetaRendererNativeClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  MetaRendererClass *renderer_class = META_RENDERER_CLASS (klass);
+
+  object_class->finalize = meta_renderer_native_finalize;
+  object_class->constructed = meta_renderer_native_constructed;
+
+  renderer_class->create_cogl_renderer = meta_renderer_native_create_cogl_renderer;
+  renderer_class->create_view = meta_renderer_native_create_view;
+  renderer_class->rebuild_views = meta_renderer_native_rebuild_views;
+  renderer_class->resume = meta_renderer_native_resume;
+}
+
+MetaRendererNative *
+meta_renderer_native_new (MetaBackendNative  *backend_native,
+                          GError            **error)
+{
+  return g_initable_new (META_TYPE_RENDERER_NATIVE,
+                         NULL,
+                         error,
+                         "backend", backend_native,
+                         NULL);
+}
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
--- a/src/backends/native/meta-renderer-view-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-view-native.c	2023-10-12 20:59:22.683834037 +0300
@@ -22,11 +22,28 @@
 
 #include "backends/native/meta-renderer-view-native.h"
 
+#include "backends/meta-output.h"
+#include "backends/native/meta-crtc-kms.h"
 #include "backends/native/meta-frame-native.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-output-kms.h"
+
+#include "clutter/clutter.h"
+
+typedef enum _MetaFrameSyncMode
+{
+  META_FRAME_SYNC_MODE_INIT,
+  META_FRAME_SYNC_MODE_ENABLED,
+  META_FRAME_SYNC_MODE_DISABLED,
+} MetaFrameSyncMode;
 
 struct _MetaRendererViewNative
 {
   MetaRendererView parent;
+
+  MetaFrameSyncMode requested_frame_sync_mode;
+  MetaFrameSyncMode frame_sync_mode;
 };
 
 G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
@@ -39,6 +56,104 @@
 }
 
 static void
+update_frame_sync_mode (MetaRendererViewNative *view_native,
+                        ClutterFrame           *frame,
+                        MetaOutput             *output,
+                        MetaFrameSyncMode       sync_mode)
+{
+  MetaFrameNative *frame_native;
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+  MetaKmsDevice *kms_device;
+  MetaKmsUpdate *kms_update;
+  ClutterFrameClock *frame_clock;
+
+  frame_native = meta_frame_native_from_frame (frame);
+
+  frame_clock =
+    clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+  kms_device = meta_kms_crtc_get_device (kms_crtc);
+
+  kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
+
+  switch (sync_mode)
+    {
+    case META_FRAME_SYNC_MODE_ENABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_VARIABLE);
+      meta_output_kms_set_vrr_mode (META_OUTPUT_KMS (output),
+                                    kms_update,
+                                    TRUE);
+      break;
+    case META_FRAME_SYNC_MODE_DISABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_FIXED);
+      meta_output_kms_set_vrr_mode (META_OUTPUT_KMS (output),
+                                    kms_update,
+                                    FALSE);
+      break;
+    case META_FRAME_SYNC_MODE_INIT:
+      g_assert_not_reached ();
+    }
+
+  view_native->frame_sync_mode = sync_mode;
+}
+
+static MetaFrameSyncMode
+get_applicable_sync_mode (MetaRendererViewNative *view_native,
+                          MetaOutput             *output)
+{
+  if (meta_output_is_vrr_disallowed (output))
+    return META_FRAME_SYNC_MODE_DISABLED;
+
+  return view_native->requested_frame_sync_mode;
+}
+
+void
+meta_renderer_view_native_maybe_update_frame_sync_mode (MetaRendererViewNative *view_native,
+                                                        ClutterFrame           *frame)
+{
+  MetaRendererView *view = META_RENDERER_VIEW (view_native);
+  MetaOutput *output;
+  MetaFrameSyncMode applicable_sync_mode;
+
+  output = meta_renderer_view_get_output (view);
+
+  if (!meta_output_is_vrr_capable (output))
+    return;
+
+  applicable_sync_mode =
+    get_applicable_sync_mode (view_native, output);
+
+  if (G_LIKELY (applicable_sync_mode == view_native->frame_sync_mode))
+    return;
+
+  update_frame_sync_mode (view_native,
+                          frame,
+                          output,
+                          applicable_sync_mode);
+}
+
+void
+meta_renderer_view_native_request_frame_sync (MetaRendererViewNative *view_native,
+                                              gboolean                enabled)
+{
+  view_native->requested_frame_sync_mode =
+    enabled
+    ? META_FRAME_SYNC_MODE_ENABLED
+    : META_FRAME_SYNC_MODE_DISABLED;
+}
+
+gboolean
+meta_renderer_view_native_is_frame_sync_enabled (MetaRendererViewNative *view_native)
+{
+  return view_native->frame_sync_mode == META_FRAME_SYNC_MODE_ENABLED;
+}
+
+static void
 meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
 {
   ClutterStageViewClass *stage_view_class = CLUTTER_STAGE_VIEW_CLASS (klass);
@@ -49,4 +164,6 @@
 static void
 meta_renderer_view_native_init (MetaRendererViewNative *view_native)
 {
+  view_native->requested_frame_sync_mode = META_FRAME_SYNC_MODE_DISABLED;
+  view_native->frame_sync_mode = META_FRAME_SYNC_MODE_INIT;
 }
diff '--color=auto' -uraN a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
--- a/src/backends/native/meta-renderer-view-native.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-view-native.h	2023-10-12 20:59:22.683834037 +0300
@@ -27,3 +27,11 @@
 #define META_TYPE_RENDERER_VIEW_NATIVE (meta_renderer_view_native_get_type ())
 G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                       META, RENDERER_VIEW_NATIVE, MetaRendererView)
+
+void meta_renderer_view_native_maybe_update_frame_sync_mode (MetaRendererViewNative *view_native,
+                                                             ClutterFrame           *frame);
+
+void meta_renderer_view_native_request_frame_sync (MetaRendererViewNative *view_native,
+                                                   gboolean                enabled);
+
+gboolean meta_renderer_view_native_is_frame_sync_enabled (MetaRendererViewNative *view_native);
diff '--color=auto' -uraN a/src/backends/native/meta-udev.c b/src/backends/native/meta-udev.c
--- a/src/backends/native/meta-udev.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-udev.c	2023-10-12 20:59:22.687167413 +0300
@@ -101,6 +101,13 @@
 }
 
 gboolean
+meta_is_udev_device_disable_vrr (GUdevDevice *device)
+{
+  return meta_has_udev_device_tag (device,
+                                   "mutter-device-disable-vrr");
+}
+
+gboolean
 meta_is_udev_device_ignore (GUdevDevice *device)
 {
   return meta_has_udev_device_tag (device, "mutter-device-ignore");
diff '--color=auto' -uraN a/src/backends/native/meta-udev.h b/src/backends/native/meta-udev.h
--- a/src/backends/native/meta-udev.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-udev.h	2023-10-12 20:59:22.687167413 +0300
@@ -32,6 +32,8 @@
 
 gboolean meta_is_udev_device_disable_modifiers (GUdevDevice *device);
 
+gboolean meta_is_udev_device_disable_vrr (GUdevDevice *device);
+
 gboolean meta_is_udev_device_ignore (GUdevDevice *device);
 
 gboolean meta_is_udev_test_device (GUdevDevice *device);
diff '--color=auto' -uraN a/src/backends/x11/meta-crtc-xrandr.c b/src/backends/x11/meta-crtc-xrandr.c
--- a/src/backends/x11/meta-crtc-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-crtc-xrandr.c	2023-10-12 20:59:22.710501037 +0300
@@ -34,6 +34,7 @@
 #include "backends/x11/meta-crtc-xrandr.h"
 
 #include <X11/Xlib-xcb.h>
+#include <X11/extensions/Xrender.h>
 #include <stdlib.h>
 #include <xcb/randr.h>
 
@@ -44,6 +45,9 @@
 #include "backends/x11/meta-gpu-xrandr.h"
 #include "backends/x11/meta-monitor-manager-xrandr.h"
 
+#define ALL_TRANSFORMS ((1 << (META_MONITOR_TRANSFORM_FLIPPED_270 + 1)) - 1)
+#define DOUBLE_TO_FIXED(d) ((xcb_render_fixed_t) ((d) * 65536))
+
 struct _MetaCrtcXrandr
 {
   MetaCrtc parent;
@@ -108,6 +112,63 @@
   *out_timestamp = reply->timestamp;
   free (reply);
 
+
+  return TRUE;
+}
+
+gboolean
+meta_crtc_xrandr_set_scale (MetaCrtc         *crtc,
+                            xcb_randr_crtc_t  xrandr_crtc,
+                            float             scale)
+{
+  MetaGpu *gpu = meta_crtc_get_gpu (crtc);
+  MetaBackend *backend = meta_gpu_get_backend (gpu);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorManagerXrandr *monitor_manager_xrandr =
+    META_MONITOR_MANAGER_XRANDR (monitor_manager);
+  Display *xdisplay;
+  const char *scale_filter;
+  xcb_connection_t *xcb_conn;
+  xcb_void_cookie_t transform_cookie;
+  xcb_generic_error_t *xcb_error = NULL;
+  xcb_render_transform_t transformation = {
+    DOUBLE_TO_FIXED (1), DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (0),
+    DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (1), DOUBLE_TO_FIXED (0),
+    DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (1)
+  };
+
+  if (!(meta_monitor_manager_get_capabilities (monitor_manager) &
+        META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return FALSE;
+
+  xdisplay = meta_monitor_manager_xrandr_get_xdisplay (monitor_manager_xrandr);
+  xcb_conn = XGetXCBConnection (xdisplay);
+
+  if (fabsf (scale - 1.0f) > 0.001)
+    {
+      scale_filter = FilterGood;
+      transformation.matrix11 = DOUBLE_TO_FIXED (1.0 / scale);
+      transformation.matrix22 = DOUBLE_TO_FIXED (1.0 / scale);
+    }
+  else
+    scale_filter = FilterFast;
+
+  transform_cookie =
+    xcb_randr_set_crtc_transform_checked (xcb_conn, xrandr_crtc, transformation,
+                                          strlen (scale_filter), scale_filter,
+                                          0, NULL);
+
+  xcb_error = xcb_request_check (xcb_conn, transform_cookie);
+  if (xcb_error)
+    {
+      meta_warning ("Impossible to set scaling on crtc %u to %f, error id %u",
+                    xrandr_crtc, scale, xcb_error->error_code);
+      g_clear_pointer (&xcb_error, free);
+
+      return FALSE;
+    }
+
   return TRUE;
 }
 
@@ -219,11 +280,34 @@
   return crtc_xrandr->current_mode;
 }
 
+static float
+meta_monitor_scale_from_transformation (XRRCrtcTransformAttributes *transformation)
+{
+  XTransform *xt;
+  float scale;
+
+  if (!transformation)
+    return 1.0f;
+
+  xt = &transformation->currentTransform;
+
+  if (xt->matrix[0][0] == xt->matrix[1][1])
+    scale = XFixedToDouble (xt->matrix[0][0]);
+  else
+    scale = XFixedToDouble (xt->matrix[0][0] + xt->matrix[1][1]) / 2.0;
+
+  g_return_val_if_fail (scale > 0.0f, 1.0f);
+
+  return 1.0f / scale;
+}
+
 MetaCrtcXrandr *
-meta_crtc_xrandr_new (MetaGpuXrandr      *gpu_xrandr,
-                      XRRCrtcInfo        *xrandr_crtc,
-                      RRCrtc              crtc_id,
-                      XRRScreenResources *resources)
+meta_crtc_xrandr_new (MetaGpuXrandr              *gpu_xrandr,
+                      XRRCrtcInfo                *xrandr_crtc,
+                      RRCrtc                      crtc_id,
+                      XRRScreenResources         *resources,
+                      XRRCrtcTransformAttributes *transform_attributes,
+                      float                       scale_multiplier)
 {
   MetaGpu *gpu = META_GPU (gpu_xrandr);
   MetaBackend *backend = meta_gpu_get_backend (gpu);
@@ -284,6 +368,9 @@
 
   if (crtc_xrandr->current_mode)
     {
+      float crtc_scale =
+        meta_monitor_scale_from_transformation (transform_attributes);
+
       meta_crtc_set_config (META_CRTC (crtc_xrandr),
                             &GRAPHENE_RECT_INIT (crtc_xrandr->rect.x,
                                                  crtc_xrandr->rect.y,
@@ -291,6 +378,11 @@
                                                  crtc_xrandr->rect.height),
                             crtc_xrandr->current_mode,
                             crtc_xrandr->transform);
+
+      if (scale_multiplier > 0.0f)
+        crtc_scale *= scale_multiplier;
+
+      meta_crtc_set_config_scale (META_CRTC (crtc_xrandr), crtc_scale);
     }
 
   return crtc_xrandr;
diff '--color=auto' -uraN a/src/backends/x11/meta-crtc-xrandr.h b/src/backends/x11/meta-crtc-xrandr.h
--- a/src/backends/x11/meta-crtc-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-crtc-xrandr.h	2023-10-12 20:59:22.710501037 +0300
@@ -41,12 +41,18 @@
                                       int                  n_outputs,
                                       xcb_timestamp_t     *out_timestamp);
 
+gboolean meta_crtc_xrandr_set_scale (MetaCrtc         *crtc,
+                                     xcb_randr_crtc_t  xrandr_crtc,
+                                     float             scale);
+
 gboolean meta_crtc_xrandr_is_assignment_changed (MetaCrtcXrandr     *crtc_xrandr,
                                                  MetaCrtcAssignment *crtc_assignment);
 
 MetaCrtcMode * meta_crtc_xrandr_get_current_mode (MetaCrtcXrandr *crtc_xrandr);
 
-MetaCrtcXrandr * meta_crtc_xrandr_new (MetaGpuXrandr      *gpu_xrandr,
-                                       XRRCrtcInfo        *xrandr_crtc,
-                                       RRCrtc              crtc_id,
-                                       XRRScreenResources *resources);
+MetaCrtcXrandr * meta_crtc_xrandr_new (MetaGpuXrandr              *gpu_xrandr,
+                                       XRRCrtcInfo                *xrandr_crtc,
+                                       RRCrtc                      crtc_id,
+                                       XRRScreenResources         *resources,
+                                       XRRCrtcTransformAttributes *transform_attributes,
+                                       float                       scale_multiplier);
diff '--color=auto' -uraN a/src/backends/x11/meta-gpu-xrandr.c b/src/backends/x11/meta-gpu-xrandr.c
--- a/src/backends/x11/meta-gpu-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-gpu-xrandr.c	2023-10-12 20:59:22.710501037 +0300
@@ -23,12 +23,14 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "backends/meta-crtc.h"
 #include "config.h"
 
 #include "backends/x11/meta-gpu-xrandr.h"
 
 #include <string.h>
 #include <X11/extensions/dpms.h>
+#include <X11/Xatom.h>
 #include <X11/Xlibint.h>
 
 #include "backends/meta-backend-private.h"
@@ -44,6 +46,8 @@
 
   XRRScreenResources *resources;
 
+  int min_screen_width;
+  int min_screen_height;
   int max_screen_width;
   int max_screen_height;
 };
@@ -57,6 +61,15 @@
 }
 
 void
+meta_gpu_xrandr_get_min_screen_size (MetaGpuXrandr *gpu_xrandr,
+                                     int           *min_width,
+                                     int           *min_height)
+{
+  *min_width = gpu_xrandr->min_screen_width;
+  *min_height = gpu_xrandr->min_screen_height;
+}
+
+void
 meta_gpu_xrandr_get_max_screen_size (MetaGpuXrandr *gpu_xrandr,
                                      int           *max_width,
                                      int           *max_height)
@@ -107,6 +120,59 @@
   return xmode->dotClock / (h_total * v_total);
 }
 
+static int
+get_current_dpi_scale (MetaMonitorManagerXrandr *manager_xrandr,
+                       MetaGpuXrandr            *gpu_xrandr)
+{
+  Atom actual;
+  int result, format;
+  unsigned long n, left;
+  g_autofree unsigned char *data = NULL;
+  g_auto(GStrv) resources = NULL;
+  Display *dpy;
+  int i;
+
+  if (gpu_xrandr->resources->timestamp ==
+      meta_monitor_manager_xrandr_get_config_timestamp (manager_xrandr))
+    {
+      MetaMonitorManager *monitor_manager = META_MONITOR_MANAGER (manager_xrandr);
+      MetaBackend *backend = meta_monitor_manager_get_backend (monitor_manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+
+      return meta_settings_get_ui_scaling_factor (settings);
+    }
+
+  dpy = meta_monitor_manager_xrandr_get_xdisplay (manager_xrandr);
+  result = XGetWindowProperty (dpy, DefaultRootWindow (dpy),
+                               XA_RESOURCE_MANAGER, 0L, 65536, False,
+                               XA_STRING, &actual, &format,
+                               &n, &left, &data);
+
+  if (result != Success || !data || actual != XA_STRING)
+    return 1;
+
+  resources = g_strsplit ((char *) data, "\n", -1);
+
+  for (i = 0; resources && resources[i]; ++i)
+    {
+      if (g_str_has_prefix (resources[i], "Xft.dpi:"))
+        {
+          g_auto(GStrv) res = g_strsplit (resources[i], "\t", 2);
+
+          if (res && res[0] && res[1])
+            {
+              guint64 dpi;
+              dpi = g_ascii_strtoull (res[1], NULL, 10);
+
+              if (dpi > 0 && dpi < 96 * 10)
+                return MAX (1, roundf ((float) dpi / 96.0f));
+            }
+        }
+    }
+
+  return 1;
+}
+
 static gboolean
 meta_gpu_xrandr_read_current (MetaGpu  *gpu,
                               GError  **error)
@@ -123,19 +189,20 @@
   RROutput primary_output;
   unsigned int i, j;
   GList *l;
-  int min_width, min_height;
   Screen *screen;
   GList *outputs = NULL;
   GList *modes = NULL;
   GList *crtcs = NULL;
+  gboolean has_transform;
+  int dpi_scale = 1;
 
   if (gpu_xrandr->resources)
     XRRFreeScreenResources (gpu_xrandr->resources);
   gpu_xrandr->resources = NULL;
 
   XRRGetScreenSizeRange (xdisplay, DefaultRootWindow (xdisplay),
-                         &min_width,
-                         &min_height,
+                         &gpu_xrandr->min_screen_width,
+                         &gpu_xrandr->min_screen_height,
                          &gpu_xrandr->max_screen_width,
                          &gpu_xrandr->max_screen_height);
 
@@ -182,22 +249,60 @@
     }
   meta_gpu_take_modes (gpu, modes);
 
+  has_transform = !!(meta_monitor_manager_get_capabilities (monitor_manager) &
+                     META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING);
+
+  if (has_transform &&
+      meta_monitor_manager_get_default_layout_mode (monitor_manager) ==
+      META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    dpi_scale = get_current_dpi_scale (monitor_manager_xrandr, gpu_xrandr);
+
   for (i = 0; i < (unsigned)resources->ncrtc; i++)
     {
       XRRCrtcInfo *xrandr_crtc;
+      XRRCrtcTransformAttributes *transform_attributes;
       RRCrtc crtc_id;
       MetaCrtcXrandr *crtc_xrandr;
 
       crtc_id = resources->crtcs[i];
       xrandr_crtc = XRRGetCrtcInfo (xdisplay,
                                     resources, crtc_id);
+
+      if (!has_transform ||
+          !XRRGetCrtcTransform (xdisplay, crtc_id, &transform_attributes))
+        transform_attributes = NULL;
+
       crtc_xrandr = meta_crtc_xrandr_new (gpu_xrandr,
-                                          xrandr_crtc, crtc_id, resources);
+                                          xrandr_crtc, crtc_id, resources,
+                                          transform_attributes, dpi_scale);
+      XFree (transform_attributes);
       XRRFreeCrtcInfo (xrandr_crtc);
 
       crtcs = g_list_append (crtcs, crtc_xrandr);
     }
 
+  if (has_transform && dpi_scale == 1 &&
+      meta_monitor_manager_get_default_layout_mode (monitor_manager) ==
+        META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      dpi_scale =
+        ceilf (meta_monitor_manager_get_maximum_crtc_scale (monitor_manager));
+
+      if (dpi_scale > 1)
+        {
+          for (l = crtcs; l; l = l->next)
+            {
+              MetaCrtc *crtc = l->data;
+              const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+
+              if (!crtc_config)
+                continue;
+
+              meta_crtc_set_config_scale (crtc, crtc_config->scale * dpi_scale);
+            }
+        }
+    }
+
   meta_gpu_take_crtcs (gpu, crtcs);
 
   primary_output = XRRGetOutputPrimary (xdisplay,
diff '--color=auto' -uraN a/src/backends/x11/meta-gpu-xrandr.h b/src/backends/x11/meta-gpu-xrandr.h
--- a/src/backends/x11/meta-gpu-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-gpu-xrandr.h	2023-10-12 20:59:22.710501037 +0300
@@ -30,6 +30,10 @@
 
 XRRScreenResources * meta_gpu_xrandr_get_resources (MetaGpuXrandr *gpu_xrandr);
 
+void meta_gpu_xrandr_get_min_screen_size (MetaGpuXrandr *gpu_xrandr,
+                                          int           *min_width,
+                                          int           *min_height);
+
 void meta_gpu_xrandr_get_max_screen_size (MetaGpuXrandr *gpu_xrandr,
                                           int           *max_width,
                                           int           *max_height);
diff '--color=auto' -uraN a/src/backends/x11/meta-monitor-manager-xrandr.c b/src/backends/x11/meta-monitor-manager-xrandr.c
--- a/src/backends/x11/meta-monitor-manager-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-monitor-manager-xrandr.c	2023-10-12 20:59:22.710501037 +0300
@@ -36,6 +36,7 @@
  * and udev.
  */
 
+#include "backends/meta-backend-types.h"
 #include "config.h"
 
 #include "backends/x11/meta-monitor-manager-xrandr.h"
@@ -64,6 +65,9 @@
  * http://git.gnome.org/browse/gnome-settings-daemon/tree/plugins/xsettings/gsd-xsettings-manager.c
  * for the reasoning */
 #define DPI_FALLBACK 96.0
+#define RANDR_VERSION_FORMAT(major, minor) ((major * 100) + minor)
+#define RANDR_TILING_MIN_VERSION RANDR_VERSION_FORMAT (1, 5)
+#define RANDR_TRANSFORM_MIN_VERSION RANDR_VERSION_FORMAT (1, 3)
 
 struct _MetaMonitorManagerXrandr
 {
@@ -72,13 +76,15 @@
   Display *xdisplay;
   int rr_event_base;
   int rr_error_base;
-  gboolean has_randr15;
+  int randr_version;
 
   xcb_timestamp_t last_xrandr_set_timestamp;
 
   GHashTable *tiled_monitor_atoms;
 };
 
+static MetaGpu * meta_monitor_manager_xrandr_get_gpu (MetaMonitorManagerXrandr *manager_xrandr);
+
 struct _MetaMonitorManagerXrandrClass
 {
   MetaMonitorManagerClass parent_class;
@@ -99,10 +105,10 @@
   return manager_xrandr->xdisplay;
 }
 
-gboolean
-meta_monitor_manager_xrandr_has_randr15 (MetaMonitorManagerXrandr *manager_xrandr)
+uint32_t
+meta_monitor_manager_xrandr_get_config_timestamp (MetaMonitorManagerXrandr *manager_xrandr)
 {
-  return manager_xrandr->has_randr15;
+  return manager_xrandr->last_xrandr_set_timestamp;
 }
 
 static GBytes *
@@ -191,6 +197,81 @@
   mtk_x11_error_trap_pop (manager_xrandr->xdisplay);
 }
 
+static void
+meta_monitor_manager_xrandr_update_screen_size (MetaMonitorManagerXrandr *manager_xrandr,
+                                                int                       width,
+                                                int                       height,
+                                                float                     scale)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
+  MetaGpu *gpu = meta_monitor_manager_xrandr_get_gpu (manager_xrandr);
+  xcb_connection_t *xcb_conn;
+  xcb_generic_error_t *xcb_error;
+  xcb_void_cookie_t xcb_cookie;
+  Screen *screen;
+  int min_width;
+  int min_height;
+  int max_width;
+  int max_height;
+  int width_mm;
+  int height_mm;
+
+  g_assert (width > 0 && height > 0 && scale > 0);
+
+  if (manager->screen_width == width && manager->screen_height == height)
+    return;
+
+  screen = ScreenOfDisplay (manager_xrandr->xdisplay,
+                            DefaultScreen (manager_xrandr->xdisplay));
+  meta_gpu_xrandr_get_min_screen_size (META_GPU_XRANDR (gpu),
+                                       &min_width, &min_height);
+  meta_gpu_xrandr_get_max_screen_size (META_GPU_XRANDR (gpu),
+                                       &max_width, &max_height);
+  width = MIN (MAX (min_width, width), max_width);
+  height = MIN (MAX (min_height, height), max_height);
+
+  /* The 'physical size' of an X screen is meaningless if that screen can
+   * consist of many monitors. So just pick a size that make the dpi 96.
+   *
+   * Firefox and Evince apparently believe what X tells them.
+   */
+  width_mm = (width / (DPI_FALLBACK * scale)) * 25.4 + 0.5;
+  height_mm = (height / (DPI_FALLBACK * scale)) * 25.4 + 0.5;
+
+  if (width == WidthOfScreen (screen) && height == HeightOfScreen (screen) &&
+      width_mm == WidthMMOfScreen (screen) && height_mm == HeightMMOfScreen (screen))
+    return;
+
+  xcb_conn = XGetXCBConnection (manager_xrandr->xdisplay);
+
+  xcb_grab_server (xcb_conn);
+
+  /* Some drivers (nvidia I look at you!) might no advertise some CRTCs, so in
+   * such case, we may ignore X errors here */
+  xcb_cookie = xcb_randr_set_screen_size_checked (xcb_conn,
+                                                  DefaultRootWindow (manager_xrandr->xdisplay),
+                                                  width, height,
+                                                  width_mm, height_mm);
+  xcb_error = xcb_request_check (xcb_conn, xcb_cookie);
+  if (!xcb_error)
+    {
+      manager->screen_width = width;
+      manager->screen_height = height;
+    }
+  else
+    {
+      gchar buf[64];
+
+      XGetErrorText (manager_xrandr->xdisplay, xcb_error->error_code, buf,
+                     sizeof (buf) - 1);
+      meta_warning ("Impossible to resize screen at size %dx%d, error id %u: %s",
+                    width, height, xcb_error->error_code, buf);
+      g_clear_pointer (&xcb_error, free);
+    }
+
+  xcb_ungrab_server (xcb_conn);
+}
+
 static xcb_randr_rotation_t
 meta_monitor_transform_to_xrandr (MetaMonitorTransform transform)
 {
@@ -246,13 +327,50 @@
   return TRUE;
 }
 
+static float
+get_maximum_crtc_assignments_scale (MetaCrtcAssignment **crtc_assignments,
+                                    unsigned int         n_crtc_assignments)
+{
+  float max_scale = 1.0f;
+  unsigned int i;
+
+  for (i = 0; i < n_crtc_assignments; i++)
+    {
+      MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
+
+      if (crtc_assignment->mode)
+        max_scale = MAX (max_scale, crtc_assignment->scale);
+    }
+
+  return max_scale;
+}
+
 static gboolean
-is_crtc_assignment_changed (MetaCrtc            *crtc,
+is_crtc_assignment_changed (MetaMonitorManager  *monitor_manager,
+                            MetaCrtc            *crtc,
                             MetaCrtcAssignment **crtc_assignments,
-                            unsigned int         n_crtc_assignments)
+                            unsigned int         n_crtc_assignments,
+                            gboolean            *weak_change)
 {
+  MetaLogicalMonitorLayoutMode layout_mode;
+  gboolean have_scaling;
+  float max_crtc_scale = 1.0f;
+  float max_req_scale = 1.0f;
   unsigned int i;
 
+  layout_mode = meta_monitor_manager_get_default_layout_mode (monitor_manager);
+  have_scaling = meta_monitor_manager_get_capabilities (monitor_manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  if (have_scaling &&
+      layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      max_crtc_scale =
+        meta_monitor_manager_get_maximum_crtc_scale (monitor_manager);
+      max_req_scale =
+        get_maximum_crtc_assignments_scale (crtc_assignments, n_crtc_assignments);
+    }
+
   for (i = 0; i < n_crtc_assignments; i++)
     {
       MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
@@ -260,8 +378,44 @@
       if (crtc_assignment->crtc != crtc)
         continue;
 
-      return meta_crtc_xrandr_is_assignment_changed (META_CRTC_XRANDR (crtc),
-                                                     crtc_assignment);
+      if (meta_crtc_xrandr_is_assignment_changed (META_CRTC_XRANDR (crtc),
+                                                  crtc_assignment))
+        return TRUE;
+
+      if (have_scaling)
+        {
+          const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+          float crtc_scale = crtc_config ? crtc_config->scale : 1.0f;
+          float req_output_scale = crtc_assignment->scale;
+
+          if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL)
+            {
+              if (fmodf (crtc_scale, 1.0) == 0.0f)
+                {
+                  *weak_change = fabsf (crtc_scale - req_output_scale) > 0.001;
+                  return FALSE;
+                }
+            }
+          else if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+            {
+              /* In scale ui-down mode we need to check if the actual output
+               * scale that will be applied to the crtc has actually changed
+               * from the current value, so we need to compare the current crtc
+               * scale with the scale that will be applied taking care of the
+               * UI scale (max crtc scale) and of the requested maximum scale.
+               * If we don't do this, we'd try to call randr calls which won't
+               * ever trigger a RRScreenChangeNotify, as no actual change is
+               * needed, and thus we won't ever emit a monitors-changed signal.
+               */
+              crtc_scale /= ceilf (max_crtc_scale);
+              req_output_scale /= ceilf (max_req_scale);
+            }
+
+          if (fabsf (crtc_scale - req_output_scale) > 0.001)
+            return TRUE;
+        }
+
+      return FALSE;
     }
 
   return !!meta_crtc_xrandr_get_current_mode (META_CRTC_XRANDR (crtc));
@@ -349,7 +503,8 @@
                         MetaCrtcAssignment   **crtc_assignments,
                         unsigned int           n_crtc_assignments,
                         MetaOutputAssignment **output_assignments,
-                        unsigned int           n_output_assignments)
+                        unsigned int           n_output_assignments,
+                        gboolean              *weak_change)
 {
   MetaMonitorManagerXrandr *manager_xrandr =
     META_MONITOR_MANAGER_XRANDR (manager);
@@ -360,7 +515,9 @@
     {
       MetaCrtc *crtc = l->data;
 
-      if (is_crtc_assignment_changed (crtc, crtc_assignments, n_crtc_assignments))
+      if (is_crtc_assignment_changed (manager, crtc,
+                                      crtc_assignments, n_crtc_assignments,
+                                      weak_change))
         return TRUE;
     }
 
@@ -376,6 +533,32 @@
         return TRUE;
     }
 
+  if (meta_monitor_manager_get_default_layout_mode (manager) ==
+      META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      /* If nothing has changed, ensure that the crtc logical scaling matches
+       * with the requested one, as in case of global UI logical layout we might
+       * assume that it is in fact equal, while it's techincally different.
+       * Not doing this would then cause a wrong computation of the max crtc
+       * scale and thus of the UI scaling. */
+      for (l = meta_gpu_get_crtcs (gpu); l; l = l->next)
+        {
+          MetaCrtc *crtc = l->data;
+          unsigned int i;
+
+          for (i = 0; i < n_crtc_assignments; i++)
+            {
+              MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
+
+              if (crtc_assignment->crtc == crtc)
+                {
+                  meta_crtc_set_config_scale (crtc, crtc_assignment->scale);
+                  break;
+                }
+            }
+        }
+    }
+
   return FALSE;
 }
 
@@ -391,31 +574,55 @@
   MetaGpu *gpu = meta_monitor_manager_xrandr_get_gpu (manager_xrandr);
   g_autoptr (GList) to_configure_outputs = NULL;
   g_autoptr (GList) to_disable_crtcs = NULL;
-  unsigned i;
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+  unsigned i, valid_crtcs;
   GList *l;
-  int width, height, width_mm, height_mm;
+  int width, height;
+  float max_scale;
+  float avg_screen_scale;
+  gboolean have_scaling;
 
   to_configure_outputs = g_list_copy (meta_gpu_get_outputs (gpu));
   to_disable_crtcs = g_list_copy (meta_gpu_get_crtcs (gpu));
 
   XGrabServer (manager_xrandr->xdisplay);
 
-  /* First compute the new size of the screen (framebuffer) */
+  have_scaling = meta_monitor_manager_get_capabilities (manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  /* Compute the new size of the screen (framebuffer) */
+  max_scale = get_maximum_crtc_assignments_scale (crtcs, n_crtcs);
   width = 0; height = 0;
+  avg_screen_scale = 0;
+  valid_crtcs = 0;
   for (i = 0; i < n_crtcs; i++)
     {
       MetaCrtcAssignment *crtc_assignment = crtcs[i];
       MetaCrtc *crtc = crtc_assignment->crtc;
+      float scale = 1.0f;
 
       if (crtc_assignment->mode == NULL)
         continue;
 
       to_disable_crtcs = g_list_remove (to_disable_crtcs, crtc);
 
-      width = MAX (width, (int) roundf (crtc_assignment->layout.origin.x +
-                                        crtc_assignment->layout.size.width));
-      height = MAX (height, (int) roundf (crtc_assignment->layout.origin.y +
-                                          crtc_assignment->layout.size.height));
+      if (have_scaling && scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+        {
+          scale = (ceilf (max_scale) / crtc_assignment->scale) *
+            crtc_assignment->scale;
+        }
+
+      width = MAX (width,
+                   (int) roundf (crtc_assignment->layout.origin.x +
+                                 crtc_assignment->layout.size.width * scale));
+      height = MAX (height,
+                    (int) roundf (crtc_assignment->layout.origin.y +
+                                  crtc_assignment->layout.size.height * scale));
+
+      avg_screen_scale += (crtc_assignment->scale - avg_screen_scale) /
+                          (float) (++valid_crtcs);
     }
 
   /* Second disable all newly disabled CRTCs, or CRTCs that in the previous
@@ -449,6 +656,10 @@
                                   0, 0, XCB_NONE,
                                   XCB_RANDR_ROTATION_ROTATE_0,
                                   NULL, 0);
+          if (have_scaling)
+            meta_crtc_xrandr_set_scale (crtc,
+                                        (xcb_randr_crtc_t) meta_crtc_get_id (crtc),
+                                        1.0f);
 
           meta_crtc_unset_config (crtc);
         }
@@ -469,6 +680,10 @@
                               0, 0, XCB_NONE,
                               XCB_RANDR_ROTATION_ROTATE_0,
                               NULL, 0);
+      if (have_scaling)
+        meta_crtc_xrandr_set_scale (crtc,
+                                    (xcb_randr_crtc_t) meta_crtc_get_id (crtc),
+                                    1.0f);
 
       meta_crtc_unset_config (crtc);
     }
@@ -476,17 +691,12 @@
   if (!n_crtcs)
     goto out;
 
-  g_assert (width > 0 && height > 0);
-  /* The 'physical size' of an X screen is meaningless if that screen
-   * can consist of many monitors. So just pick a size that make the
-   * dpi 96.
-   *
-   * Firefox and Evince apparently believe what X tells them.
-   */
-  width_mm = (width / DPI_FALLBACK) * 25.4 + 0.5;
-  height_mm = (height / DPI_FALLBACK) * 25.4 + 0.5;
-  XRRSetScreenSize (manager_xrandr->xdisplay, DefaultRootWindow (manager_xrandr->xdisplay),
-                    width, height, width_mm, height_mm);
+  if (width > manager->screen_width || height > manager->screen_height)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      width, height,
+                                                      avg_screen_scale);
+    }
 
   for (i = 0; i < n_crtcs; i++)
     {
@@ -502,12 +712,21 @@
           int x, y;
           xcb_randr_rotation_t rotation;
           xcb_randr_mode_t mode;
+          float scale = 1.0f;
 
           crtc_mode = crtc_assignment->mode;
 
           n_output_ids = crtc_assignment->outputs->len;
           output_ids = g_new (xcb_randr_output_t, n_output_ids);
 
+          if (have_scaling && scale_mode != META_X11_SCALE_MODE_NONE)
+            {
+              scale = crtc_assignment->scale;
+
+              if (scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+                scale /= ceilf (max_scale);
+            }
+
           for (j = 0; j < n_output_ids; j++)
             {
               MetaOutput *output;
@@ -532,6 +751,14 @@
           rotation =
             meta_monitor_transform_to_xrandr (crtc_assignment->transform);
           mode =  meta_crtc_mode_get_id (crtc_mode);
+
+          if (have_scaling &&
+              !meta_crtc_xrandr_set_scale (crtc, crtc_id, scale))
+            {
+              meta_warning ("Scalig CRTC %d at %f failed\n",
+                            (unsigned) crtc_id, scale);
+            }
+
           if (!xrandr_set_crtc_config (manager_xrandr,
                                        crtc,
                                        save_timestamp,
@@ -560,6 +787,20 @@
                                 &crtc_assignment->layout,
                                 crtc_mode,
                                 crtc_assignment->transform);
+          meta_crtc_set_config_scale (crtc, crtc_assignment->scale);
+
+          if (have_scaling && scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+            {
+              const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+              graphene_size_t *crtc_size =
+                (graphene_size_t *) &crtc_config->layout.size;
+
+              scale = (ceilf (max_scale) / crtc_assignment->scale) *
+                crtc_assignment->scale;
+
+              crtc_size->width = roundf (crtc_size->width * scale);
+              crtc_size->height = roundf (crtc_size->height * scale);
+            }
         }
     }
 
@@ -575,6 +816,13 @@
                   (GFunc) meta_output_unassign_crtc,
                   NULL);
 
+  if (width > 0 && height > 0)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      width, height,
+                                                      avg_screen_scale);
+    }
+
 out:
   XUngrabServer (manager_xrandr->xdisplay);
   XFlush (manager_xrandr->xdisplay);
@@ -600,6 +848,91 @@
   meta_monitor_manager_update_logical_state_derived (manager, config);
 }
 
+static void
+meta_monitor_manager_xrandr_update_screen_size_derived (MetaMonitorManager *manager,
+                                                        MetaMonitorsConfig *config)
+{
+  MetaMonitorManagerXrandr *manager_xrandr =
+    META_MONITOR_MANAGER_XRANDR (manager);
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+  int screen_width = 0;
+  int screen_height = 0;
+  unsigned n_crtcs = 0;
+  float average_scale = 0;
+  gboolean have_scaling;
+  GList *l;
+
+  have_scaling = meta_monitor_manager_get_capabilities (manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  /* Compute the new size of the screen (framebuffer) */
+  for (l = manager->monitors; l != NULL; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaOutput *output = meta_monitor_get_main_output (monitor);
+      MetaCrtc *crtc = meta_output_get_assigned_crtc (output);
+      const MetaCrtcConfig *crtc_config;
+      const graphene_rect_t *crtc_layout;
+      float scale = 1.0f;
+
+      if (!crtc)
+        continue;
+
+      crtc_config = meta_crtc_get_config (crtc);
+
+      if (!crtc_config)
+        continue;
+
+      if (!have_scaling || scale_mode != META_X11_SCALE_MODE_UI_DOWN)
+        {
+          /* When scaling up we should not reduce the screen size, or X will
+           * fail miserably, while we must do it when scaling down, in order to
+           * increase the available screen area we can use. */
+          scale = crtc_config->scale > 1.0f ? crtc_config->scale : 1.0f;
+        }
+
+      /* When computing the screen size from the crtc rects we don't have to
+       * use inverted values when monitors are rotated, because this is already
+       * taken in account in the crtc rectangles */
+      crtc_layout = &crtc_config->layout;
+      screen_width = MAX (screen_width, crtc_layout->origin.x +
+                          roundf (crtc_layout->size.width * scale));
+      screen_height = MAX (screen_height, crtc_layout->origin.y +
+                           roundf (crtc_layout->size.height * scale));
+      ++n_crtcs;
+
+      /* This value isn't completely exact, since it doesn't take care of the
+       * actual crtc sizes, however, since w're going to use this only to set
+       * the MM size of the screen, and given that this value is just an
+       * estimation, we don't need to be super precise. */
+      average_scale += (crtc_config->scale - average_scale) / (float) n_crtcs;
+    }
+
+  if (screen_width > 0 && screen_height > 0)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      screen_width,
+                                                      screen_height,
+                                                      average_scale);
+    }
+}
+
+static void
+maybe_update_ui_scaling_factor (MetaMonitorManager *manager,
+                                MetaMonitorsConfig *config)
+{
+  if (config->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL ||
+      manager->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+
+      meta_settings_update_ui_scaling_factor (settings);
+    }
+}
+
 static gboolean
 meta_monitor_manager_xrandr_apply_monitors_config (MetaMonitorManager      *manager,
                                                    MetaMonitorsConfig      *config,
@@ -626,6 +959,8 @@
 
   if (method != META_MONITORS_CONFIG_METHOD_VERIFY)
     {
+      gboolean weak_change = FALSE;
+
       /*
        * If the assignment has not changed, we won't get any notification about
        * any new configuration from the X server; but we still need to update
@@ -633,12 +968,16 @@
        * have changed locally, such as the logical monitors scale. This means we
        * must check that our new assignment actually changes anything, otherwise
        * just update the logical state.
+       * If we record a weak change it means that only UI scaling needs to be
+       * updated and so that we don't have to reconfigure the CRTCs, but still
+       * need to update the logical state.
        */
       if (is_assignments_changed (manager,
                                   (MetaCrtcAssignment **) crtc_assignments->pdata,
                                   crtc_assignments->len,
                                   (MetaOutputAssignment **) output_assignments->pdata,
-                                  output_assignments->len))
+                                  output_assignments->len,
+                                  &weak_change))
         {
           apply_crtc_assignments (manager,
                                   TRUE,
@@ -646,9 +985,13 @@
                                   crtc_assignments->len,
                                   (MetaOutputAssignment **) output_assignments->pdata,
                                   output_assignments->len);
+          maybe_update_ui_scaling_factor (manager, config);
         }
       else
         {
+          if (weak_change)
+            maybe_update_ui_scaling_factor (manager, config);
+
           meta_monitor_manager_rebuild_derived (manager, config);
         }
     }
@@ -737,7 +1080,8 @@
   GList *l;
   int i;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   product = meta_monitor_get_product (monitor);
@@ -786,7 +1130,8 @@
 
   int monitor_count;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   monitor_xrandr_data = meta_monitor_xrandr_data_from_monitor (monitor);
@@ -804,10 +1149,12 @@
 static void
 meta_monitor_manager_xrandr_init_monitors (MetaMonitorManagerXrandr *manager_xrandr)
 {
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
   XRRMonitorInfo *m;
   int n, i;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   /* delete any tiled monitors setup, as mutter will want to recreate
@@ -839,6 +1186,18 @@
   return TRUE;
 }
 
+static MetaMonitorScalesConstraint
+get_scale_constraints (MetaMonitorManager *manager)
+{
+  MetaMonitorScalesConstraint constraints = 0;
+
+  if (meta_monitor_manager_get_capabilities (manager) &
+      META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED)
+    constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+
+  return constraints;
+}
+
 static float
 meta_monitor_manager_xrandr_calculate_monitor_mode_scale (MetaMonitorManager           *manager,
                                                           MetaLogicalMonitorLayoutMode  layout_mode,
@@ -847,7 +1206,7 @@
 {
   MetaMonitorScalesConstraint constraints;
 
-  constraints = META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+  constraints = get_scale_constraints (manager);
   return meta_monitor_calculate_mode_scale (monitor, monitor_mode, constraints);
 }
 
@@ -860,7 +1219,7 @@
 {
   MetaMonitorScalesConstraint constraints;
 
-  constraints = META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+  constraints = get_scale_constraints (manager);
   return meta_monitor_calculate_supported_scales (monitor, monitor_mode,
                                                   constraints,
                                                   n_supported_scales);
@@ -869,7 +1228,30 @@
 static MetaMonitorManagerCapability
 meta_monitor_manager_xrandr_get_capabilities (MetaMonitorManager *manager)
 {
-  return META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED;
+  MetaMonitorManagerCapability capabilities;
+  MetaMonitorManagerXrandr *xrandr_manager = META_MONITOR_MANAGER_XRANDR (manager);
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  capabilities = META_MONITOR_MANAGER_CAPABILITY_NONE;
+
+  if (xrandr_manager->randr_version >= RANDR_TILING_MIN_VERSION)
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_TILING;
+
+  if (xrandr_manager->randr_version >= RANDR_TRANSFORM_MIN_VERSION)
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  if (meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    {
+      capabilities |= META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE;
+    }
+  else
+    {
+      capabilities |= META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED;
+    }
+
+  return capabilities;
 }
 
 static gboolean
@@ -887,9 +1269,41 @@
   return TRUE;
 }
 
+static void
+scale_mode_changed (MetaSettings       *settings,
+                    MetaMonitorManager *manager)
+{
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return;
+
+  if (!meta_settings_is_experimental_feature_enabled (settings,
+      META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    return;
+
+  meta_monitor_manager_reconfigure (manager);
+  meta_settings_update_ui_scaling_factor (settings);
+}
+
 static MetaLogicalMonitorLayoutMode
 meta_monitor_manager_xrandr_get_default_layout_mode (MetaMonitorManager *manager)
 {
+  MetaMonitorManagerCapability capabilities =
+    meta_monitor_manager_get_capabilities (manager);
+
+  if ((capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING) &&
+      (capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+      MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+
+      if (scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+        return META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL;
+      else if (scale_mode == META_X11_SCALE_MODE_UP)
+        return META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL;
+    }
+
   return META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
 }
 
@@ -908,6 +1322,7 @@
   MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
   MetaBackend *backend = meta_monitor_manager_get_backend (manager);
   MetaBackendX11 *backend_x11 = META_BACKEND_X11 (backend);
+  MetaSettings *settings = meta_backend_get_settings (backend);
 
   manager_xrandr->xdisplay = meta_backend_x11_get_xdisplay (backend_x11);
 
@@ -928,19 +1343,19 @@
 		      | RRCrtcChangeNotifyMask
 		      | RROutputPropertyNotifyMask);
 
-      manager_xrandr->has_randr15 = FALSE;
       XRRQueryVersion (manager_xrandr->xdisplay, &major_version,
                        &minor_version);
-      if (major_version > 1 ||
-          (major_version == 1 &&
-           minor_version >= 5))
-        {
-          manager_xrandr->has_randr15 = TRUE;
-          manager_xrandr->tiled_monitor_atoms = g_hash_table_new (NULL, NULL);
-        }
+      manager_xrandr->randr_version = RANDR_VERSION_FORMAT (major_version,
+                                                            minor_version);
+      if (manager_xrandr->randr_version >= RANDR_TILING_MIN_VERSION)
+        manager_xrandr->tiled_monitor_atoms = g_hash_table_new (NULL, NULL);
+
       meta_monitor_manager_xrandr_init_monitors (manager_xrandr);
     }
 
+  g_signal_connect_object (settings, "x11-scale-mode-changed",
+                           G_CALLBACK (scale_mode_changed), manager_xrandr, 0);
+
   G_OBJECT_CLASS (meta_monitor_manager_xrandr_parent_class)->constructed (object);
 }
 
@@ -972,6 +1387,7 @@
   manager_class->read_current_state = meta_monitor_manager_xrandr_read_current_state;
   manager_class->ensure_initial_config = meta_monitor_manager_xrandr_ensure_initial_config;
   manager_class->apply_monitors_config = meta_monitor_manager_xrandr_apply_monitors_config;
+  manager_class->update_screen_size_derived = meta_monitor_manager_xrandr_update_screen_size_derived;
   manager_class->set_power_save_mode = meta_monitor_manager_xrandr_set_power_save_mode;
   manager_class->change_backlight = meta_monitor_manager_xrandr_change_backlight;
   manager_class->tiled_monitor_added = meta_monitor_manager_xrandr_tiled_monitor_added;
diff '--color=auto' -uraN a/src/backends/x11/meta-monitor-manager-xrandr.h b/src/backends/x11/meta-monitor-manager-xrandr.h
--- a/src/backends/x11/meta-monitor-manager-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-monitor-manager-xrandr.h	2023-10-12 20:59:22.710501037 +0300
@@ -32,7 +32,7 @@
 
 Display * meta_monitor_manager_xrandr_get_xdisplay (MetaMonitorManagerXrandr *manager_xrandr);
 
-gboolean meta_monitor_manager_xrandr_has_randr15 (MetaMonitorManagerXrandr *manager_xrandr);
-
 gboolean meta_monitor_manager_xrandr_handle_xevent (MetaMonitorManagerXrandr *manager,
                                                     XEvent                   *event);
+
+uint32_t meta_monitor_manager_xrandr_get_config_timestamp (MetaMonitorManagerXrandr *manager);
diff '--color=auto' -uraN a/src/backends/x11/meta-output-xrandr.c b/src/backends/x11/meta-output-xrandr.c
--- a/src/backends/x11/meta-output-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-output-xrandr.c	2023-10-12 20:59:22.710501037 +0300
@@ -1005,7 +1005,8 @@
       output_info->height_mm = xrandr_output->mm_height;
     }
 
-  if (meta_monitor_manager_xrandr_has_randr15 (monitor_manager_xrandr))
+  if ((meta_monitor_manager_get_capabilities (monitor_manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     output_info_init_tile_info (output_info, xdisplay, output_id);
   output_info_init_modes (output_info, gpu, xrandr_output);
   output_info_init_crtcs (output_info, gpu, xrandr_output);
diff '--color=auto' -uraN a/src/backends/x11/nested/meta-renderer-x11-nested.c b/src/backends/x11/nested/meta-renderer-x11-nested.c
--- a/src/backends/x11/nested/meta-renderer-x11-nested.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/nested/meta-renderer-x11-nested.c	2023-10-12 20:59:22.687167413 +0300
@@ -138,6 +138,7 @@
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "refresh-rate", mode_info->refresh_rate,
                        "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                        "offscreen", COGL_FRAMEBUFFER (offscreen),
diff '--color=auto' -uraN a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
--- a/src/compositor/meta-compositor-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-native.c	2023-10-12 20:59:22.687167413 +0300
@@ -43,6 +43,9 @@
                                                     compositor);
 #endif
 
+  meta_compositor_view_native_maybe_update_frame_sync_surface (compositor_view_native,
+                                                               compositor);
+
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
   parent_class->before_paint (compositor, compositor_view);
 }
diff '--color=auto' -uraN a/src/compositor/meta-compositor-view-native.c b/src/compositor/meta-compositor-view-native.c
--- a/src/compositor/meta-compositor-view-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-view-native.c	2023-10-12 20:59:22.687167413 +0300
@@ -26,14 +26,20 @@
 
 #include "backends/meta-crtc.h"
 #include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-renderer-view-native.h"
+#include "clutter/clutter.h"
 #include "compositor/compositor-private.h"
 #include "compositor/meta-window-actor-private.h"
+#include "core/window-private.h"
 
 #ifdef HAVE_WAYLAND
 #include "compositor/meta-surface-actor-wayland.h"
 #include "wayland/meta-wayland-surface.h"
 #endif /* HAVE_WAYLAND */
 
+static void update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                       MetaSurfaceActor         *surface_actor);
+
 struct _MetaCompositorViewNative
 {
   MetaCompositorView parent;
@@ -41,11 +47,52 @@
 #ifdef HAVE_WAYLAND
   MetaWaylandSurface *scanout_candidate;
 #endif /* HAVE_WAYLAND */
+
+  MetaSurfaceActor *frame_sync_surface;
+
+  gulong frame_sync_surface_repaint_scheduled_id;
+  gulong frame_sync_surface_frozen_id;
+  gulong frame_sync_surface_destroy_id;
 };
 
 G_DEFINE_TYPE (MetaCompositorViewNative, meta_compositor_view_native,
                META_TYPE_COMPOSITOR_VIEW)
 
+static void
+on_frame_sync_surface_repaint_scheduled (MetaSurfaceActor         *surface_actor,
+                                         MetaCompositorViewNative *view_native)
+{
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view;
+  MetaRendererViewNative *renderer_view_native;
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  renderer_view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+
+  if (meta_renderer_view_native_is_frame_sync_enabled (renderer_view_native))
+    {
+      ClutterFrameClock *frame_clock;
+
+      frame_clock = clutter_stage_view_get_frame_clock (stage_view);
+
+      clutter_frame_clock_schedule_update_now (frame_clock);
+    }
+}
+
+static void
+on_frame_sync_surface_frozen (MetaSurfaceActor         *surface_actor,
+                              MetaCompositorViewNative *view_native)
+{
+  update_frame_sync_surface (view_native, NULL);
+}
+
+static void
+on_frame_sync_surface_destroyed (MetaSurfaceActor         *surface_actor,
+                                 MetaCompositorViewNative *view_native)
+{
+  update_frame_sync_surface (view_native, NULL);
+}
+
 #ifdef HAVE_WAYLAND
 static void
 update_scanout_candidate (MetaCompositorViewNative *view_native,
@@ -269,6 +316,151 @@
 }
 #endif /* HAVE_WAYLAND */
 
+static MetaSurfaceActor *
+find_frame_sync_candidate (MetaCompositorView *compositor_view,
+                           MetaCompositor     *compositor)
+{
+  MetaWindowActor *window_actor;
+  MetaWindow *window;
+  ClutterStageView *stage_view;
+  MtkRectangle view_layout;
+  MetaSurfaceActor *surface_actor;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: unredirect inhibited");
+      return NULL;
+    }
+
+  window_actor =
+    meta_compositor_view_get_top_window_actor (compositor_view);
+  if (!window_actor)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: no top window actor");
+      return NULL;
+    }
+
+  if (meta_window_actor_is_frozen (window_actor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor is frozen");
+      return NULL;
+    }
+
+  if (meta_window_actor_effect_in_progress (window_actor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor effects in progress");
+      return NULL;
+    }
+
+  if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor has transition");
+      return NULL;
+    }
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  if (!window)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: no meta-window");
+      return NULL;
+    }
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+
+  clutter_stage_view_get_layout (stage_view, &view_layout);
+
+  if (!meta_window_frame_contains_rect (window, &view_layout))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: stage-view layout not covered "
+                  "by meta-window frame");
+      return NULL;
+    }
+
+  surface_actor = meta_window_actor_get_scanout_candidate (window_actor);
+  if (!surface_actor)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor has no scanout candidate");
+      return NULL;
+    }
+
+  if (!meta_surface_actor_contains_rect (surface_actor,
+                                         &view_layout))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: stage-view layout not covered "
+                  "by surface-actor");
+      return NULL;
+    }
+
+  return surface_actor;
+}
+
+static void
+update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                           MetaSurfaceActor         *surface_actor)
+{
+  MetaCompositorView *compositor_view =
+    META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view;
+  MetaRendererViewNative *renderer_view_native;
+
+  g_clear_signal_handler (&view_native->frame_sync_surface_repaint_scheduled_id,
+                          view_native->frame_sync_surface);
+  g_clear_signal_handler (&view_native->frame_sync_surface_frozen_id,
+                          view_native->frame_sync_surface);
+  g_clear_signal_handler (&view_native->frame_sync_surface_destroy_id,
+                          view_native->frame_sync_surface);
+
+  if (surface_actor)
+    {
+      view_native->frame_sync_surface_repaint_scheduled_id =
+        g_signal_connect (surface_actor, "repaint-scheduled",
+                          G_CALLBACK (on_frame_sync_surface_repaint_scheduled),
+                          view_native);
+      view_native->frame_sync_surface_frozen_id =
+        g_signal_connect (surface_actor, "frozen",
+                          G_CALLBACK (on_frame_sync_surface_frozen),
+                          view_native);
+      view_native->frame_sync_surface_destroy_id =
+        g_signal_connect (surface_actor, "destroy",
+                          G_CALLBACK (on_frame_sync_surface_destroyed),
+                          view_native);
+    }
+
+  view_native->frame_sync_surface = surface_actor;
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  renderer_view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+
+  meta_renderer_view_native_request_frame_sync (renderer_view_native,
+                                                surface_actor != NULL);
+}
+
+void
+meta_compositor_view_native_maybe_update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                                             MetaCompositor           *compositor)
+{
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  MetaSurfaceActor *surface_actor;
+
+  surface_actor = find_frame_sync_candidate (compositor_view,
+                                             compositor);
+
+  if (G_LIKELY (surface_actor == view_native->frame_sync_surface))
+    return;
+
+  update_frame_sync_surface (view_native,
+                             surface_actor);
+}
+
 MetaCompositorViewNative *
 meta_compositor_view_native_new (ClutterStageView *stage_view)
 {
@@ -280,6 +472,25 @@
 }
 
 static void
+meta_compositor_view_native_dispose (GObject *object)
+{
+  MetaCompositorViewNative *view_native = META_COMPOSITOR_VIEW_NATIVE (object);
+
+  if (view_native->frame_sync_surface)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_surface_repaint_scheduled_id,
+                              view_native->frame_sync_surface);
+      g_clear_signal_handler (&view_native->frame_sync_surface_destroy_id,
+                              view_native->frame_sync_surface);
+      g_clear_signal_handler (&view_native->frame_sync_surface_frozen_id,
+                              view_native->frame_sync_surface);
+      view_native->frame_sync_surface = NULL;
+    }
+
+  G_OBJECT_CLASS (meta_compositor_view_native_parent_class)->dispose (object);
+}
+
+static void
 meta_compositor_view_native_finalize (GObject *object)
 {
 #ifdef HAVE_WAYLAND
@@ -296,6 +507,7 @@
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
+  object_class->dispose = meta_compositor_view_native_dispose;
   object_class->finalize = meta_compositor_view_native_finalize;
 }
 
diff '--color=auto' -uraN a/src/compositor/meta-compositor-view-native.h b/src/compositor/meta-compositor-view-native.h
--- a/src/compositor/meta-compositor-view-native.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-view-native.h	2023-10-12 20:59:22.687167413 +0300
@@ -36,3 +36,6 @@
 void meta_compositor_view_native_maybe_assign_scanout (MetaCompositorViewNative *view_native,
                                                        MetaCompositor           *compositor);
 #endif /* HAVE_WAYLAND */
+
+void meta_compositor_view_native_maybe_update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                                                  MetaCompositor           *compositor);
diff '--color=auto' -uraN a/src/compositor/meta-compositor-x11.c b/src/compositor/meta-compositor-x11.c
--- a/src/compositor/meta-compositor-x11.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-x11.c	2023-10-12 20:59:22.710501037 +0300
@@ -30,6 +30,7 @@
 #include "compositor/meta-sync-ring.h"
 #include "compositor/meta-window-actor-x11.h"
 #include "core/display-private.h"
+#include "core/window-private.h"
 #include "x11/meta-x11-display-private.h"
 
 struct _MetaCompositorX11
@@ -49,6 +50,8 @@
   gboolean xserver_uses_monotonic_clock;
   int64_t xserver_time_query_time_us;
   int64_t xserver_time_offset_us;
+
+  gboolean randr_scale_disabled;
 };
 
 G_DEFINE_TYPE (MetaCompositorX11, meta_compositor_x11, META_TYPE_COMPOSITOR)
@@ -267,19 +270,90 @@
 }
 
 static void
+on_redirected_monitor_changed (MetaWindow        *window,
+                               int                old_monitor,
+                               MetaCompositorX11 *compositor_x11)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaDisplay *display = meta_compositor_get_display (compositor);
+  MetaContext *context = meta_display_get_context (display);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+
+  if (old_monitor >= 0 && window->monitor &&
+      window->monitor->number != old_monitor)
+    {
+      g_signal_handlers_block_by_func (window,
+                                       on_redirected_monitor_changed,
+                                       compositor_x11);
+
+      if (!compositor_x11->randr_scale_disabled)
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            window->monitor);
+        }
+
+      g_signal_handlers_unblock_by_func (window,
+                                         on_redirected_monitor_changed,
+                                         compositor_x11);
+    }
+  else
+    shape_cow_for_window (META_COMPOSITOR_X11 (compositor_x11), window);
+}
+
+static MetaWindow *
+get_unredirectable_window (MetaCompositorX11 *compositor_x11)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaWindowActor *window_actor;
+  MetaWindowActorX11 *window_actor_x11;
+
+  window_actor = meta_compositor_get_top_window_actor (compositor);
+  if (!window_actor)
+    return NULL;
+
+  window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
+  if (!meta_window_actor_x11_should_unredirect (window_actor_x11))
+    return NULL;
+
+  return meta_window_actor_get_meta_window (window_actor);
+}
+
+static void
 set_unredirected_window (MetaCompositorX11 *compositor_x11,
                          MetaWindow        *window)
 {
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaDisplay *display = meta_compositor_get_display (compositor);
+  MetaContext *context = meta_display_get_context (display);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager = meta_backend_get_monitor_manager (backend);
   MetaWindow *prev_unredirected_window = compositor_x11->unredirected_window;
 
   if (prev_unredirected_window == window)
-    return;
+    {
+      if (!window && compositor_x11->randr_scale_disabled &&
+          !get_unredirectable_window (compositor_x11))
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            NULL);
+        }
+
+      return;
+    }
 
   if (prev_unredirected_window)
     {
       MetaWindowActor *window_actor;
       MetaWindowActorX11 *window_actor_x11;
 
+      g_signal_handlers_disconnect_by_func (prev_unredirected_window,
+                                            on_redirected_monitor_changed,
+                                            compositor_x11);
+
       window_actor = meta_window_actor_from_window (prev_unredirected_window);
       window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
       meta_window_actor_x11_set_unredirected (window_actor_x11, FALSE);
@@ -293,6 +367,17 @@
       MetaWindowActor *window_actor;
       MetaWindowActorX11 *window_actor_x11;
 
+      if (!compositor_x11->randr_scale_disabled)
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            window->monitor);
+        }
+
+      g_signal_connect_object (window, "monitor-changed",
+                              G_CALLBACK (on_redirected_monitor_changed),
+                              compositor_x11, 0);
+
       window_actor = meta_window_actor_from_window (window);
       window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
       meta_window_actor_x11_set_unredirected (window_actor_x11, TRUE);
@@ -304,21 +389,11 @@
 {
   MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
   MetaWindow *window_to_unredirect = NULL;
-  MetaWindowActor *window_actor;
-  MetaWindowActorX11 *window_actor_x11;
 
   if (meta_compositor_is_unredirect_inhibited (compositor))
     goto out;
 
-  window_actor = meta_compositor_get_top_window_actor (compositor);
-  if (!window_actor)
-    goto out;
-
-  window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
-  if (!meta_window_actor_x11_should_unredirect (window_actor_x11))
-    goto out;
-
-  window_to_unredirect = meta_window_actor_get_meta_window (window_actor);
+  window_to_unredirect = get_unredirectable_window (compositor_x11);
 
 out:
   set_unredirected_window (compositor_x11, window_to_unredirect);
diff '--color=auto' -uraN a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
--- a/src/compositor/meta-surface-actor.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-surface-actor.c	2023-10-12 20:59:22.687167413 +0300
@@ -63,6 +63,7 @@
 {
   REPAINT_SCHEDULED,
   SIZE_CHANGED,
+  FROZEN,
 
   LAST_SIGNAL,
 };
@@ -296,6 +297,13 @@
                                         0,
                                         NULL, NULL, NULL,
                                         G_TYPE_NONE, 0);
+
+  signals[FROZEN] = g_signal_new ("frozen",
+                                  G_TYPE_FROM_CLASS (object_class),
+                                  G_SIGNAL_RUN_LAST,
+                                  0,
+                                  NULL, NULL, NULL,
+                                  G_TYPE_NONE, 0);
 }
 
 gboolean
@@ -543,6 +551,22 @@
                                                       stage_view);
 }
 
+gboolean
+meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                  MtkRectangle    *rect)
+{
+  ClutterActor *actor = CLUTTER_ACTOR (surface_actor);
+  graphene_rect_t bounding_rect;
+  graphene_rect_t bound_rect;
+
+  clutter_actor_get_transformed_extents (actor, &bounding_rect);
+
+  bound_rect = mtk_rectangle_to_graphene_rect (rect);
+
+  return graphene_rect_contains_rect (&bounding_rect,
+                                      &bound_rect);
+}
+
 void
 meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                      cairo_region_t   *region)
@@ -624,6 +648,9 @@
 
   priv->frozen = frozen;
 
+  if (frozen)
+    g_signal_emit (self, signals[FROZEN], 0);
+
   if (!frozen && priv->pending_damage)
     {
       int i, n_rects = cairo_region_num_rectangles (priv->pending_damage);
diff '--color=auto' -uraN a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
--- a/src/compositor/meta-surface-actor.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-surface-actor.h	2023-10-12 20:59:22.687167413 +0300
@@ -42,6 +42,9 @@
                                                        ClutterStageView *stage_view,
                                                        float            *unobscurred_fraction);
 
+gboolean meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                           MtkRectangle    *rect);
+
 void meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                           cairo_region_t   *region);
 void meta_surface_actor_set_opaque_region (MetaSurfaceActor *self,
diff '--color=auto' -uraN a/src/core/events.c b/src/core/events.c
--- a/src/core/events.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/events.c	2023-10-12 20:59:22.717167787 +0300
@@ -530,7 +530,7 @@
 #ifdef HAVE_WAYLAND
   /* If a Wayland client has a grab, don't pass that through to Clutter */
   if (wayland_compositor && meta_wayland_compositor_is_grabbed (wayland_compositor))
-    bypass_clutter = !bypass_wayland;
+    bypass_clutter = bypass_clutter || !bypass_wayland;
 
   if (wayland_compositor && !bypass_wayland)
     {
diff '--color=auto' -uraN a/src/core/meta-private-introspected.h b/src/core/meta-private-introspected.h
--- a/src/core/meta-private-introspected.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/core/meta-private-introspected.h	2023-10-12 20:59:22.713834412 +0300
@@ -0,0 +1,27 @@
+# pragma once
+
+#include <glib-object.h>
+
+#include <meta/types.h>
+
+/**
+ * MetaTileConstraint:
+ * @META_TILE_CONSTRAINT_NONE: No constraint
+ * @META_TILE_CONSTRAINT_WINDOW: Window constraint
+ * @META_TILE_CONSTRAINT_MONITOR: Monitor constraint
+ */
+typedef enum
+{
+  META_WINDOW_CONSTRAINT_NONE,
+  META_WINDOW_CONSTRAINT_WINDOW,
+  META_WINDOW_CONSTRAINT_MONITOR,
+} MetaWindowConstraint;
+
+
+META_EXPORT
+void
+meta_window_override_constraints (MetaWindow           *window,
+                                  MetaWindowConstraint  top,
+                                  MetaWindowConstraint  left,
+                                  MetaWindowConstraint  right,
+                                  MetaWindowConstraint  bottom);
diff '--color=auto' -uraN a/src/core/window-private.h b/src/core/window-private.h
--- a/src/core/window-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/window-private.h	2023-10-12 20:59:22.713834412 +0300
@@ -230,6 +230,13 @@
     MetaEdgeConstraint left;
   } edge_constraints;
 
+  struct {
+    MetaEdgeConstraint top;
+    MetaEdgeConstraint right;
+    MetaEdgeConstraint bottom;
+    MetaEdgeConstraint left;
+  } overridden_constraints;
+
   double tile_hfraction;
 
   uint64_t preferred_output_winsys_id;
@@ -702,6 +709,9 @@
                                               int         *width,
                                               int         *height);
 
+gboolean    meta_window_frame_contains_rect (MetaWindow    *window,
+                                             MtkRectangle *rect);
+
 void        meta_window_update_unfocused_button_grabs (MetaWindow *window);
 
 void        meta_window_update_appears_focused (MetaWindow *window);
diff '--color=auto' -uraN a/src/core/window.c b/src/core/window.c
--- a/src/core/window.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/window.c	2023-10-12 20:59:22.713834412 +0300
@@ -74,6 +74,7 @@
 #include "core/constraints.h"
 #include "core/frame.h"
 #include "core/keybindings-private.h"
+#include "core/meta-private-introspected.h"
 #include "core/meta-workspace-manager-private.h"
 #include "core/place.h"
 #include "core/stack.h"
@@ -230,6 +231,7 @@
   UNMANAGED,
   SIZE_CHANGED,
   POSITION_CHANGED,
+  MONITOR_CHANGED,
   SHOWN,
   HIGHEST_SCALE_MONITOR_CHANGED,
 
@@ -695,6 +697,21 @@
                   NULL, NULL, NULL,
                   G_TYPE_NONE, 0);
 
+    /**
+   * MetaWindow::monitor-changed:
+   * @window: a #MetaWindow
+   * @old_monitor: the old monitor index or -1 if not known
+   *
+   * This is emitted when the window has changed monitor
+   */
+  window_signals[MONITOR_CHANGED] =
+    g_signal_new ("monitor-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1, G_TYPE_INT);
+
   /**
    * MetaWindow::shown:
    * @window: a #MetaWindow
@@ -976,6 +993,9 @@
 {
   META_WINDOW_GET_CLASS (window)->main_monitor_changed (window, old);
 
+  g_signal_emit (window, window_signals[MONITOR_CHANGED], 0,
+                 old ? old->number : -1);
+
   if (old)
     g_signal_emit_by_name (window->display, "window-left-monitor",
                            old->number, window);
@@ -2892,6 +2912,38 @@
     meta_window_tile (tile_match, tile_match->tile_mode);
 }
 
+G_ALWAYS_INLINE static inline MetaEdgeConstraint
+get_edge_constraint (MetaWindowConstraint constraint)
+{
+  switch (constraint)
+    {
+      case META_WINDOW_CONSTRAINT_NONE:
+        return META_EDGE_CONSTRAINT_NONE;
+      case META_WINDOW_CONSTRAINT_WINDOW:
+        return META_EDGE_CONSTRAINT_WINDOW;
+      case META_WINDOW_CONSTRAINT_MONITOR:
+        return META_EDGE_CONSTRAINT_MONITOR;
+    }
+
+  g_return_val_if_reached (META_WINDOW_CONSTRAINT_NONE);
+}
+
+void
+meta_window_override_constraints (MetaWindow           *window,
+                                  MetaWindowConstraint  top,
+                                  MetaWindowConstraint  left,
+                                  MetaWindowConstraint  right,
+                                  MetaWindowConstraint  bottom)
+{
+  window->overridden_constraints.left = get_edge_constraint (left);
+  window->overridden_constraints.right = get_edge_constraint (right);
+  window->overridden_constraints.top = get_edge_constraint (top);
+  window->overridden_constraints.bottom = get_edge_constraint (bottom);
+
+  update_edge_constraints (window);
+  meta_window_frame_size_changed (window);
+}
+
 static void
 update_edge_constraints (MetaWindow *window)
 {
@@ -2947,6 +2999,18 @@
       window->edge_constraints.right = META_EDGE_CONSTRAINT_MONITOR;
       window->edge_constraints.left = META_EDGE_CONSTRAINT_MONITOR;
     }
+
+  if (window->overridden_constraints.top != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.top = window->overridden_constraints.top;
+
+  if (window->overridden_constraints.bottom != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.bottom = window->overridden_constraints.bottom;
+
+  if (window->overridden_constraints.left != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.left = window->overridden_constraints.left;
+
+  if (window->overridden_constraints.right != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.right = window->overridden_constraints.right;
 }
 
 void
@@ -4321,6 +4385,14 @@
     window->size_hints.height_inc;
 }
 
+gboolean
+meta_window_frame_contains_rect (MetaWindow    *window,
+                                 MtkRectangle *rect)
+{
+  return mtk_rectangle_contains_rect (&window->rect,
+                                       rect);
+}
+
 /**
  * meta_window_get_buffer_rect:
  * @window: a #MetaWindow
diff '--color=auto' -uraN a/src/core/workspace.c b/src/core/workspace.c
--- a/src/core/workspace.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/workspace.c	2023-10-12 20:59:22.700500912 +0300
@@ -705,6 +705,7 @@
 {
   int ret;
 
+  g_return_val_if_fail (META_IS_WORKSPACE (workspace), -1);
   ret = g_list_index (workspace->manager->workspaces, workspace);
   g_return_val_if_fail (ret >= 0, -1);
 
diff '--color=auto' -uraN a/src/meson.build b/src/meson.build
--- a/src/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/src/meson.build	2023-10-12 20:59:22.717167787 +0300
@@ -1257,7 +1257,8 @@
     sources: [
       mutter_enum_types[1],
       mutter_introspected_sources,
-      mutter_public_header_files
+      mutter_public_header_files,
+      'core' / 'meta-private-introspected.h',
     ],
     nsversion: libmutter_api_version,
     namespace: 'Meta',
diff '--color=auto' -uraN a/src/meson.build.orig b/src/meson.build.orig
--- a/src/meson.build.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/meson.build.orig	2023-09-16 23:51:03.000000000 +0300
@@ -0,0 +1,1309 @@
+mutter_includesubdir = pkgname / 'meta'
+mutter_includedir = includedir / mutter_includesubdir
+
+mutter_includes = [
+  include_directories('.'),
+  top_includepath,
+  clutter_includepath,
+  cogl_includepath,
+]
+
+mutter_lib_deps = [
+  m_dep,
+]
+
+mutter_pkg_deps = [
+  cairo_dep,
+  gio_unix_dep,
+  glib_dep,
+  gsettings_desktop_schemas_dep,
+  pango_dep,
+]
+
+mutter_pkg_private_deps = [
+  colord_dep,
+  lcms2_dep,
+  gmodule_no_export_dep,
+  gnome_settings_daemon_dep,
+  json_glib_dep,
+  xkbcommon_dep,
+  libeis_dep,
+]
+
+if have_gnome_desktop
+  mutter_pkg_private_deps += [
+    gnome_desktop_dep,
+  ]
+endif
+
+if have_libdisplay_info
+  mutter_pkg_private_deps += [
+    libdisplay_info_dep,
+  ]
+endif
+
+if have_sound_player
+  mutter_pkg_private_deps += [
+    libcanberra_dep,
+  ]
+endif
+
+if have_gl
+  mutter_pkg_deps += [
+    gl_dep,
+  ]
+endif
+
+if have_gles2
+  mutter_pkg_private_deps += [
+    gles2_dep,
+  ]
+endif
+
+if have_egl
+  mutter_pkg_deps += [
+    egl_dep,
+  ]
+endif
+
+if have_libgudev
+  mutter_pkg_private_deps += [
+    gudev_dep,
+    libudev_dep,
+  ]
+endif
+
+if have_startup_notification
+  mutter_pkg_private_deps += [
+    libstartup_notification_dep,
+  ]
+endif
+
+if have_libwacom
+  mutter_pkg_private_deps += [
+    libwacom_dep,
+  ]
+endif
+
+if have_remote_desktop
+  mutter_pkg_private_deps += [
+    libpipewire_dep,
+    libeis_dep,
+  ]
+endif
+
+if have_introspection
+  mutter_pkg_private_deps += [
+    gobject_introspection_dep,
+  ]
+endif
+
+if have_x11
+  mutter_pkg_deps += [
+    xfixes_dep,
+    xi_dep,
+    x11_dep,
+  ]
+
+  mutter_pkg_private_deps += [
+    xrandr_dep,
+    xinerama_dep,
+    xext_dep,
+    ice_dep,
+    xcomposite_dep,
+    xcursor_dep,
+    xdamage_dep,
+    xkbfile_dep,
+    xkeyboard_config_dep,
+    xkbcommon_x11_dep,
+    xrender_dep,
+    x11_xcb_dep,
+    xcb_randr_dep,
+    xcb_res_dep,
+    xau_dep,
+    xtst_dep,
+  ]
+
+  if have_sm
+    mutter_pkg_private_deps += [
+      sm_dep,
+    ]
+  endif
+endif
+
+if have_wayland
+  mutter_pkg_deps += [
+    wayland_server_dep,
+  ]
+endif
+
+if have_libsystemd
+  mutter_pkg_private_deps += [
+    libsystemd_dep,
+  ]
+endif
+
+if have_native_backend
+  mutter_pkg_private_deps += [
+    libinput_dep,
+    gudev_dep,
+    libgbm_dep,
+    logind_provider_dep,
+    libudev_dep,
+    xkbcommon_dep,
+  ]
+endif
+
+if have_wayland or have_native_backend
+  mutter_pkg_private_deps += [
+    libdrm_dep,
+  ]
+endif
+
+if have_wayland_eglstream
+  mutter_lib_deps += [
+    dl_dep,
+  ]
+  mutter_pkg_private_deps += [
+    wayland_eglstream_protocols_dep,
+  ]
+endif
+
+mutter_deps = [
+  mutter_pkg_deps,
+  mutter_pkg_private_deps,
+  mutter_lib_deps,
+]
+
+mutter_c_args = [
+  '-DCLUTTER_ENABLE_COMPOSITOR_API',
+  '-DCOGL_ENABLE_EXPERIMENTAL_API',
+  '-DCOGL_ENABLE_EXPERIMENTAL_2_0_API',
+  '-DCOGL_ENABLE_MUTTER_API',
+  '-DCLUTTER_DISABLE_DEPRECATION_WARNINGS',
+  '-DCOGL_DISABLE_DEPRECATION_WARNINGS',
+  '-DSN_API_NOT_YET_FROZEN=1',
+  '-DGETTEXT_PACKAGE="@0@"'.format(meson.project_name()),
+]
+
+if get_option('verbose')
+  mutter_c_args += [
+    '-DWITH_VERBOSE_MODE'
+  ]
+endif
+
+mutter_sources = [
+  'backends/edid.h',
+  'backends/edid-parse.c',
+  'backends/gsm-inhibitor-flag.h',
+  'backends/meta-backend.c',
+  'backends/meta-backend-private.h',
+  'backends/meta-barrier.c',
+  'backends/meta-barrier-private.h',
+  'backends/meta-color-device.c',
+  'backends/meta-color-device.h',
+  'backends/meta-color-manager.c',
+  'backends/meta-color-manager.h',
+  'backends/meta-color-manager-private.h',
+  'backends/meta-color-profile.c',
+  'backends/meta-color-profile.h',
+  'backends/meta-color-store.c',
+  'backends/meta-color-store.h',
+  'backends/meta-crtc-mode.c',
+  'backends/meta-crtc-mode.h',
+  'backends/meta-crtc.c',
+  'backends/meta-crtc.h',
+  'backends/meta-cursor.c',
+  'backends/meta-cursor.h',
+  'backends/meta-cursor-renderer.c',
+  'backends/meta-cursor-renderer.h',
+  'backends/meta-cursor-sprite-xcursor.c',
+  'backends/meta-cursor-sprite-xcursor.h',
+  'backends/meta-cursor-tracker.c',
+  'backends/meta-cursor-tracker-private.h',
+  'backends/meta-dbus-session-manager.c',
+  'backends/meta-dbus-session-manager.h',
+  'backends/meta-dbus-session-watcher.c',
+  'backends/meta-dbus-session-watcher.h',
+  'backends/meta-display-config-shared.h',
+  'backends/meta-dnd-private.h',
+  'backends/meta-fd-source.c',
+  'backends/meta-fd-source.h',
+  'backends/meta-gpu.c',
+  'backends/meta-gpu.h',
+  'backends/meta-idle-monitor.c',
+  'backends/meta-idle-manager.c',
+  'backends/meta-idle-manager.h',
+  'backends/meta-idle-monitor-private.h',
+  'backends/meta-input-capture.c',
+  'backends/meta-input-capture.h',
+  'backends/meta-input-capture-session.c',
+  'backends/meta-input-capture-session.h',
+  'backends/meta-input-device.c',
+  'backends/meta-input-mapper.c',
+  'backends/meta-input-mapper-private.h',
+  'backends/meta-input-settings.c',
+  'backends/meta-input-settings-private.h',
+  'backends/meta-input-settings-dummy.c',
+  'backends/meta-input-settings-dummy.h',
+  'backends/meta-keymap-utils.c',
+  'backends/meta-keymap-utils.h',
+  'backends/meta-logical-monitor.c',
+  'backends/meta-logical-monitor.h',
+  'backends/meta-monitor.c',
+  'backends/meta-monitor-config-manager.c',
+  'backends/meta-monitor-config-manager.h',
+  'backends/meta-monitor-config-migration.c',
+  'backends/meta-monitor-config-migration.h',
+  'backends/meta-monitor-config-store.c',
+  'backends/meta-monitor-config-store.h',
+  'backends/meta-monitor.h',
+  'backends/meta-monitor-manager.c',
+  'backends/meta-monitor-manager-dummy.c',
+  'backends/meta-monitor-manager-dummy.h',
+  'backends/meta-monitor-manager-private.h',
+  'backends/meta-monitor-transform.c',
+  'backends/meta-monitor-transform.h',
+  'backends/meta-orientation-manager.c',
+  'backends/meta-orientation-manager.h',
+  'backends/meta-output.c',
+  'backends/meta-output.h',
+  'backends/meta-pointer-constraint.c',
+  'backends/meta-pointer-constraint.h',
+  'backends/meta-remote-access-controller-private.h',
+  'backends/meta-remote-access-controller.c',
+  'backends/meta-renderer.c',
+  'backends/meta-renderer.h',
+  'backends/meta-renderer-view.c',
+  'backends/meta-renderer-view.h',
+  'backends/meta-screen-cast-window.c',
+  'backends/meta-screen-cast-window.h',
+  'backends/meta-settings.c',
+  'backends/meta-settings-private.h',
+  'backends/meta-stage.c',
+  'backends/meta-stage-impl.c',
+  'backends/meta-stage-impl-private.h',
+  'backends/meta-stage-private.h',
+  'backends/meta-stage-view.c',
+  'backends/meta-stage-view-private.h',
+  'backends/meta-viewport-info.c',
+  'backends/meta-viewport-info.h',
+  'backends/meta-virtual-monitor.c',
+  'backends/meta-virtual-monitor.h',
+  'compositor/clutter-utils.c',
+  'compositor/clutter-utils.h',
+  'compositor/cogl-utils.c',
+  'compositor/cogl-utils.h',
+  'compositor/compositor.c',
+  'compositor/compositor-private.h',
+  'compositor/edge-resistance.c',
+  'compositor/edge-resistance.h',
+  'compositor/meta-background-actor.c',
+  'compositor/meta-background-actor-private.h',
+  'compositor/meta-background-content.c',
+  'compositor/meta-background-content-private.h',
+  'compositor/meta-background.c',
+  'compositor/meta-background-group.c',
+  'compositor/meta-background-image.c',
+  'compositor/meta-background-private.h',
+  'compositor/meta-compositor-server.c',
+  'compositor/meta-compositor-server.h',
+  'compositor/meta-compositor-view.c',
+  'compositor/meta-compositor-view.h',
+  'compositor/meta-cullable.c',
+  'compositor/meta-cullable.h',
+  'compositor/meta-dnd-actor.c',
+  'compositor/meta-dnd-actor-private.h',
+  'compositor/meta-dnd.c',
+  'compositor/meta-feedback-actor.c',
+  'compositor/meta-feedback-actor-private.h',
+  'compositor/meta-later.c',
+  'compositor/meta-module.c',
+  'compositor/meta-module.h',
+  'compositor/meta-multi-texture.c',
+  'compositor/meta-multi-texture-format.c',
+  'compositor/meta-multi-texture-format-private.h',
+  'compositor/meta-plugin.c',
+  'compositor/meta-plugin-manager.c',
+  'compositor/meta-plugin-manager.h',
+  'compositor/meta-shadow-factory.c',
+  'compositor/meta-shaped-texture.c',
+  'compositor/meta-shaped-texture-private.h',
+  'compositor/meta-surface-actor.c',
+  'compositor/meta-surface-actor.h',
+  'compositor/meta-texture-mipmap.c',
+  'compositor/meta-texture-mipmap.h',
+  'compositor/meta-window-actor.c',
+  'compositor/meta-window-actor-private.h',
+  'compositor/meta-window-drag.c',
+  'compositor/meta-window-drag.h',
+  'compositor/meta-window-group.c',
+  'compositor/meta-window-group-private.h',
+  'compositor/meta-window-shape.c',
+  'compositor/region-utils.c',
+  'compositor/region-utils.h',
+  'core/bell.c',
+  'core/bell.h',
+  'core/boxes.c',
+  'core/boxes-private.h',
+  'core/constraints.c',
+  'core/constraints.h',
+  'core/delete.c',
+  'core/display.c',
+  'core/display-private.h',
+  'core/events.c',
+  'core/events.h',
+  'core/frame.c',
+  'core/frame.h',
+  'core/keybindings.c',
+  'core/keybindings-private.h',
+  'core/meta-accel-parse.c',
+  'core/meta-accel-parse.h',
+  'core/meta-anonymous-file.c',
+  'core/meta-anonymous-file.h',
+  'core/meta-border.c',
+  'core/meta-border.h',
+  'core/meta-clipboard-manager.c',
+  'core/meta-clipboard-manager.h',
+  'core/meta-close-dialog.c',
+  'core/meta-context-main.c',
+  'core/meta-context-main.h',
+  'core/meta-context-private.h',
+  'core/meta-context.c',
+  'core/meta-fraction.c',
+  'core/meta-fraction.h',
+  'core/meta-gesture-tracker.c',
+  'core/meta-gesture-tracker-private.h',
+  'core/meta-inhibit-shortcuts-dialog.c',
+  'core/meta-inhibit-shortcuts-dialog-default.c',
+  'core/meta-inhibit-shortcuts-dialog-default-private.h',
+  'core/meta-launch-context.c',
+  'core/meta-pad-action-mapper.c',
+  'core/meta-private-enums.h',
+  'core/meta-selection.c',
+  'core/meta-selection-source.c',
+  'core/meta-selection-source-memory.c',
+  'core/meta-sound-player.c',
+  'core/meta-workspace-manager.c',
+  'core/meta-workspace-manager-private.h',
+  'core/place.c',
+  'core/place.h',
+  'core/prefs-private.h',
+  'core/prefs.c',
+  'core/restart.c',
+  'core/stack.c',
+  'core/stack.h',
+  'core/stack-tracker.c',
+  'core/stack-tracker.h',
+  'core/startup-notification.c',
+  'core/startup-notification-private.h',
+  'core/util.c',
+  'core/util-private.h',
+  'core/window.c',
+  'core/window-private.h',
+  'core/workspace.c',
+  'core/workspace-private.h',
+]
+
+if have_x11
+  mutter_sources += [
+    'backends/x11/cm/meta-backend-x11-cm.c',
+    'backends/x11/cm/meta-backend-x11-cm.h',
+    'backends/x11/cm/meta-cursor-sprite-xfixes.c',
+    'backends/x11/cm/meta-cursor-sprite-xfixes.h',
+    'backends/x11/cm/meta-renderer-x11-cm.c',
+    'backends/x11/cm/meta-renderer-x11-cm.h',
+    'backends/x11/meta-backend-x11.c',
+    'backends/x11/meta-backend-x11.h',
+    'backends/x11/meta-barrier-x11.c',
+    'backends/x11/meta-barrier-x11.h',
+    'backends/x11/meta-clutter-backend-x11.c',
+    'backends/x11/meta-clutter-backend-x11.h',
+    'backends/x11/meta-color-manager-x11.c',
+    'backends/x11/meta-color-manager-x11.h',
+    'backends/x11/meta-crtc-xrandr.c',
+    'backends/x11/meta-crtc-xrandr.h',
+    'backends/x11/meta-cursor-renderer-x11.c',
+    'backends/x11/meta-cursor-renderer-x11.h',
+    'backends/x11/meta-cursor-tracker-x11.c',
+    'backends/x11/meta-cursor-tracker-x11.h',
+    'backends/x11/meta-event-x11.c',
+    'backends/x11/meta-event-x11.h',
+    'backends/x11/meta-gpu-xrandr.c',
+    'backends/x11/meta-gpu-xrandr.h',
+    'backends/x11/meta-input-device-x11.c',
+    'backends/x11/meta-input-device-x11.h',
+    'backends/x11/meta-input-device-tool-x11.c',
+    'backends/x11/meta-input-device-tool-x11.h',
+    'backends/x11/meta-input-settings-x11.c',
+    'backends/x11/meta-input-settings-x11.h',
+    'backends/x11/meta-seat-x11.c',
+    'backends/x11/meta-seat-x11.h',
+    'backends/x11/meta-keymap-x11.c',
+    'backends/x11/meta-keymap-x11.h',
+    'backends/x11/meta-monitor-manager-xrandr.c',
+    'backends/x11/meta-monitor-manager-xrandr.h',
+    'backends/x11/meta-output-xrandr.c',
+    'backends/x11/meta-output-xrandr.h',
+    'backends/x11/meta-renderer-x11.c',
+    'backends/x11/meta-renderer-x11.h',
+    'backends/x11/meta-stage-x11.c',
+    'backends/x11/meta-stage-x11.h',
+    'backends/x11/meta-virtual-input-device-x11.c',
+    'backends/x11/meta-virtual-input-device-x11.h',
+    'backends/x11/meta-xkb-a11y-x11.c',
+    'backends/x11/meta-xkb-a11y-x11.h',
+    'backends/x11/nested/meta-backend-x11-nested.c',
+    'backends/x11/nested/meta-backend-x11-nested.h',
+    'backends/x11/nested/meta-cursor-renderer-x11-nested.c',
+    'backends/x11/nested/meta-cursor-renderer-x11-nested.h',
+    'backends/x11/nested/meta-stage-x11-nested.c',
+    'backends/x11/nested/meta-stage-x11-nested.h',
+    'backends/x11/nested/meta-renderer-x11-nested.c',
+    'backends/x11/nested/meta-renderer-x11-nested.h',
+  ]
+endif
+
+if have_x11_client
+  mutter_sources += [
+    'compositor/meta-compositor-x11.c',
+    'compositor/meta-compositor-x11.h',
+    'compositor/meta-surface-actor-x11.c',
+    'compositor/meta-surface-actor-x11.h',
+    'compositor/meta-sync-ring.c',
+    'compositor/meta-sync-ring.h',
+    'compositor/meta-window-actor-x11.c',
+    'compositor/meta-window-actor-x11.h',
+    'x11/atomnames.h',
+    'x11/events.c',
+    'x11/events.h',
+    'x11/group.c',
+    'x11/group-private.h',
+    'x11/group-props.c',
+    'x11/group-props.h',
+    'x11/iconcache.c',
+    'x11/iconcache.h',
+    'x11/meta-selection-source-x11.c',
+    'x11/meta-selection-source-x11-private.h',
+    'x11/meta-startup-notification-x11.c',
+    'x11/meta-startup-notification-x11.h',
+    'x11/meta-sync-counter.c',
+    'x11/meta-sync-counter.h',
+    'x11/meta-x11-display.c',
+    'x11/meta-x11-display-private.h',
+    'x11/meta-x11-errors.c',
+    'x11/meta-x11-event-source.c',
+    'x11/meta-x11-selection.c',
+    'x11/meta-x11-selection-private.h',
+    'x11/meta-x11-selection-input-stream.c',
+    'x11/meta-x11-selection-input-stream-private.h',
+    'x11/meta-x11-selection-output-stream.c',
+    'x11/meta-x11-selection-output-stream-private.h',
+    'x11/meta-x11-stack.c',
+    'x11/meta-x11-stack-private.h',
+    'x11/mutter-Xatomtype.h',
+    'x11/session.c',
+    'x11/session.h',
+    'x11/window-props.c',
+    'x11/window-props.h',
+    'x11/window-x11.c',
+    'x11/window-x11.h',
+    'x11/window-x11-private.h',
+    'x11/xprops.c',
+    'x11/xprops.h',
+  ]
+endif
+
+
+if have_egl_device
+  mutter_sources += [
+    'backends/native/meta-render-device-egl-stream.c',
+    'backends/native/meta-render-device-egl-stream.h',
+  ]
+endif
+
+if have_egl
+  mutter_sources += [
+    'backends/meta-egl.c',
+    'backends/meta-egl-ext.h',
+    'backends/meta-egl.h',
+  ]
+endif
+
+if have_gles2
+  mutter_sources += [
+    'backends/meta-gles3.c',
+    'backends/meta-gles3.h',
+    'backends/meta-gles3-table.h',
+  ]
+endif
+
+if have_remote_desktop
+  mutter_sources += [
+    'backends/meta-eis.c',
+    'backends/meta-eis.h',
+    'backends/meta-eis-client.c',
+    'backends/meta-eis-client.h',
+    'backends/meta-eis-viewport.c',
+    'backends/meta-eis-viewport.h',
+    'backends/meta-remote-desktop.c',
+    'backends/meta-remote-desktop.h',
+    'backends/meta-remote-desktop-session.c',
+    'backends/meta-remote-desktop-session.h',
+    'backends/meta-screen-cast.c',
+    'backends/meta-screen-cast.h',
+    'backends/meta-screen-cast-area-stream.c',
+    'backends/meta-screen-cast-area-stream.h',
+    'backends/meta-screen-cast-area-stream-src.c',
+    'backends/meta-screen-cast-area-stream-src.h',
+    'backends/meta-screen-cast-monitor-stream.c',
+    'backends/meta-screen-cast-monitor-stream.h',
+    'backends/meta-screen-cast-monitor-stream-src.c',
+    'backends/meta-screen-cast-monitor-stream-src.h',
+    'backends/meta-screen-cast-virtual-stream-src.c',
+    'backends/meta-screen-cast-virtual-stream-src.h',
+    'backends/meta-screen-cast-virtual-stream.c',
+    'backends/meta-screen-cast-virtual-stream.h',
+    'backends/meta-screen-cast-window-stream-src.c',
+    'backends/meta-screen-cast-window-stream-src.h',
+    'backends/meta-screen-cast-window-stream.c',
+    'backends/meta-screen-cast-window-stream.h',
+    'backends/meta-screen-cast-session.c',
+    'backends/meta-screen-cast-session.h',
+    'backends/meta-screen-cast-stream.c',
+    'backends/meta-screen-cast-stream.h',
+    'backends/meta-screen-cast-stream-src.c',
+    'backends/meta-screen-cast-stream-src.h',
+    'core/meta-selection-source-remote.c',
+    'core/meta-selection-source-remote.h',
+  ]
+endif
+
+if have_wayland
+  mutter_sources += [
+    'compositor/meta-surface-actor-wayland.c',
+    'compositor/meta-surface-actor-wayland.h',
+    'compositor/meta-window-actor-wayland.c',
+    'compositor/meta-window-actor-wayland.h',
+    'core/meta-service-channel.c',
+    'core/meta-service-channel.h',
+    'wayland/meta-cursor-sprite-wayland.c',
+    'wayland/meta-cursor-sprite-wayland.h',
+    'wayland/meta-pointer-confinement-wayland.c',
+    'wayland/meta-pointer-confinement-wayland.h',
+    'wayland/meta-pointer-lock-wayland.c',
+    'wayland/meta-pointer-lock-wayland.h',
+    'wayland/meta-selection-source-wayland.c',
+    'wayland/meta-selection-source-wayland-private.h',
+    'wayland/meta-wayland-activation.c',
+    'wayland/meta-wayland-activation.h',
+    'wayland/meta-wayland-actor-surface.c',
+    'wayland/meta-wayland-actor-surface.h',
+    'wayland/meta-wayland-buffer.c',
+    'wayland/meta-wayland-buffer.h',
+    'wayland/meta-wayland.c',
+    'wayland/meta-wayland-client.c',
+    'wayland/meta-wayland-client-private.h',
+    'wayland/meta-wayland-cursor-surface.c',
+    'wayland/meta-wayland-cursor-surface.h',
+    'wayland/meta-wayland-data-device.c',
+    'wayland/meta-wayland-data-device.h',
+    'wayland/meta-wayland-data-device-primary.c',
+    'wayland/meta-wayland-data-device-primary.h',
+    'wayland/meta-wayland-data-offer.c',
+    'wayland/meta-wayland-data-offer.h',
+    'wayland/meta-wayland-data-offer-primary.c',
+    'wayland/meta-wayland-data-offer-primary.h',
+    'wayland/meta-wayland-data-source.c',
+    'wayland/meta-wayland-data-source.h',
+    'wayland/meta-wayland-data-source-primary.c',
+    'wayland/meta-wayland-data-source-primary.h',
+    'wayland/meta-wayland-dma-buf.c',
+    'wayland/meta-wayland-dma-buf.h',
+    'wayland/meta-wayland-dnd-surface.c',
+    'wayland/meta-wayland-dnd-surface.h',
+    'wayland/meta-wayland-filter-manager.c',
+    'wayland/meta-wayland-filter-manager.h',
+    'wayland/meta-wayland-fractional-scale.c',
+    'wayland/meta-wayland-fractional-scale.h',
+    'wayland/meta-wayland-gtk-shell.c',
+    'wayland/meta-wayland-gtk-shell.h',
+    'wayland/meta-wayland.h',
+    'wayland/meta-wayland-idle-inhibit.c',
+    'wayland/meta-wayland-idle-inhibit.h',
+    'wayland/meta-wayland-inhibit-shortcuts.c',
+    'wayland/meta-wayland-inhibit-shortcuts-dialog.c',
+    'wayland/meta-wayland-inhibit-shortcuts-dialog.h',
+    'wayland/meta-wayland-inhibit-shortcuts.h',
+    'wayland/meta-wayland-input-device.c',
+    'wayland/meta-wayland-input-device.h',
+    'wayland/meta-wayland-keyboard.c',
+    'wayland/meta-wayland-keyboard.h',
+    'wayland/meta-wayland-legacy-xdg-foreign.c',
+    'wayland/meta-wayland-legacy-xdg-foreign.h',
+    'wayland/meta-wayland-outputs.c',
+    'wayland/meta-wayland-outputs.h',
+    'wayland/meta-wayland-pointer.c',
+    'wayland/meta-wayland-pointer-constraints.c',
+    'wayland/meta-wayland-pointer-constraints.h',
+    'wayland/meta-wayland-pointer-gesture-hold.c',
+    'wayland/meta-wayland-pointer-gesture-hold.h',
+    'wayland/meta-wayland-pointer-gesture-pinch.c',
+    'wayland/meta-wayland-pointer-gesture-pinch.h',
+    'wayland/meta-wayland-pointer-gestures.c',
+    'wayland/meta-wayland-pointer-gestures.h',
+    'wayland/meta-wayland-pointer-gesture-swipe.c',
+    'wayland/meta-wayland-pointer-gesture-swipe.h',
+    'wayland/meta-wayland-pointer.h',
+    'wayland/meta-wayland-popup.c',
+    'wayland/meta-wayland-popup.h',
+    'wayland/meta-wayland-presentation-time.c',
+    'wayland/meta-wayland-presentation-time-private.h',
+    'wayland/meta-wayland-private.h',
+    'wayland/meta-wayland-region.c',
+    'wayland/meta-wayland-region.h',
+    'wayland/meta-wayland-seat.c',
+    'wayland/meta-wayland-seat.h',
+    'wayland/meta-wayland-shell-surface.c',
+    'wayland/meta-wayland-shell-surface.h',
+    'wayland/meta-wayland-single-pixel-buffer.c',
+    'wayland/meta-wayland-single-pixel-buffer.h',
+    'wayland/meta-wayland-subsurface.c',
+    'wayland/meta-wayland-subsurface.h',
+    'wayland/meta-wayland-surface.c',
+    'wayland/meta-wayland-surface.h',
+    'wayland/meta-wayland-tablet.c',
+    'wayland/meta-wayland-tablet-cursor-surface.c',
+    'wayland/meta-wayland-tablet-cursor-surface.h',
+    'wayland/meta-wayland-tablet.h',
+    'wayland/meta-wayland-tablet-manager.c',
+    'wayland/meta-wayland-tablet-manager.h',
+    'wayland/meta-wayland-tablet-pad.c',
+    'wayland/meta-wayland-tablet-pad-group.c',
+    'wayland/meta-wayland-tablet-pad-group.h',
+    'wayland/meta-wayland-tablet-pad.h',
+    'wayland/meta-wayland-tablet-pad-ring.c',
+    'wayland/meta-wayland-tablet-pad-ring.h',
+    'wayland/meta-wayland-tablet-pad-strip.c',
+    'wayland/meta-wayland-tablet-pad-strip.h',
+    'wayland/meta-wayland-tablet-seat.c',
+    'wayland/meta-wayland-tablet-seat.h',
+    'wayland/meta-wayland-tablet-tool.c',
+    'wayland/meta-wayland-tablet-tool.h',
+    'wayland/meta-wayland-text-input.c',
+    'wayland/meta-wayland-text-input.h',
+    'wayland/meta-wayland-touch.c',
+    'wayland/meta-wayland-touch.h',
+    'wayland/meta-wayland-transaction.c',
+    'wayland/meta-wayland-transaction.h',
+    'wayland/meta-wayland-types.h',
+    'wayland/meta-wayland-versions.h',
+    'wayland/meta-wayland-viewporter.c',
+    'wayland/meta-wayland-viewporter.h',
+    'wayland/meta-wayland-window-configuration.c',
+    'wayland/meta-wayland-window-configuration.h',
+    'wayland/meta-wayland-xdg-foreign.c',
+    'wayland/meta-wayland-xdg-foreign.h',
+    'wayland/meta-wayland-xdg-foreign-private.h',
+    'wayland/meta-wayland-xdg-shell.c',
+    'wayland/meta-wayland-xdg-shell.h',
+    'wayland/meta-window-wayland.c',
+    'wayland/meta-window-wayland.h',
+  ]
+
+  if have_xwayland
+    mutter_sources += [
+      'wayland/meta-wayland-x11-interop.c',
+      'wayland/meta-wayland-x11-interop.h',
+      'wayland/meta-window-xwayland.c',
+      'wayland/meta-window-xwayland.h',
+      'wayland/meta-xwayland.c',
+      'wayland/meta-xwayland-grab-keyboard.c',
+      'wayland/meta-xwayland-grab-keyboard.h',
+      'wayland/meta-xwayland.h',
+      'wayland/meta-xwayland-private.h',
+      'wayland/meta-xwayland-dnd.c',
+      'wayland/meta-xwayland-dnd-private.h',
+      'wayland/meta-xwayland-surface.c',
+      'wayland/meta-xwayland-surface.h',
+    ]
+  endif
+endif
+
+if have_native_backend
+  mutter_sources += [
+    'backends/native/dbus-utils.c',
+    'backends/native/dbus-utils.h',
+    'backends/native/meta-backend-native.c',
+    'backends/native/meta-backend-native.h',
+    'backends/native/meta-backend-native-private.h',
+    'backends/native/meta-backend-native-types.h',
+    'backends/native/meta-barrier-native.c',
+    'backends/native/meta-barrier-native.h',
+    'backends/native/meta-clutter-backend-native.c',
+    'backends/native/meta-clutter-backend-native.h',
+    'backends/native/meta-crtc-kms.c',
+    'backends/native/meta-crtc-kms.h',
+    'backends/native/meta-crtc-native.c',
+    'backends/native/meta-crtc-native.h',
+    'backends/native/meta-crtc-mode-kms.c',
+    'backends/native/meta-crtc-mode-kms.h',
+    'backends/native/meta-crtc-mode-virtual.c',
+    'backends/native/meta-crtc-mode-virtual.h',
+    'backends/native/meta-crtc-virtual.c',
+    'backends/native/meta-crtc-virtual.h',
+    'backends/native/meta-cursor-renderer-native.c',
+    'backends/native/meta-cursor-renderer-native.h',
+    'backends/native/meta-device-pool-private.h',
+    'backends/native/meta-device-pool.c',
+    'backends/native/meta-device-pool.h',
+    'backends/native/meta-drm-buffer-dumb.c',
+    'backends/native/meta-drm-buffer-dumb.h',
+    'backends/native/meta-drm-buffer-gbm.c',
+    'backends/native/meta-drm-buffer-gbm.h',
+    'backends/native/meta-drm-buffer-import.c',
+    'backends/native/meta-drm-buffer-import.h',
+    'backends/native/meta-drm-buffer-private.h',
+    'backends/native/meta-drm-buffer.c',
+    'backends/native/meta-drm-buffer.h',
+    'backends/native/meta-gpu-kms.c',
+    'backends/native/meta-gpu-kms.h',
+    'backends/native/meta-frame-native.c',
+    'backends/native/meta-frame-native.h',
+    'backends/native/meta-input-device-native.c',
+    'backends/native/meta-input-device-native.h',
+    'backends/native/meta-input-device-tool-native.c',
+    'backends/native/meta-input-device-tool-native.h',
+    'backends/native/meta-input-settings-native.c',
+    'backends/native/meta-input-settings-native.h',
+    'backends/native/meta-keymap-native.c',
+    'backends/native/meta-keymap-native.h',
+    'backends/native/meta-launcher.c',
+    'backends/native/meta-launcher.h',
+    'backends/native/meta-monitor-manager-native.c',
+    'backends/native/meta-monitor-manager-native.h',
+    'backends/native/meta-output-kms.c',
+    'backends/native/meta-output-kms.h',
+    'backends/native/meta-output-native.c',
+    'backends/native/meta-output-native.h',
+    'backends/native/meta-output-virtual.c',
+    'backends/native/meta-output-virtual.h',
+    'backends/native/meta-kms-connector-private.h',
+    'backends/native/meta-kms-connector.c',
+    'backends/native/meta-kms-connector.h',
+    'backends/native/meta-kms-crtc-private.h',
+    'backends/native/meta-kms-crtc.c',
+    'backends/native/meta-kms-crtc.h',
+    'backends/native/meta-kms-cursor-manager.c',
+    'backends/native/meta-kms-cursor-manager.h',
+    'backends/native/meta-kms-device-private.h',
+    'backends/native/meta-kms-device.c',
+    'backends/native/meta-kms-device.h',
+    'backends/native/meta-kms-impl-device-atomic.c',
+    'backends/native/meta-kms-impl-device-atomic.h',
+    'backends/native/meta-kms-impl-device-dummy.c',
+    'backends/native/meta-kms-impl-device-dummy.h',
+    'backends/native/meta-kms-impl-device-simple.c',
+    'backends/native/meta-kms-impl-device-simple.h',
+    'backends/native/meta-kms-impl-device.c',
+    'backends/native/meta-kms-impl-device.h',
+    'backends/native/meta-kms-impl.c',
+    'backends/native/meta-kms-impl.h',
+    'backends/native/meta-kms-mode.c',
+    'backends/native/meta-kms-mode.h',
+    'backends/native/meta-kms-page-flip.c',
+    'backends/native/meta-kms-page-flip-private.h',
+    'backends/native/meta-kms-plane.c',
+    'backends/native/meta-kms-plane-private.h',
+    'backends/native/meta-kms-plane.h',
+    'backends/native/meta-kms-private.h',
+    'backends/native/meta-kms-types-private.h',
+    'backends/native/meta-kms-types.h',
+    'backends/native/meta-kms-update-private.h',
+    'backends/native/meta-kms-update.c',
+    'backends/native/meta-kms-update.h',
+    'backends/native/meta-kms-utils.c',
+    'backends/native/meta-kms-utils.h',
+    'backends/native/meta-kms.c',
+    'backends/native/meta-kms.h',
+    'backends/native/meta-onscreen-native.c',
+    'backends/native/meta-onscreen-native.h',
+    'backends/native/meta-pointer-constraint-native.c',
+    'backends/native/meta-pointer-constraint-native.h',
+    'backends/native/meta-render-device-gbm.c',
+    'backends/native/meta-render-device-gbm.h',
+    'backends/native/meta-render-device-private.h',
+    'backends/native/meta-render-device-surfaceless.c',
+    'backends/native/meta-render-device-surfaceless.h',
+    'backends/native/meta-render-device.c',
+    'backends/native/meta-render-device.h',
+    'backends/native/meta-renderer-native-gles3.c',
+    'backends/native/meta-renderer-native-gles3.h',
+    'backends/native/meta-renderer-native-private.h',
+    'backends/native/meta-renderer-native.c',
+    'backends/native/meta-renderer-native.h',
+    'backends/native/meta-renderer-view-native.c',
+    'backends/native/meta-renderer-view-native.h',
+    'backends/native/meta-seat-impl.c',
+    'backends/native/meta-seat-impl.h',
+    'backends/native/meta-seat-native.c',
+    'backends/native/meta-seat-native.h',
+    'backends/native/meta-stage-native.c',
+    'backends/native/meta-stage-native.h',
+    'backends/native/meta-thread-impl.c',
+    'backends/native/meta-thread-impl.h',
+    'backends/native/meta-thread-private.h',
+    'backends/native/meta-thread.c',
+    'backends/native/meta-thread.h',
+    'backends/native/meta-thread-private.h',
+    'backends/native/meta-udev.c',
+    'backends/native/meta-udev.h',
+    'backends/native/meta-virtual-input-device-native.c',
+    'backends/native/meta-virtual-input-device-native.h',
+    'backends/native/meta-virtual-monitor-native.c',
+    'backends/native/meta-virtual-monitor-native.h',
+    'backends/native/meta-xkb-utils.c',
+    'backends/native/meta-xkb-utils.h',
+    'compositor/meta-compositor-native.c',
+    'compositor/meta-compositor-native.h',
+    'compositor/meta-compositor-view-native.c',
+    'compositor/meta-compositor-view-native.h',
+  ]
+endif
+
+if have_wayland or have_native_backend
+  mutter_sources += [
+    'common/meta-cogl-drm-formats.c',
+    'common/meta-cogl-drm-formats.h',
+  ]
+endif
+
+if have_wayland_eglstream
+  mutter_sources += [
+    'wayland/meta-wayland-egl-stream.c',
+    'wayland/meta-wayland-egl-stream.h',
+  ]
+endif
+
+mutter_private_enum_sources = [
+  'core/window-private.h',
+]
+
+if have_remote_desktop
+  mutter_private_enum_sources += [
+    'backends/meta-screen-cast.h',
+    'backends/meta-screen-cast-session.h',
+  ]
+endif
+
+if have_native_backend
+  mutter_private_enum_sources += [
+    'backends/native/meta-backend-native-types.h',
+    'backends/native/meta-drm-buffer.h',
+    'backends/native/meta-kms-types.h',
+    'backends/native/meta-thread.h',
+  ]
+endif
+
+mutter_built_sources = []
+
+if mutter_private_enum_sources.length() > 0
+  mutter_private_enum_types = gnome.mkenums('meta-private-enum-types',
+    sources: mutter_private_enum_sources,
+    c_template: 'meta-private-enum-types.c.in',
+    h_template: 'meta-private-enum-types.h.in',
+  )
+
+  mutter_built_sources += mutter_private_enum_types
+endif
+
+dbus_interfaces = [
+  {
+    'name': 'meta-dbus-display-config',
+    'interface': 'org.gnome.Mutter.DisplayConfig.xml',
+    'prefix': 'org.gnome.Mutter.',
+  },
+  {
+    'name': 'meta-dbus-idle-monitor',
+    'interface': 'org.gnome.Mutter.IdleMonitor.xml',
+    'prefix': 'org.gnome.Mutter.',
+    'object_manager': true,
+  },
+  {
+    'name': 'meta-dbus-input-mapping',
+    'interface': 'org.gnome.Mutter.InputMapping.xml',
+    'prefix': 'org.gnome.Mutter.',
+  },
+  {
+    'name': 'meta-dbus-service-channel',
+    'interface': 'org.gnome.Mutter.ServiceChannel.xml',
+    'prefix': 'org.gnome.Mutter.',
+  },
+]
+
+if have_profiler
+  mutter_sources += [
+    'core/meta-profiler.c',
+    'core/meta-profiler.h',
+  ]
+
+  dbus_interfaces += [
+    {
+      'name': 'meta-dbus-sysprof3-profiler',
+      'interface': 'org.gnome.Sysprof3.Profiler.xml',
+      'prefix': 'org.gnome.',
+      'directory': sysprof_dbus_interfaces_dir,
+    },
+  ]
+endif
+
+if have_native_backend
+  cvt = find_program('cvt')
+
+  gen_default_modes = find_program('backends/native/gen-default-modes.py')
+  default_modes_h = custom_target('meta-default-modes',
+    output: 'meta-default-modes.h',
+    command: [gen_default_modes, '@OUTPUT@']
+  )
+  mutter_built_sources += default_modes_h
+
+  dbus_interfaces += [
+    {
+      'name': 'meta-dbus-login1',
+      'interface': 'org.freedesktop.login1.xml',
+      'prefix': 'org.freedesktop.',
+    },
+  ]
+endif
+
+if have_remote_desktop
+  dbus_interfaces += [
+    {
+      'name': 'meta-dbus-remote-desktop',
+      'interface': 'org.gnome.Mutter.RemoteDesktop.xml',
+      'prefix': 'org.gnome.Mutter.',
+    },
+    {
+      'name': 'meta-dbus-screen-cast',
+      'interface': 'org.gnome.Mutter.ScreenCast.xml',
+      'prefix': 'org.gnome.Mutter.',
+    },
+  ]
+endif
+
+dbus_interfaces += [
+  {
+    'name': 'meta-dbus-rtkit1',
+    'interface': 'org.freedesktop.RealtimeKit1.xml',
+    'prefix': 'org.freedesktop.',
+  },
+  {
+    'name': 'meta-dbus-gsd-color',
+    'interface': 'org.gnome.SettingsDaemon.Color.xml',
+    'prefix': 'org.gnome.',
+  },
+  {
+    'name': 'meta-dbus-gsd-power-screen',
+    'interface': 'org.gnome.SettingsDaemon.Power.Screen.xml',
+    'prefix': 'org.gnome.',
+  },
+]
+
+built_dbus_sources = {}
+
+foreach dbus_interface: dbus_interfaces
+  name = dbus_interface['name']
+
+  interface = dbus_interface['interface']
+  if dbus_interface.has_key('directory')
+    directory = dbus_interface['directory']
+  else
+    directory = dbus_interfaces_dir
+  endif
+  interface_file = directory / interface
+
+  prefix = dbus_interface['prefix']
+
+  if dbus_interface.has_key('object_manager')
+    object_manager = dbus_interface['object_manager']
+  else
+    object_manager = false
+  endif
+
+  dbus_sources = gnome.gdbus_codegen(name, interface_file,
+    interface_prefix: prefix,
+    namespace: 'MetaDBus',
+    object_manager: object_manager,
+  )
+  built_dbus_sources += {
+    name: dbus_sources,
+  }
+  mutter_built_sources += dbus_sources
+endforeach
+
+dbus_input_capture_built_sources = gnome.gdbus_codegen('meta-dbus-input-capture',
+    dbus_interfaces_dir / 'org.gnome.Mutter.InputCapture.xml',
+    interface_prefix: 'org.gnome.Mutter',
+    namespace: 'MetaDBus',
+)
+mutter_built_sources += dbus_input_capture_built_sources
+
+wayland_protocol_server_headers = []
+wayland_protocol_client_headers = []
+wayland_protocol_sources = []
+
+wayland_protocol_files = {}
+
+if have_wayland
+  # Format:
+  #  - protocol name
+  #  - protocol stability ('private', 'stable' or 'unstable')
+  #  - protocol version (if stability is 'unstable')
+  wayland_protocols = [
+    ['fractional-scale', 'staging', 'v1', ],
+    ['gtk-shell', 'private', ],
+    ['idle-inhibit', 'unstable', 'v1', ],
+    ['keyboard-shortcuts-inhibit', 'unstable', 'v1', ],
+    ['linux-dmabuf', 'unstable', 'v1', ],
+    ['pointer-constraints', 'unstable', 'v1', ],
+    ['pointer-gestures', 'unstable', 'v1', ],
+    ['presentation-time', 'stable', ],
+    ['primary-selection', 'unstable', 'v1', ],
+    ['relative-pointer', 'unstable', 'v1', ],
+    ['single-pixel-buffer', 'staging', 'v1', ],
+    ['tablet', 'unstable', 'v2', ],
+    ['text-input', 'unstable', 'v3', ],
+    ['viewporter', 'stable', ],
+    ['xdg-activation', 'staging', 'v1', ],
+    ['xdg-foreign', 'unstable', 'v1', ],
+    ['xdg-foreign', 'unstable', 'v2', ],
+    ['xdg-output', 'unstable', 'v1', ],
+    ['xdg-shell', 'stable', ],
+    ['xwayland-keyboard-grab', 'unstable', 'v1', ],
+  ]
+  if have_wayland_eglstream
+    wayland_eglstream_protocols_dir = wayland_eglstream_protocols_dep.get_variable('pkgdatadir')
+    wayland_protocols += [
+      ['wayland-eglstream-controller', 'third-party', wayland_eglstream_protocols_dir],
+    ]
+  endif
+  if have_xwayland
+    wayland_protocols += [
+      ['mutter-x11-interop', 'private', ],
+    ]
+  endif
+
+  wayland_scanner = find_program('wayland-scanner')
+  protocols_dir = wayland_protocols_dep.get_variable('pkgdatadir')
+  assert(protocols_dir != '', 'Could not get pkgdatadir from wayland-protocols.pc')
+
+  foreach p: wayland_protocols
+    protocol_name = p.get(0)
+    protocol_type = p.get(1)
+
+    if protocol_type == 'stable'
+      output_base = protocol_name
+      input = protocols_dir / protocol_type / protocol_name / '@0@.xml'.format(output_base)
+    elif protocol_type == 'staging'
+      protocol_version = p.get(2)
+      output_base = '@0@-@1@'.format(protocol_name, protocol_version)
+      input = protocols_dir / protocol_type / protocol_name / '@0@.xml'.format(output_base)
+    elif protocol_type == 'private'
+      output_base = protocol_name
+      input = 'wayland/protocol/@0@.xml'.format(protocol_name)
+    elif protocol_type == 'third-party'
+      output_base = protocol_name
+      protocol_dir = p.get(2)
+      input = protocol_dir / '@0@.xml'.format(protocol_name)
+    else
+      protocol_version = p.get(2)
+      output_base = '@0@-@1@-@2@'.format(protocol_name,
+                                         protocol_type,
+                                         protocol_version)
+      input = protocols_dir / protocol_type / protocol_name / '@0@.xml'.format(output_base)
+    endif
+
+    server_header = custom_target('@0@ server header'.format(output_base),
+      input: input,
+      output: '@0@-server-protocol.h'.format(output_base),
+      command: [
+        wayland_scanner,
+        'server-header',
+        '@INPUT@', '@OUTPUT@',
+      ]
+    )
+    client_header = custom_target('@0@ client header'.format(output_base),
+      input: input,
+      output: '@0@-client-protocol.h'.format(output_base),
+      command: [
+        wayland_scanner,
+        'client-header',
+        '@INPUT@', '@OUTPUT@',
+      ]
+    )
+    protocol_code = custom_target('@0@ source'.format(output_base),
+      input: input,
+      output: '@0@-protocol.c'.format(output_base),
+      command: [
+        wayland_scanner,
+        'private-code',
+        '@INPUT@', '@OUTPUT@',
+      ]
+    )
+
+    wayland_protocol_files += {
+      protocol_name: {
+        'server-header': server_header,
+        'client-header': client_header,
+        'protocol-code': protocol_code,
+      },
+    }
+
+    wayland_protocol_server_headers += server_header
+    wayland_protocol_client_headers += client_header
+    wayland_protocol_sources += protocol_code
+  endforeach
+endif
+
+mutter_built_sources += wayland_protocol_server_headers
+mutter_built_sources += wayland_protocol_sources
+
+subdir('meta')
+
+mutter_built_sources += mutter_enum_types
+
+mutter_built_headers = []
+foreach built_source : mutter_built_sources
+  if built_source.full_path().endswith('.h')
+    mutter_built_headers += [built_source]
+  endif
+endforeach
+
+libmutter = shared_library(libmutter_name,
+  mutter_sources,
+  mutter_built_sources,
+  version: '0.0.0',
+  soversion: 0,
+  gnu_symbol_visibility: 'hidden',
+  include_directories: mutter_includes,
+  c_args: [
+    mutter_c_args,
+    '-DG_LOG_DOMAIN="libmutter"',
+  ],
+  dependencies: [
+    libmutter_cogl_dep,
+    libmutter_clutter_dep,
+    mutter_deps,
+  ],
+  install_rpath: pkglibdir,
+  install_dir: libdir,
+  install: true,
+)
+
+libmutter_dep = declare_dependency(
+  link_with: libmutter,
+  include_directories: mutter_includes,
+  sources: mutter_built_headers,
+  dependencies: [
+    libmutter_cogl_dep,
+    libmutter_clutter_dep,
+    mutter_deps,
+  ],
+)
+
+mutter = executable('mutter',
+  sources: [
+    files('core/mutter.c'),
+  ],
+  include_directories: mutter_includes,
+  c_args: [
+    mutter_c_args,
+    '-DG_LOG_DOMAIN="mutter"',
+  ],
+  dependencies: [libmutter_dep],
+  install_dir: bindir,
+  install: true,
+)
+if have_x11
+  executable('mutter-restart-helper',
+    sources: [
+      files('core/restart-helper.c'),
+    ],
+    include_directories: [
+      top_includepath,
+    ],
+    c_args: [
+      mutter_c_args,
+      '-DG_LOG_DOMAIN="mutter-restart-helper"',
+    ],
+    dependencies: [
+      x11_dep,
+      xcomposite_dep,
+    ],
+    install_dir: libexecdir,
+    install: true,
+  )
+endif
+
+if have_introspection
+  mutter_introspected_sources = []
+  foreach source : mutter_sources
+    if source.endswith('.c')
+      mutter_introspected_sources += source
+    endif
+  endforeach
+
+  libmutter_gir = gnome.generate_gir(libmutter,
+    sources: [
+      mutter_enum_types[1],
+      mutter_introspected_sources,
+      mutter_public_header_files
+    ],
+    nsversion: libmutter_api_version,
+    namespace: 'Meta',
+    symbol_prefix: 'meta',
+    includes: [
+      'GObject-2.0',
+      'GDesktopEnums-3.0',
+      'xlib-2.0',
+      'xfixes-4.0',
+      libmutter_cogl_gir[0],
+      libmutter_cogl_pango_gir[0],
+      libmutter_clutter_gir[0],
+      libmutter_mtk_gir[0],
+    ],
+    dependencies: [
+      libmutter_dep,
+      mutter_deps,
+    ],
+    export_packages: 'libmutter-@0@'.format(libmutter_api_version),
+    extra_args: mutter_c_args + introspection_args,
+    install_dir_gir: pkglibdir,
+    install_dir_typelib: pkglibdir,
+    install: true
+  )
+endif
+
+pkg.generate(libmutter,
+  name: 'Meta',
+  filebase: 'libmutter-' + libmutter_api_version,
+  description: 'Mutter compositor and window manager library',
+  subdirs: pkgname,
+  requires: [mutter_pkg_deps, libmutter_clutter_name],
+  version: meson.project_version(),
+  variables: [
+    'apiversion=' + libmutter_api_version,
+    'girdir=${libdir}/mutter-' + libmutter_api_version,
+    'typelibdir=${libdir}/mutter-' + libmutter_api_version,
+  ],
+  install_dir: pcdir,
+)
+
+subdir('compositor/plugins')
+if have_x11_client
+  subdir('frames')
+endif
+
+if have_core_tests
+  subdir('tests')
+endif
diff '--color=auto' -uraN a/src/tests/meson.build b/src/tests/meson.build
--- a/src/tests/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meson.build	2023-10-12 20:59:22.703834287 +0300
@@ -683,7 +683,6 @@
   'override-redirect',
   'set-override-redirect-parent',
   'set-parent-exported',
-  'restore-size',
   'unmaximize-new-size',
   'fullscreen-maximize',
   'unfullscreen-strut-change',
diff '--color=auto' -uraN a/src/tests/meta-monitor-manager-test.c b/src/tests/meta-monitor-manager-test.c
--- a/src/tests/meta-monitor-manager-test.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-manager-test.c	2023-10-12 20:59:22.713834412 +0300
@@ -325,6 +325,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
@@ -376,7 +377,8 @@
 static MetaMonitorManagerCapability
 meta_monitor_manager_test_get_capabilities (MetaMonitorManager *manager)
 {
-  return META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE;
+  return META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE |
+         META_MONITOR_MANAGER_CAPABILITY_TILING;
 }
 
 static gboolean
diff '--color=auto' -uraN a/src/tests/meta-monitor-test-utils.c b/src/tests/meta-monitor-test-utils.c
--- a/src/tests/meta-monitor-test-utils.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-test-utils.c	2023-10-12 20:59:22.690500787 +0300
@@ -394,6 +394,10 @@
                            ==,
                            meta_output_is_underscanning (output));
 
+          g_assert_cmpint (expect->monitors[i].is_vrr_disallowed,
+                           ==,
+                           meta_output_is_vrr_disallowed (output));
+
           if (!meta_output_get_max_bpc (output, &output_max_bpc))
             output_max_bpc = 0;
 
@@ -796,6 +800,7 @@
 
           output_assignment = (MetaOutputAssignment) {
             .is_underscanning = setup->outputs[i].is_underscanning,
+            .is_vrr_disallowed = setup->outputs[i].is_vrr_disallowed,
             .has_max_bpc = !!setup->outputs[i].max_bpc,
             .max_bpc = setup->outputs[i].max_bpc,
           };
diff '--color=auto' -uraN a/src/tests/meta-monitor-test-utils.h b/src/tests/meta-monitor-test-utils.h
--- a/src/tests/meta-monitor-test-utils.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-test-utils.h	2023-10-12 20:59:22.690500787 +0300
@@ -105,6 +105,7 @@
   float scale;
   gboolean is_laptop_panel;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   unsigned int max_bpc;
   const char *serial;
   MetaMonitorTransform panel_orientation_transform;
@@ -160,6 +161,7 @@
   int width_mm;
   int height_mm;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   unsigned int max_bpc;
 } MonitorTestCaseMonitor;
 
diff '--color=auto' -uraN a/src/tests/meta-ref-test.c b/src/tests/meta-ref-test.c
--- a/src/tests/meta-ref-test.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-ref-test.c	2023-10-12 20:59:22.700500912 +0300
@@ -516,6 +516,11 @@
       g_assert_cmpint (ref_status, ==, CAIRO_STATUS_SUCCESS);
       ensure_expected_format (&ref_image);
 
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  g_test_incomplete ("View comparison is not supported by this architecture");
+  return;
+#endif
+
       if (!compare_images (ref_image, view_image, &gl_fuzz,
                            &diff_stat))
         {
diff '--color=auto' -uraN a/src/tests/monitor-configs/vrr-disallowed.xml b/src/tests/monitor-configs/vrr-disallowed.xml
--- a/src/tests/monitor-configs/vrr-disallowed.xml	1970-01-01 02:00:00.000000000 +0200
+++ b/src/tests/monitor-configs/vrr-disallowed.xml	2023-10-12 20:59:22.690500787 +0300
@@ -0,0 +1,23 @@
+<monitors version="2">
+  <configuration>
+    <logicalmonitor>
+      <x>0</x>
+      <y>0</y>
+      <primary>yes</primary>
+      <monitor>
+	<monitorspec>
+	  <connector>DP-1</connector>
+	  <vendor>MetaProduct&apos;s Inc.</vendor>
+	  <product>MetaMonitor</product>
+	  <serial>0x123456</serial>
+	</monitorspec>
+	<mode>
+	  <width>1024</width>
+	  <height>768</height>
+	  <rate>60.000495910644531</rate>
+	</mode>
+	<vrr-allowed>no</vrr-allowed>
+      </monitor>
+    </logicalmonitor>
+  </configuration>
+</monitors>
diff '--color=auto' -uraN a/src/tests/monitor-store-unit-tests.c b/src/tests/monitor-store-unit-tests.c
--- a/src/tests/monitor-store-unit-tests.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/monitor-store-unit-tests.c	2023-10-12 20:59:22.690500787 +0300
@@ -48,6 +48,7 @@
   const char *serial;
   MonitorStoreTestCaseMonitorMode mode;
   gboolean is_underscanning;
+  gboolean disallow_vrr;
   unsigned int max_bpc;
 } MonitorStoreTestCaseMonitor;
 
@@ -197,6 +198,9 @@
           g_assert_cmpint (monitor_config->enable_underscanning,
                            ==,
                            test_monitor->is_underscanning);
+          g_assert_cmpint (monitor_config->disallow_vrr,
+                           ==,
+                           test_monitor->disallow_vrr);
           g_assert_cmpint (monitor_config->has_max_bpc,
                            ==,
                            !!test_monitor->max_bpc);
@@ -454,6 +458,51 @@
 }
 
 static void
+meta_test_monitor_store_vrr_disallowed (void)
+{
+  MonitorStoreTestExpect expect = {
+    .configurations = {
+      {
+        .logical_monitors = {
+          {
+            .layout = {
+              .x = 0,
+              .y = 0,
+              .width = 1024,
+              .height = 768
+            },
+            .scale = 1,
+            .is_primary = TRUE,
+            .is_presentation = FALSE,
+            .monitors = {
+              {
+                .connector = "DP-1",
+                .vendor = "MetaProduct's Inc.",
+                .product = "MetaMonitor",
+                .serial = "0x123456",
+                .mode = {
+                  .width = 1024,
+                  .height = 768,
+                  .refresh_rate = 60.000495910644531
+                },
+                .disallow_vrr = TRUE,
+              }
+            },
+            .n_monitors = 1,
+          },
+        },
+        .n_logical_monitors = 1
+      }
+    },
+    .n_configurations = 1
+  };
+
+  meta_set_custom_monitor_config (test_context, "vrr-disallowed.xml");
+
+  check_monitor_store_configurations (&expect);
+}
+
+static void
 meta_test_monitor_store_max_bpc (void)
 {
   MonitorStoreTestExpect expect = {
@@ -1047,6 +1096,8 @@
                    meta_test_monitor_store_primary);
   g_test_add_func ("/backends/monitor-store/underscanning",
                    meta_test_monitor_store_underscanning);
+  g_test_add_func ("/backends/monitor-store/vrr-disallowed",
+                   meta_test_monitor_store_vrr_disallowed);
   g_test_add_func ("/backends/monitor-store/max-bpc",
                    meta_test_monitor_store_max_bpc);
   g_test_add_func ("/backends/monitor-store/scale",
diff '--color=auto' -uraN a/src/tests/monitor-unit-tests.c b/src/tests/monitor-unit-tests.c
--- a/src/tests/monitor-unit-tests.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/monitor-unit-tests.c	2023-10-12 20:59:22.693834162 +0300
@@ -3255,6 +3255,100 @@
 }
 
 static void
+meta_test_monitor_vrr_disallowed_config (void)
+{
+  MonitorTestCase test_case = {
+    .setup = {
+      .modes = {
+        {
+          .width = 1024,
+          .height = 768,
+          .refresh_rate = 60.0
+        }
+      },
+      .n_modes = 1,
+      .outputs = {
+        {
+          .crtc = 0,
+          .modes = { 0 },
+          .n_modes = 1,
+          .preferred_mode = 0,
+          .possible_crtcs = { 0 },
+          .n_possible_crtcs = 1,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0
+        }
+      },
+      .n_crtcs = 1
+    },
+
+    .expect = {
+      .monitors = {
+        {
+          .outputs = { 0 },
+          .n_outputs = 1,
+          .modes = {
+            {
+              .width = 1024,
+              .height = 768,
+              .refresh_rate = 60.0,
+              .crtc_modes = {
+                {
+                  .output = 0,
+                  .crtc_mode = 0
+                }
+              }
+            }
+          },
+          .n_modes = 1,
+          .current_mode = 0,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_monitors = 1,
+      .logical_monitors = {
+        {
+          .monitors = { 0 },
+          .n_monitors = 1,
+          .layout = { .x = 0, .y = 0, .width = 1024, .height = 768 },
+          .scale = 1
+        }
+      },
+      .n_logical_monitors = 1,
+      .primary_logical_monitor = 0,
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0,
+        }
+      },
+      .n_crtcs = 1,
+      .screen_width = 1024,
+      .screen_height = 768
+    }
+  };
+  MetaMonitorTestSetup *test_setup;
+
+  test_setup = meta_create_monitor_test_setup (test_backend,
+                                               &test_case.setup,
+                                               MONITOR_TEST_FLAG_NO_STORED);
+  emulate_hotplug (test_setup);
+  META_TEST_LOG_CALL ("Checking monitor configuration",
+                      meta_check_monitor_configuration (test_context,
+                                                        &test_case.expect));
+  check_monitor_test_clients_state ();
+}
+
+static void
 meta_test_monitor_max_bpc_config (void)
 {
   MonitorTestCase test_case = {
@@ -5840,6 +5934,103 @@
 }
 
 static void
+meta_test_monitor_custom_vrr_disallowed_config (void)
+{
+  MonitorTestCase test_case = {
+    .setup = {
+      .modes = {
+        {
+          .width = 1024,
+          .height = 768,
+          .refresh_rate = 60.000495910644531
+        }
+      },
+      .n_modes = 1,
+      .outputs = {
+        {
+          .crtc = 0,
+          .modes = { 0 },
+          .n_modes = 1,
+          .preferred_mode = 0,
+          .possible_crtcs = { 0 },
+          .n_possible_crtcs = 1,
+          .width_mm = 222,
+          .height_mm = 125,
+          .serial = "0x123456",
+        },
+      },
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0
+        },
+      },
+      .n_crtcs = 1
+    },
+
+    .expect = {
+      .monitors = {
+        {
+          .outputs = { 0 },
+          .n_outputs = 1,
+          .modes = {
+            {
+              .width = 1024,
+              .height = 768,
+              .refresh_rate = 60.000495910644531,
+              .crtc_modes = {
+                {
+                  .output = 0,
+                  .crtc_mode = 0
+                }
+              }
+            }
+          },
+          .n_modes = 1,
+          .current_mode = 0,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_monitors = 1,
+      .logical_monitors = {
+        {
+          .monitors = { 0 },
+          .n_monitors = 1,
+          .layout = { .x = 0, .y = 0, .width = 1024, .height = 768 },
+          .scale = 1
+        }
+      },
+      .n_logical_monitors = 1,
+      .primary_logical_monitor = 0,
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0,
+        }
+      },
+      .n_crtcs = 1,
+      .n_tiled_monitors = 0,
+      .screen_width = 1024,
+      .screen_height = 768
+    }
+  };
+  MetaMonitorTestSetup *test_setup;
+
+  test_setup = meta_create_monitor_test_setup (test_backend,
+                                               &test_case.setup,
+                                               MONITOR_TEST_FLAG_NONE);
+  meta_set_custom_monitor_config (test_context, "vrr-disallowed.xml");
+  emulate_hotplug (test_setup);
+
+  META_TEST_LOG_CALL ("Checking monitor configuration",
+                      meta_check_monitor_configuration (test_context,
+                                                        &test_case.expect));
+  check_monitor_test_clients_state ();
+}
+
+static void
 meta_test_monitor_custom_scale_config (void)
 {
   MonitorTestCase test_case = {
@@ -9624,6 +9815,8 @@
                     meta_test_monitor_no_outputs);
   add_monitor_test ("/backends/monitor/underscanning-config",
                     meta_test_monitor_underscanning_config);
+  add_monitor_test ("/backends/monitor/vrr-disallowed-config",
+                    meta_test_monitor_vrr_disallowed_config);
   add_monitor_test ("/backends/monitor/max-bpc-config",
                     meta_test_monitor_max_bpc_config);
   add_monitor_test ("/backends/monitor/preferred-non-first-mode",
@@ -9658,6 +9851,8 @@
                     meta_test_monitor_custom_primary_config);
   add_monitor_test ("/backends/monitor/custom/underscanning-config",
                     meta_test_monitor_custom_underscanning_config);
+  add_monitor_test ("/backends/monitor/custom/vrr-disallowed-config",
+                    meta_test_monitor_custom_vrr_disallowed_config);
   add_monitor_test ("/backends/monitor/custom/scale-config",
                     meta_test_monitor_custom_scale_config);
   add_monitor_test ("/backends/monitor/custom/fractional-scale-config",
diff '--color=auto' -uraN a/src/tests/native-headless.c b/src/tests/native-headless.c
--- a/src/tests/native-headless.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/native-headless.c	2023-10-12 20:59:22.703834287 +0300
@@ -26,7 +26,8 @@
 init_tests (MetaContext *context)
 {
   init_virtual_monitor_tests (context);
-  init_screen_cast_tests ();
+  // init_screen_cast_tests ();
+  (void) init_screen_cast_tests;
 }
 
 int
diff '--color=auto' -uraN a/src/tests/native-thread.c b/src/tests/native-thread.c
--- a/src/tests/native-thread.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/native-thread.c	2023-10-12 20:59:22.707167662 +0300
@@ -1156,6 +1156,12 @@
                                 g_variant_new ("(t)", gettid ()));
 
   g_variant_get (ret, "(u)", &priority);
+
+#if defined  __arm__ || defined __i386__
+  g_test_incomplete ("Modifying thread priority is not supported by this architecture");
+  return;
+#endif
+
   g_assert_cmpint (priority, ==, 20);
 
   return NULL;
diff '--color=auto' -uraN a/src/tests/ref-test-sanity.c b/src/tests/ref-test-sanity.c
--- a/src/tests/ref-test-sanity.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/ref-test-sanity.c	2023-10-12 20:59:22.700500912 +0300
@@ -108,6 +108,11 @@
   clutter_actor_set_background_color (actor2, CLUTTER_COLOR_SkyBlue);
   clutter_actor_add_child (stage, actor2);
 
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  g_test_incomplete ("View comparison is not supported by this architecture");
+  return;
+#endif
+
   g_test_expect_message ("libmutter-test",
                          G_LOG_LEVEL_CRITICAL,
                          "Pixel difference exceeds limits*");
diff '--color=auto' -uraN a/src/tests/stacking/unmaximize-new-size.metatest b/src/tests/stacking/unmaximize-new-size.metatest
--- a/src/tests/stacking/unmaximize-new-size.metatest	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/stacking/unmaximize-new-size.metatest	2023-10-12 20:59:22.703834287 +0300
@@ -11,11 +11,9 @@
 
 maximize w/1
 wait_reconfigure
-assert_size w/1 MONITOR_WIDTH MONITOR_HEIGHT
 
 resize w/1 300 500
 wait_reconfigure
-assert_size w/1 MONITOR_WIDTH MONITOR_HEIGHT
 
 unmaximize w/1
 wait_reconfigure
