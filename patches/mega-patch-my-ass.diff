diff '--color=auto' -ruN a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
--- a/clutter/clutter/clutter-frame-clock.c	2023-09-16 23:51:03.000000000 +0300
+++ b/clutter/clutter/clutter-frame-clock.c	2023-10-03 20:26:00.169129039 +0300
@@ -37,6 +37,8 @@
 
 #define SYNC_DELAY_FALLBACK_FRACTION 0.875
 
+#define MINIMUM_REFRESH_RATE 30
+
 typedef struct _ClutterFrameListener
 {
   const ClutterFrameListenerIface *iface;
@@ -54,6 +56,7 @@
 {
   CLUTTER_FRAME_CLOCK_STATE_INIT,
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
+  CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
   CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
@@ -65,6 +68,8 @@
 
   float refresh_rate;
   int64_t refresh_interval_us;
+  int64_t minimum_refresh_interval_us;
+
   ClutterFrameListener listener;
 
   GSource *source;
@@ -72,6 +77,8 @@
   int64_t frame_count;
 
   ClutterFrameClockState state;
+  ClutterFrameClockMode mode;
+
   int64_t last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
   int64_t last_presentation_time_us;
@@ -375,6 +382,7 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -395,6 +403,7 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -597,6 +606,39 @@
   *out_min_render_time_allowed_us = min_render_time_allowed_us;
 }
 
+static void
+calculate_next_idle_timeout_us (ClutterFrameClock *frame_clock,
+                                int64_t           *out_next_update_time_us)
+{
+  int64_t now_us;
+  int64_t last_presentation_time_us;
+  int64_t next_presentation_time_us;
+  int64_t timeout_interval_us;
+
+  now_us = g_get_monotonic_time ();
+
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
+
+  timeout_interval_us = frame_clock->minimum_refresh_interval_us;
+
+  if (last_presentation_time_us == 0)
+    {
+      *out_next_update_time_us =
+        frame_clock->last_dispatch_time_us ?
+        ((frame_clock->last_dispatch_time_us -
+          frame_clock->last_dispatch_lateness_us) + timeout_interval_us) :
+        now_us;
+      return;
+    }
+
+  next_presentation_time_us = last_presentation_time_us + timeout_interval_us;
+
+  while (next_presentation_time_us < now_us)
+    next_presentation_time_us += timeout_interval_us;
+
+  *out_next_update_time_us = next_presentation_time_us;
+}
+
 void
 clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
 {
@@ -609,6 +651,7 @@
         case CLUTTER_FRAME_CLOCK_STATE_INIT:
         case CLUTTER_FRAME_CLOCK_STATE_IDLE:
           break;
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
         case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
           frame_clock->pending_reschedule = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
@@ -650,6 +693,7 @@
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
       next_update_time_us = g_get_monotonic_time ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -682,15 +726,12 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
       next_update_time_us = g_get_monotonic_time ();
-      break;
+      g_source_set_ready_time (frame_clock->source, next_update_time_us);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      return;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      calculate_next_update_time_us (frame_clock,
-                                     &next_update_time_us,
-                                     &frame_clock->next_presentation_time_us,
-                                     &frame_clock->min_render_time_allowed_us);
-      frame_clock->is_next_presentation_time_valid =
-        (frame_clock->next_presentation_time_us != 0);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -699,11 +740,56 @@
       return;
     }
 
+  switch (frame_clock->mode)
+    {
+    case CLUTTER_FRAME_CLOCK_MODE_FIXED:
+      calculate_next_update_time_us (frame_clock,
+                                     &next_update_time_us,
+                                     &frame_clock->next_presentation_time_us,
+                                     &frame_clock->min_render_time_allowed_us);
+      frame_clock->is_next_presentation_time_valid =
+            (frame_clock->next_presentation_time_us != 0);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      break;
+    case CLUTTER_FRAME_CLOCK_MODE_VARIABLE:
+      calculate_next_idle_timeout_us (frame_clock,
+                                      &next_update_time_us);
+      frame_clock->is_next_presentation_time_valid = FALSE;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT;
+      break;
+    }
+
   g_warn_if_fail (next_update_time_us != -1);
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+}
+
+void
+clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                              ClutterFrameClockMode  mode)
+{
+  if (frame_clock->mode == mode)
+    return;
+
+  frame_clock->mode = mode;
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+      frame_clock->pending_reschedule = TRUE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      break;
+    }
+
+  maybe_reschedule_update (frame_clock);
 }
 
 static void
@@ -794,6 +880,7 @@
       g_warn_if_reached ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -918,6 +1005,10 @@
   init_frame_clock_source (frame_clock);
 
   clutter_frame_clock_set_refresh_rate (frame_clock, refresh_rate);
+
+  frame_clock->minimum_refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / MINIMUM_REFRESH_RATE);
+
   frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
@@ -951,6 +1042,7 @@
 clutter_frame_clock_init (ClutterFrameClock *frame_clock)
 {
   frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_INIT;
+  frame_clock->mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
 }
 
 static void
diff '--color=auto' -ruN a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
--- a/clutter/clutter/clutter-frame-clock.h	2023-09-16 23:51:03.000000000 +0300
+++ b/clutter/clutter/clutter-frame-clock.h	2023-10-03 20:26:00.169129039 +0300
@@ -54,6 +54,12 @@
                                 gpointer           user_data);
 } ClutterFrameListenerIface;
 
+typedef enum _ClutterFrameClockMode
+{
+  CLUTTER_FRAME_CLOCK_MODE_FIXED,
+  CLUTTER_FRAME_CLOCK_MODE_VARIABLE,
+} ClutterFrameClockMode;
+
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
                                              int64_t                          vblank_duration_us,
@@ -64,6 +70,10 @@
 void clutter_frame_clock_destroy (ClutterFrameClock *frame_clock);
 
 CLUTTER_EXPORT
+void clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                                   ClutterFrameClockMode  mode);
+
+CLUTTER_EXPORT
 void clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                            ClutterFrameInfo  *frame_info);
 
diff '--color=auto' -ruN a/cogl/cogl/winsys/cogl-onscreen-glx.c b/cogl/cogl/winsys/cogl-onscreen-glx.c
--- a/cogl/cogl/winsys/cogl-onscreen-glx.c	2023-09-16 23:51:03.000000000 +0300
+++ b/cogl/cogl/winsys/cogl-onscreen-glx.c	2023-10-03 20:26:00.165795662 +0300
@@ -540,6 +540,8 @@
   GLXDrawable drawable;
   unsigned int age = 0;
 
+  return 0;
+
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_BUFFER_AGE))
     return 0;
 
diff '--color=auto' -ruN a/data/61-mutter.rules b/data/61-mutter.rules
--- a/data/61-mutter.rules	2023-09-16 23:51:03.000000000 +0300
+++ b/data/61-mutter.rules	2023-10-03 20:26:00.169129039 +0300
@@ -1,3 +1,4 @@
+DRIVERS=="i915", SUBSYSTEM=="drm", TAG+="mutter-device-disable-vrr"
 DRIVERS=="i915", SUBSYSTEM=="drm", ATTRS{vendor}=="0x8086", ATTRS{device}=="0x1602", TAG+="mutter-device-disable-kms-modifiers"
 DRIVERS=="i915", SUBSYSTEM=="drm", ATTRS{vendor}=="0x8086", ATTRS{device}=="0x1606", TAG+="mutter-device-disable-kms-modifiers"
 DRIVERS=="i915", SUBSYSTEM=="drm", ATTRS{vendor}=="0x8086", ATTRS{device}=="0x160a", TAG+="mutter-device-disable-kms-modifiers"
diff '--color=auto' -ruN a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml	2023-09-16 23:51:03.000000000 +0300
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml	2023-10-03 20:26:00.169129039 +0300
@@ -343,6 +343,10 @@
 	    - "is-underscanning" (b): whether underscanning is enabled
 				      (absence of this means underscanning
 				      not being supported)
+	    - "is-vrr-allowed" (b): whether variable refresh rate is allowed
+	                            (absence of this means variable refresh
+	                            rate not being supported)
+
 	    - "max-screen-size" (ii): the maximum size a screen may have
 				      (absence of this means unlimited screen
 				      size)
@@ -413,6 +417,11 @@
 			     using the logical monitor scale.
 	    * 2 : physical - the dimension of a logical monitor is derived from
 			     the monitor modes associated with it.
+	    * 3 : logical with ui scaling - the dimension of a logical monitor
+			     is derived from the monitor modes associated with it,
+			     then scaled using the logical monitor scale that is also
+			     scaled by the global UI scaling (computed using the maximum
+			     ceiled scaling value across the displays).
 	* "supports-changing-layout-mode" (b): True if the layout mode can be
 					       changed. Absence of this means the
 					       layout mode cannot be changed.
@@ -461,6 +470,9 @@
 	        - "enable_underscanning" (b): enable monitor underscanning;
 					      may only be set when underscanning
 					      is supported (see GetCurrentState).
+	        - "allow_vrr" (b): whether to allow variable refresh rate; may
+	                           only be set when variable refresh rate is
+	                           supported (see GetCurrentState).
 
 	@properties may effect the global monitor configuration state. Possible
 	properties are:
diff '--color=auto' -ruN a/data/meson.build b/data/meson.build
--- a/data/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/data/meson.build	2023-10-03 20:26:00.102461495 +0300
@@ -41,6 +41,13 @@
   install_dir: schemadir
 )
 
+configure_file(
+  input: 'org.gnome.mutter.x11.gschema.xml.in',
+  output: 'org.gnome.mutter.x11.gschema.xml',
+  configuration: gschema_config,
+  install_dir: schemadir
+)
+
 install_data(['mutter-schemas.convert'],
   install_dir: datadir / 'GConf/gsettings',
 )
diff '--color=auto' -ruN a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
--- a/data/org.gnome.mutter.gschema.xml.in	2023-09-16 23:51:03.000000000 +0300
+++ b/data/org.gnome.mutter.gschema.xml.in	2023-10-03 20:27:52.250610631 +0300
@@ -5,6 +5,7 @@
     <value nick="kms-modifiers" value="2"/>
     <value nick="rt-scheduler" value="4"/>
     <value nick="autoclose-xwayland" value="8"/>
+    <value nick="variable-refresh-rate" value="16"/>
   </flags>
 
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
@@ -101,8 +102,7 @@
       </description>
     </key>
 
-    <key name="experimental-features"
-        flags='org.gnome.mutter.MetaExperimentalFeature'>
+    <key name="experimental-features" type="as">
       <default>[]</default>
       <summary>Enable experimental features</summary>
       <description>
@@ -133,6 +133,17 @@
                                         relevant X11 clients are gone.
                                         Requires a restart.
 
+        • “x11-randr-fractional-scaling” — enable fractional scaling under X11
+                                           using xrandr scaling. It might reduce
+                                           performances.
+                                           Does not require a restart.
+                                           
+        • “variable-refresh-rate”     — makes mutter dynamically adjust the
+                                        refresh rate of the monitor when
+                                        applicable if supported by the monitor,
+                                        GPU and DRM driver. Configurable in
+                                        Settings. Requires a restart.
+
       </description>
     </key>
 
diff '--color=auto' -ruN a/data/org.gnome.mutter.x11.gschema.xml.in b/data/org.gnome.mutter.x11.gschema.xml.in
--- a/data/org.gnome.mutter.x11.gschema.xml.in	1970-01-01 02:00:00.000000000 +0200
+++ b/data/org.gnome.mutter.x11.gschema.xml.in	2023-10-03 20:26:00.102461495 +0300
@@ -0,0 +1,30 @@
+<schemalist>
+
+  <enum id="org.gnome.mutter.X11.scale-mode">
+    <value nick="scale-up" value="1"/>
+    <value nick="scale-ui-down" value="2"/>
+  </enum>
+
+  <schema id="org.gnome.mutter.x11" path="/org/gnome/mutter/x11/"
+          gettext-domain="@GETTEXT_DOMAIN@">
+
+    <key name="fractional-scale-mode" enum="org.gnome.mutter.X11.scale-mode">
+      <default>"scale-ui-down"</default>
+      <description>
+        Choose the scaling mode to be used under X11 via Randr extension.
+
+        Supported methods are:
+
+        • “scale-up”     — Scale everything up to the requested scale, shrinking
+                           the UI. The applications will look blurry when scaling
+                           at higher values and the resolution will be lowered.
+        • “scale-ui-down — Scale up the UI toolkits to the closest integer
+                           scaling value upwards, while scale down the display
+                           to match the requested scaling level.
+                           It increases the resolution of the logical display.
+      </description>
+    </key>
+
+  </schema>
+
+</schemalist>
diff '--color=auto' -ruN a/meson.build b/meson.build
--- a/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/meson.build	2023-10-03 20:26:00.099128118 +0300
@@ -398,7 +398,7 @@
 
   add_test_setup('plain')
 
-  xvfb = find_program('xvfb-run')
+  xvfb = find_program('xvfb-run', required: false)
   xvfb_args = [
     '-a',
     '-s',
diff '--color=auto' -ruN a/src/backends/meta-crtc.c b/src/backends/meta-crtc.c
--- a/src/backends/meta-crtc.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-crtc.c	2023-10-03 20:26:00.102461495 +0300
@@ -125,6 +125,7 @@
   config->layout = *layout;
   config->mode = mode;
   config->transform = transform;
+  config->scale = 1.0f;
 
   priv->config = config;
 }
@@ -289,6 +290,26 @@
                  gamma->size * sizeof (uint16_t)) == 0;
 }
 
+void
+meta_crtc_set_config_scale (MetaCrtc *crtc,
+                            float    scale)
+{
+  MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+
+  g_return_if_fail (scale > 0);
+
+  if (priv->config)
+    priv->config->scale = scale;
+}
+
+float
+meta_crtc_get_config_scale (MetaCrtc *crtc)
+{
+  MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+
+  return priv->config ? priv->config->scale : 1.0f;
+}
+
 static void
 meta_crtc_set_property (GObject      *object,
                         guint         prop_id,
diff '--color=auto' -ruN a/src/backends/meta-crtc.h b/src/backends/meta-crtc.h
--- a/src/backends/meta-crtc.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-crtc.h	2023-10-03 20:26:00.102461495 +0300
@@ -30,6 +30,7 @@
   graphene_rect_t layout;
   MetaMonitorTransform transform;
   MetaCrtcMode *mode;
+  float scale;
 } MetaCrtcConfig;
 
 #define META_TYPE_CRTC (meta_crtc_get_type ())
@@ -75,6 +76,11 @@
                            MetaCrtcMode         *mode,
                            MetaMonitorTransform  transform);
 
+void meta_crtc_set_config_scale (MetaCrtc *crtc,
+                                 float    scale);
+
+float meta_crtc_get_config_scale (MetaCrtc *crtc);
+
 META_EXPORT_TEST
 void meta_crtc_unset_config (MetaCrtc *crtc);
 
diff '--color=auto' -ruN a/src/backends/meta-egl.c b/src/backends/meta-egl.c
--- a/src/backends/meta-egl.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-egl.c	2023-10-03 20:26:00.165795662 +0300
@@ -238,6 +238,14 @@
   return has_extensions;
 }
 
+const char *
+meta_egl_query_string (MetaEgl    *egl,
+                       EGLDisplay  display,
+                       EGLint      name)
+{
+  return eglQueryString (display, name);
+}
+
 gboolean
 meta_egl_initialize (MetaEgl   *egl,
                      EGLDisplay display,
diff '--color=auto' -ruN a/src/backends/meta-egl.h b/src/backends/meta-egl.h
--- a/src/backends/meta-egl.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-egl.h	2023-10-03 20:26:00.165795662 +0300
@@ -47,6 +47,10 @@
                                   const char   *first_extension,
                                   ...);
 
+const char * meta_egl_query_string (MetaEgl    *egl,
+                                    EGLDisplay  display,
+                                    EGLint      name);
+
 gboolean meta_egl_initialize (MetaEgl   *egl,
                               EGLDisplay display,
                               GError   **error);
diff '--color=auto' -ruN a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
--- a/src/backends/meta-monitor.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor.c	2023-10-03 20:26:00.169129039 +0300
@@ -371,6 +371,25 @@
 }
 
 gboolean
+meta_monitor_is_vrr_capable (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_monitor_is_vrr_disallowed (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_vrr_disallowed (output);
+}
+
+gboolean
 meta_monitor_get_max_bpc (MetaMonitor  *monitor,
                           unsigned int *max_bpc)
 {
@@ -1984,7 +2003,6 @@
   i = 0;
   found_one = FALSE;
   base_scaled_w = floorf (width / scale);
-
   do
     {
       for (j = 0; j < 2; j++)
diff '--color=auto' -ruN a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
--- a/src/backends/meta-monitor-config-manager.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-manager.c	2023-10-03 20:26:00.169129039 +0300
@@ -216,6 +216,18 @@
   else
     crtc_hw_transform = META_MONITOR_TRANSFORM_NORMAL;
 
+  scale = data->logical_monitor_config->scale;
+  if (!meta_monitor_manager_is_scale_supported (data->monitor_manager,
+                                                data->config->layout_mode,
+                                                monitor, mode, scale))
+    {
+      scale = roundf (scale);
+      if (!meta_monitor_manager_is_scale_supported (data->monitor_manager,
+                                                    data->config->layout_mode,
+                                                    monitor, mode, scale))
+        scale = 1.0;
+    }
+
   meta_monitor_calculate_crtc_pos (monitor, mode, output, crtc_transform,
                                    &crtc_x, &crtc_y);
 
@@ -230,6 +242,8 @@
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       scale = 1.0;
       break;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      break;
     }
 
   crtc_mode = monitor_crtc_mode->crtc_mode;
@@ -257,6 +271,7 @@
     .mode = crtc_mode,
     .layout = crtc_layout,
     .transform = crtc_hw_transform,
+    .scale = scale,
     .outputs = g_ptr_array_new ()
   };
   g_ptr_array_add (crtc_assignment->outputs, output);
@@ -285,6 +300,7 @@
     .is_primary = assign_output_as_primary,
     .is_presentation = assign_output_as_presentation,
     .is_underscanning = data->monitor_config->enable_underscanning,
+    .is_vrr_disallowed = data->monitor_config->disallow_vrr,
     .has_max_bpc = data->monitor_config->has_max_bpc,
     .max_bpc = data->monitor_config->max_bpc
   };
@@ -691,7 +707,8 @@
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = meta_monitor_spec_clone (monitor_spec),
     .mode_spec = g_memdup2 (mode_spec, sizeof (MetaMonitorModeSpec)),
-    .enable_underscanning = meta_monitor_is_underscanning (monitor)
+    .enable_underscanning = meta_monitor_is_underscanning (monitor),
+    .disallow_vrr = meta_monitor_is_vrr_disallowed (monitor),
   };
 
   monitor_config->has_max_bpc =
@@ -722,6 +739,7 @@
 static void
 scale_logical_monitor_width (MetaLogicalMonitorLayoutMode  layout_mode,
                              float                         scale,
+                             float                         max_scale,
                              int                           mode_width,
                              int                           mode_height,
                              int                          *width,
@@ -733,6 +751,13 @@
       *width = (int) roundf (mode_width / scale);
       *height = (int) roundf (mode_height / scale);
       return;
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      {
+        float ui_scale = scale / ceilf (max_scale);
+        *width = (int) roundf (mode_width / ui_scale);
+        *height = (int) roundf (mode_height / ui_scale);
+      }
+      return;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       *width = mode_width;
       *height = mode_height;
@@ -742,12 +767,37 @@
   g_assert_not_reached ();
 }
 
+static float
+get_preferred_preferred_max_scale (MetaMonitorManager           *monitor_manager,
+                                   GList                        *monitors,
+                                   MetaLogicalMonitorLayoutMode  layout_mode)
+{
+  float scale = 1.0;
+  GList *l;
+
+  for (l = monitors; l; l = l->next)
+    {
+      float s;
+      MetaMonitor *monitor = l->data;
+      MetaMonitorMode *mode = meta_monitor_get_preferred_mode (monitor);
+
+      s = meta_monitor_manager_calculate_monitor_mode_scale (monitor_manager,
+                                                             layout_mode,
+                                                             monitor,
+                                                             mode);
+      scale = MAX (scale, s);
+    }
+
+  return scale;
+}
+
 static MetaLogicalMonitorConfig *
 create_preferred_logical_monitor_config (MetaMonitorManager          *monitor_manager,
                                          MetaMonitor                 *monitor,
                                          int                          x,
                                          int                          y,
                                          float                        scale,
+                                         float                        max_scale,
                                          MetaLogicalMonitorLayoutMode layout_mode)
 {
   MetaMonitorMode *mode;
@@ -758,7 +808,7 @@
 
   mode = meta_monitor_get_preferred_mode (monitor);
   meta_monitor_mode_get_resolution (mode, &width, &height);
-  scale_logical_monitor_width (layout_mode, scale,
+  scale_logical_monitor_width (layout_mode, scale, max_scale,
                                width, height, &width, &height);
 
   monitor_config = create_monitor_config (monitor, mode);
@@ -937,6 +987,7 @@
   MetaMonitor *primary_monitor;
   MetaLogicalMonitorLayoutMode layout_mode;
   float scale;
+  float max_scale = 1.0;
   GList *l;
   int x, y;
 
@@ -956,6 +1007,10 @@
    */
   monitors = g_list_prepend (monitors, primary_monitor);
 
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    max_scale = get_preferred_preferred_max_scale (monitor_manager, monitors,
+                                                   layout_mode);
+
   for (l = monitors; l; l = l->next)
     {
       MetaMonitor *monitor = l->data;
@@ -979,6 +1034,7 @@
         create_preferred_logical_monitor_config (monitor_manager,
                                                  monitor,
                                                  x, y, scale,
+                                                 max_scale,
                                                  layout_mode);
       logical_monitor_config->is_primary = (monitor == primary_monitor);
       logical_monitor_configs = g_list_append (logical_monitor_configs,
@@ -1045,6 +1101,7 @@
         .mode_spec = g_memdup2 (monitor_config_in->mode_spec,
                                 sizeof (MetaMonitorModeSpec)),
         .enable_underscanning = monitor_config_in->enable_underscanning,
+        .disallow_vrr = monitor_config_in->disallow_vrr,
         .has_max_bpc = monitor_config_in->has_max_bpc,
         .max_bpc = monitor_config_in->max_bpc
       };
@@ -1224,6 +1281,39 @@
                                               META_MONITOR_TRANSFORM_NORMAL);
 }
 
+MetaMonitorsConfig *
+meta_monitor_config_manager_create_for_layout (MetaMonitorConfigManager     *config_manager,
+                                               MetaMonitorsConfig           *config,
+                                               MetaLogicalMonitorLayoutMode  layout_mode)
+{
+  MetaMonitorManager *monitor_manager = config_manager->monitor_manager;
+  GList *logical_monitor_configs;
+  GList *l;
+
+  if (!config)
+    return NULL;
+
+  if (config->layout_mode == layout_mode)
+    return g_object_ref (config);
+
+  logical_monitor_configs =
+    clone_logical_monitor_config_list (config->logical_monitor_configs);
+
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL)
+    {
+      for (l = logical_monitor_configs; l; l = l->next)
+        {
+          MetaLogicalMonitorConfig *monitor_config = l->data;
+          monitor_config->scale = roundf (monitor_config->scale);
+        }
+    }
+
+  return meta_monitors_config_new (monitor_manager,
+                                   logical_monitor_configs,
+                                   layout_mode,
+                                   META_MONITORS_CONFIG_FLAG_NONE);
+}
+
 static MetaMonitorsConfig *
 create_monitors_switch_config (MetaMonitorConfigManager    *config_manager,
                                MonitorMatchRule             match_rule,
@@ -1254,6 +1344,7 @@
   GList *monitor_configs = NULL;
   gint common_mode_w = 0, common_mode_h = 0;
   float best_scale = 1.0;
+  float max_scale = 1.0;
   MetaMonitor *monitor;
   GList *modes;
   GList *monitors;
@@ -1345,7 +1436,11 @@
       monitor_configs = g_list_prepend (monitor_configs, create_monitor_config (monitor, mode));
     }
 
-  scale_logical_monitor_width (layout_mode, best_scale,
+  if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    max_scale = get_preferred_preferred_max_scale (monitor_manager, monitors,
+                                                   layout_mode);
+
+  scale_logical_monitor_width (layout_mode, best_scale, max_scale,
                                common_mode_w, common_mode_h,
                                &width, &height);
 
@@ -1815,6 +1910,7 @@
 meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
                                     MetaLogicalMonitorLayoutMode layout_mode,
                                     MetaMonitorManager          *monitor_manager,
+                                    float                        max_scale,
                                     GError                     **error)
 {
   GList *l;
@@ -1851,6 +1947,10 @@
 
   switch (layout_mode)
     {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      expected_mode_width /= ceilf (max_scale);
+      expected_mode_height /= ceilf (max_scale);
+      /* fall through! */
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
       expected_mode_width = roundf (expected_mode_width *
                                     logical_monitor_config->scale);
diff '--color=auto' -ruN a/src/backends/meta-monitor-config-manager.h b/src/backends/meta-monitor-config-manager.h
--- a/src/backends/meta-monitor-config-manager.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-manager.h	2023-10-03 20:26:00.169129039 +0300
@@ -31,6 +31,7 @@
   MetaMonitorSpec *monitor_spec;
   MetaMonitorModeSpec *mode_spec;
   gboolean enable_underscanning;
+  gboolean disallow_vrr;
   gboolean has_max_bpc;
   unsigned int max_bpc;
 } MetaMonitorConfig;
@@ -115,6 +116,10 @@
 META_EXPORT_TEST
 MetaMonitorsConfig * meta_monitor_config_manager_create_for_rotate_monitor (MetaMonitorConfigManager *config_manager);
 
+MetaMonitorsConfig * meta_monitor_config_manager_create_for_layout (MetaMonitorConfigManager     *config_manager,
+                                                                    MetaMonitorsConfig           *config,
+                                                                    MetaLogicalMonitorLayoutMode  layout_mode);
+
 META_EXPORT_TEST
 MetaMonitorsConfig * meta_monitor_config_manager_create_for_switch_config (MetaMonitorConfigManager    *config_manager,
                                                                            MetaMonitorSwitchConfigType  config_type);
@@ -200,6 +205,7 @@
 gboolean meta_verify_logical_monitor_config (MetaLogicalMonitorConfig    *logical_monitor_config,
                                              MetaLogicalMonitorLayoutMode layout_mode,
                                              MetaMonitorManager          *monitor_manager,
+                                             float                        max_scale,
                                              GError                     **error);
 
 META_EXPORT_TEST
diff '--color=auto' -ruN a/src/backends/meta-monitor-config-store.c b/src/backends/meta-monitor-config-store.c
--- a/src/backends/meta-monitor-config-store.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-config-store.c	2023-10-03 20:26:00.169129039 +0300
@@ -165,6 +165,7 @@
   STATE_MONITOR_MODE_RATE,
   STATE_MONITOR_MODE_FLAG,
   STATE_MONITOR_UNDERSCANNING,
+  STATE_MONITOR_VRR_ALLOWED,
   STATE_MONITOR_MAXBPC,
   STATE_DISABLED,
   STATE_POLICY,
@@ -450,6 +451,10 @@
           {
             parser->state = STATE_MONITOR_UNDERSCANNING;
           }
+        else if (g_str_equal (element_name, "vrr-allowed"))
+          {
+            parser->state = STATE_MONITOR_VRR_ALLOWED;
+          }
         else if (g_str_equal (element_name, "maxbpc"))
           {
             parser->state = STATE_MONITOR_MAXBPC;
@@ -547,6 +552,13 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under vrr-allowed", element_name);
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
@@ -648,6 +660,7 @@
 static gboolean
 derive_logical_monitor_layout (MetaLogicalMonitorConfig    *logical_monitor_config,
                                MetaLogicalMonitorLayoutMode layout_mode,
+                               float                        max_scale,
                                GError                     **error)
 {
   MetaMonitorConfig *monitor_config;
@@ -685,6 +698,10 @@
 
   switch (layout_mode)
     {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      width *= ceilf (max_scale);
+      height *= ceilf (max_scale);
+      /* fall through! */
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
       width = roundf (width / logical_monitor_config->scale);
       height = roundf (height / logical_monitor_config->scale);
@@ -828,6 +845,14 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        g_assert (g_str_equal (element_name, "vrr-allowed"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         g_assert (g_str_equal (element_name, "maxbpc"));
@@ -900,6 +925,7 @@
         GList *l;
         MetaLogicalMonitorLayoutMode layout_mode;
         MetaMonitorsConfigFlag config_flags = META_MONITORS_CONFIG_FLAG_NONE;
+        float max_scale = 1.0f;
 
         g_assert (g_str_equal (element_name, "configuration"));
 
@@ -909,18 +935,29 @@
           layout_mode =
             meta_monitor_manager_get_default_layout_mode (store->monitor_manager);
 
+        if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+          {
+            for (l = parser->current_logical_monitor_configs; l; l = l->next)
+              {
+                MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+                max_scale = MAX (max_scale, logical_monitor_config->scale);
+              }
+          }
+
         for (l = parser->current_logical_monitor_configs; l; l = l->next)
           {
             MetaLogicalMonitorConfig *logical_monitor_config = l->data;
 
             if (!derive_logical_monitor_layout (logical_monitor_config,
                                                 layout_mode,
+                                                max_scale,
                                                 error))
               return;
 
             if (!meta_verify_logical_monitor_config (logical_monitor_config,
                                                      layout_mode,
                                                      store->monitor_manager,
+                                                     max_scale,
                                                      error))
               return;
           }
@@ -1327,6 +1364,18 @@
         return;
       }
 
+    case STATE_MONITOR_VRR_ALLOWED:
+      {
+        gboolean allow_vrr = TRUE;
+
+        read_bool (text, text_len,
+                   &allow_vrr,
+                   error);
+        parser->current_monitor_config->disallow_vrr = !allow_vrr;
+
+        return;
+      }
+
     case STATE_MONITOR_MAXBPC:
       {
         int signed_max_bpc;
@@ -1526,6 +1575,9 @@
       if (monitor_config->enable_underscanning)
         g_string_append (buffer, "        <underscanning>yes</underscanning>\n");
 
+      if (monitor_config->disallow_vrr)
+        g_string_append (buffer, "        <vrr-allowed>no</vrr-allowed>\n");
+
       if (monitor_config->has_max_bpc)
         {
           g_string_append_printf (buffer, "        <maxbpc>%u</maxbpc>\n",
diff '--color=auto' -ruN a/src/backends/meta-monitor.h b/src/backends/meta-monitor.h
--- a/src/backends/meta-monitor.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor.h	2023-10-03 20:26:00.169129039 +0300
@@ -118,6 +118,10 @@
 
 gboolean meta_monitor_is_underscanning (MetaMonitor *monitor);
 
+gboolean meta_monitor_is_vrr_capable (MetaMonitor *monitor);
+
+gboolean meta_monitor_is_vrr_disallowed (MetaMonitor *monitor);
+
 gboolean meta_monitor_get_max_bpc (MetaMonitor  *monitor,
                                    unsigned int *max_bpc);
 
diff '--color=auto' -ruN a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
--- a/src/backends/meta-monitor-manager.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager.c	2023-10-03 20:26:00.169129039 +0300
@@ -131,6 +131,15 @@
 meta_monitor_manager_is_config_complete (MetaMonitorManager *manager,
                                          MetaMonitorsConfig *config);
 
+static gboolean
+meta_monitor_manager_is_scale_supported_with_threshold (MetaMonitorManager           *manager,
+                                                        MetaLogicalMonitorLayoutMode  layout_mode,
+                                                        MetaMonitor                  *monitor,
+                                                        MetaMonitorMode              *monitor_mode,
+                                                        float                         scale,
+                                                        float                         threshold,
+                                                        float                        *out_scale);
+
 static void
 meta_monitor_manager_real_read_current_state (MetaMonitorManager *manager);
 
@@ -224,6 +233,30 @@
                                                     primary_logical_monitor);
 }
 
+float
+meta_monitor_manager_get_maximum_crtc_scale (MetaMonitorManager *manager)
+{
+  GList *l;
+  float scale;
+
+  scale = 1.0f;
+  for (l = manager->monitors; l != NULL; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaOutput *output = meta_monitor_get_main_output (monitor);
+      MetaCrtc *crtc = meta_output_get_assigned_crtc (output);
+
+      if (crtc)
+        {
+          const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+
+          scale = MAX (scale, crtc_config ? crtc_config->scale : 1.0f);
+        }
+    }
+
+  return scale;
+}
+
 static float
 derive_configured_global_scale (MetaMonitorManager *manager,
                                 MetaMonitorsConfig *config)
@@ -335,6 +368,51 @@
   return 1.0;
 }
 
+static gboolean
+derive_scale_from_crtc (MetaMonitorManager *manager,
+                        MetaMonitor        *monitor,
+                        float              *out_scale)
+{
+  MetaMonitorManagerCapability capabilities;
+  MetaMonitorMode *monitor_mode;
+  float threshold;
+  MetaOutput *output;
+  MetaCrtc *crtc;
+  float scale;
+
+  capabilities = meta_monitor_manager_get_capabilities (manager);
+
+  if (!(capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return FALSE;
+
+  if (!(capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    return FALSE;
+
+  output = meta_monitor_get_main_output (monitor);
+  crtc = meta_output_get_assigned_crtc (output);
+
+  if (!crtc)
+    return FALSE;
+
+  /* Due to integer and possibly inverse scaling applied to the output the
+   * result could not match exactly, so we apply a more relaxed threshold
+   * in this case. */
+  threshold = 0.001f;
+
+  scale = meta_crtc_get_config_scale (crtc);
+  monitor_mode = meta_monitor_get_current_mode (monitor);
+  if (meta_monitor_manager_is_scale_supported_with_threshold (manager,
+                                                              manager->layout_mode,
+                                                              monitor,
+                                                              monitor_mode,
+                                                              scale,
+                                                              threshold,
+                                                              out_scale))
+    return TRUE;
+
+  return FALSE;
+}
+
 static void
 meta_monitor_manager_rebuild_logical_monitors_derived (MetaMonitorManager *manager,
                                                        MetaMonitorsConfig *config)
@@ -382,11 +460,17 @@
           float scale;
 
           if (use_global_scale)
-            scale = global_scale;
-          else if (config)
-            scale = derive_scale_from_config (manager, config, &layout);
+            scale = roundf (global_scale);
           else
-            scale = calculate_monitor_scale (manager, monitor);
+            {
+              if (!derive_scale_from_crtc (manager, monitor, &scale))
+                {
+                  if (config)
+                    scale = derive_scale_from_config (manager, config, &layout);
+                  else
+                    scale = calculate_monitor_scale (manager, monitor);
+                }
+            }
 
           g_assert (scale > 0);
 
@@ -601,13 +685,19 @@
                                                    MetaMonitor                  *monitor,
                                                    MetaMonitorMode              *monitor_mode)
 {
+  float scale;
   MetaMonitorManagerClass *manager_class =
     META_MONITOR_MANAGER_GET_CLASS (manager);
 
-  return manager_class->calculate_monitor_mode_scale (manager,
-                                                      layout_mode,
-                                                      monitor,
-                                                      monitor_mode);
+  scale = manager_class->calculate_monitor_mode_scale (manager,
+                                                       layout_mode,
+                                                       monitor,
+                                                       monitor_mode);
+
+  if (g_list_find (manager->scale_override_monitors, monitor))
+    return ceilf (scale);
+
+  return scale;
 }
 
 float *
@@ -775,7 +865,8 @@
 should_use_stored_config (MetaMonitorManager *manager)
 {
   return (manager->in_init ||
-          !meta_monitor_manager_has_hotplug_mode_update (manager));
+          (!manager->scale_override_monitors &&
+           !meta_monitor_manager_has_hotplug_mode_update (manager)));
 }
 
 MetaMonitorsConfig *
@@ -787,6 +878,8 @@
   MetaMonitorsConfigMethod method;
   MetaMonitorsConfigMethod fallback_method =
     META_MONITORS_CONFIG_METHOD_TEMPORARY;
+  MetaLogicalMonitorLayoutMode layout_mode =
+    meta_monitor_manager_get_default_layout_mode (manager);
 
   use_stored_config = should_use_stored_config (manager);
   if (use_stored_config)
@@ -796,7 +889,18 @@
 
   if (use_stored_config)
     {
+      g_autoptr(MetaMonitorsConfig) new_config = NULL;
+
       config = meta_monitor_config_manager_get_stored (manager->config_manager);
+      if (config && config->layout_mode != layout_mode)
+        {
+          new_config =
+            meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                           config,
+                                                           layout_mode);
+          config = new_config;
+        }
+
       if (config)
         {
           g_autoptr (MetaMonitorsConfig) oriented_config = NULL;
@@ -897,6 +1001,16 @@
 
       config = g_object_ref (config);
 
+      if (config && config->layout_mode != layout_mode)
+        {
+          MetaMonitorsConfig *new_config =
+            meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                           config,
+                                                           layout_mode);
+          g_object_unref (config);
+          config = new_config;
+        }
+
       if (meta_monitor_manager_is_config_complete (manager, config))
         {
           if (!meta_monitor_manager_apply_monitors_config (manager,
@@ -1087,6 +1201,66 @@
   handle_orientation_change (orientation_manager, manager);
 }
 
+static gboolean
+apply_x11_fractional_scaling_config (MetaMonitorManager *manager)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(MetaMonitorsConfig) config = NULL;
+  MetaMonitorsConfig *applied_config;
+  MetaLogicalMonitorLayoutMode layout_mode =
+    meta_monitor_manager_get_default_layout_mode (manager);
+
+  if (!META_IS_MONITOR_MANAGER_XRANDR (manager))
+    return TRUE;
+
+  applied_config =
+    meta_monitor_config_manager_get_current (manager->config_manager);
+  config =
+    meta_monitor_config_manager_create_for_layout (manager->config_manager,
+                                                   applied_config,
+                                                   layout_mode);
+  if (!config)
+    return FALSE;
+
+  if (meta_monitor_manager_apply_monitors_config (manager,
+                                                  config,
+                                                  META_MONITORS_CONFIG_METHOD_PERSISTENT,
+                                                  &error))
+    {
+      if (config != applied_config && manager->persistent_timeout_id)
+        {
+          if (G_UNLIKELY (applied_config !=
+                          meta_monitor_config_manager_get_previous (manager->config_manager)))
+            {
+              meta_warning ("The removed configuration doesn't match the "
+                            "previously applied one, reverting may not work");
+            }
+          else
+            {
+              g_autoptr(MetaMonitorsConfig) previous_config = NULL;
+
+              /* The previous config we applied was just a temporary one that
+               * GNOME control center passed us while toggling the fractional
+               * scaling. So, in such case, once the configuration with the
+               * correct layout has been applied, we need to ignore the
+               * temporary one. */
+              previous_config =
+                meta_monitor_config_manager_pop_previous (manager->config_manager);
+
+              g_assert_true (applied_config == previous_config);
+            }
+        }
+    }
+  else
+    {
+      meta_warning ("Impossible to apply the layout config %s\n",
+                    error->message);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 static void
 experimental_features_changed (MetaSettings           *settings,
                                MetaExperimentalFeature old_experimental_features,
@@ -1094,6 +1268,8 @@
 {
   gboolean was_stage_views_scaled;
   gboolean is_stage_views_scaled;
+  gboolean was_x11_scaling;
+  gboolean x11_scaling;
   gboolean should_reconfigure = FALSE;
 
   was_stage_views_scaled =
@@ -1103,10 +1279,23 @@
     meta_settings_is_experimental_feature_enabled (
       settings,
       META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+  was_x11_scaling =
+    !!(old_experimental_features &
+       META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING);
+  x11_scaling =
+    meta_settings_is_experimental_feature_enabled (
+      settings,
+      META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING);
 
   if (is_stage_views_scaled != was_stage_views_scaled)
     should_reconfigure = TRUE;
 
+  if (was_x11_scaling != x11_scaling)
+    {
+      if (!apply_x11_fractional_scaling_config (manager))
+        should_reconfigure = TRUE;
+    }
+
   if (should_reconfigure)
     meta_monitor_manager_reconfigure (manager);
 
@@ -1330,10 +1519,11 @@
 
   manager->display_config = meta_dbus_display_config_skeleton_new ();
 
-  g_signal_connect_object (settings,
-                           "experimental-features-changed",
-                           G_CALLBACK (experimental_features_changed),
-                           manager, 0);
+  manager->experimental_features_changed_handler_id =
+    g_signal_connect_object (settings,
+                             "experimental-features-changed",
+                             G_CALLBACK (experimental_features_changed),
+                             manager, 0);
 
   g_signal_connect_object (settings,
                            "privacy-screen-changed",
@@ -1930,6 +2120,33 @@
 }
 
 static void
+restore_previous_experimental_config (MetaMonitorManager *manager,
+                                      MetaMonitorsConfig *previous_config)
+{
+  MetaBackend *backend = manager->backend;
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  gboolean was_fractional;
+
+  if (!META_IS_MONITOR_MANAGER_XRANDR (manager))
+    return;
+
+  was_fractional =
+    previous_config->layout_mode != META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+
+  if (meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING) == was_fractional)
+    return;
+
+  g_signal_handler_block (settings,
+                          manager->experimental_features_changed_handler_id);
+
+  meta_settings_enable_x11_fractional_scaling (settings, was_fractional);
+
+  g_signal_handler_unblock (settings,
+                            manager->experimental_features_changed_handler_id);
+}
+
+static void
 restore_previous_config (MetaMonitorManager *manager)
 {
   MetaMonitorsConfig *previous_config;
@@ -1954,6 +2171,8 @@
             g_set_object (&previous_config, oriented_config);
         }
 
+      restore_previous_experimental_config (manager, previous_config);
+
       method = META_MONITORS_CONFIG_METHOD_TEMPORARY;
       if (meta_monitor_manager_apply_monitors_config (manager,
                                                       previous_config,
@@ -2007,6 +2226,41 @@
   g_signal_emit (manager, signals[CONFIRM_DISPLAY_CHANGE], 0);
 }
 
+gboolean
+meta_monitor_manager_disable_scale_for_monitor (MetaMonitorManager *manager,
+                                                MetaLogicalMonitor *monitor)
+{
+  switch (manager->layout_mode)
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
+      break;
+    default:
+      return FALSE;
+    }
+
+  if (monitor && fmodf (monitor->scale, 1.0) != 0.0f)
+    {
+      if (manager->scale_override_monitors)
+        {
+          g_clear_pointer (&manager->scale_override_monitors, g_list_free);
+          g_object_unref (meta_monitor_config_manager_pop_previous (manager->config_manager));
+        }
+
+      manager->scale_override_monitors = g_list_copy (monitor->monitors);
+      meta_monitor_manager_ensure_configured (manager);
+      return TRUE;
+    }
+
+  if (manager->scale_override_monitors)
+    {
+      g_clear_pointer (&manager->scale_override_monitors, g_list_free);
+      restore_previous_config (manager);
+    }
+
+  return FALSE;
+}
+
 #define META_DISPLAY_CONFIG_MODE_FLAGS_PREFERRED (1 << 0)
 #define META_DISPLAY_CONFIG_MODE_FLAGS_CURRENT (1 << 1)
 
@@ -2034,6 +2288,7 @@
   MetaMonitorManagerCapability capabilities;
   int ui_scaling_factor;
   int max_screen_width, max_screen_height;
+  char *renderer;
 
   g_variant_builder_init (&monitors_builder,
                           G_VARIANT_TYPE (MONITORS_FORMAT));
@@ -2136,6 +2391,15 @@
                                  g_variant_new_boolean (is_underscanning));
         }
 
+      if (meta_monitor_is_vrr_capable (monitor))
+        {
+          gboolean vrr_disallowed = meta_monitor_is_vrr_disallowed (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-vrr-allowed",
+                                 g_variant_new_boolean (!vrr_disallowed));
+        }
+
       is_builtin = meta_monitor_is_laptop_panel (monitor);
       g_variant_builder_add (&monitor_properties_builder, "{sv}",
                              "is-builtin",
@@ -2202,6 +2466,14 @@
     }
 
   g_variant_builder_init (&properties_builder, G_VARIANT_TYPE ("a{sv}"));
+
+  renderer = g_ascii_strdown (G_OBJECT_TYPE_NAME (manager) +
+                              strlen (g_type_name (g_type_parent (G_OBJECT_TYPE (manager)))),
+                              -1);
+  g_variant_builder_add (&properties_builder, "{sv}",
+                         "renderer",
+                         g_variant_new_take_string (renderer));
+
   capabilities = meta_monitor_manager_get_capabilities (manager);
 
   g_variant_builder_add (&properties_builder, "{sv}",
@@ -2220,6 +2492,14 @@
                              "global-scale-required",
                              g_variant_new_boolean (TRUE));
     }
+  else if (META_IS_MONITOR_MANAGER_XRANDR (manager) &&
+           (capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING) &&
+           (capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      g_variant_builder_add (&properties_builder, "{sv}",
+                             "x11-fractional-scaling",
+                             g_variant_new_boolean (TRUE));
+    }
 
   ui_scaling_factor = meta_settings_get_ui_scaling_factor (settings);
   g_variant_builder_add (&properties_builder, "{sv}",
@@ -2264,12 +2544,14 @@
 #undef LOGICAL_MONITOR_FORMAT
 #undef LOGICAL_MONITORS_FORMAT
 
-gboolean
-meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
-                                         MetaLogicalMonitorLayoutMode layout_mode,
-                                         MetaMonitor                 *monitor,
-                                         MetaMonitorMode             *monitor_mode,
-                                         float                        scale)
+static gboolean
+meta_monitor_manager_is_scale_supported_with_threshold (MetaMonitorManager           *manager,
+                                                        MetaLogicalMonitorLayoutMode  layout_mode,
+                                                        MetaMonitor                  *monitor,
+                                                        MetaMonitorMode              *monitor_mode,
+                                                        float                         scale,
+                                                        float                         threshold,
+                                                        float                        *out_scale)
 {
   g_autofree float *supported_scales = NULL;
   int n_supported_scales;
@@ -2283,13 +2565,34 @@
                                                      &n_supported_scales);
   for (i = 0; i < n_supported_scales; i++)
     {
-      if (supported_scales[i] == scale)
-        return TRUE;
+      if (fabs (supported_scales[i] - scale) < threshold)
+        {
+          if (out_scale)
+            *out_scale = supported_scales[i];
+
+          return TRUE;
+        }
     }
 
   return FALSE;
 }
 
+gboolean
+meta_monitor_manager_is_scale_supported (MetaMonitorManager          *manager,
+                                         MetaLogicalMonitorLayoutMode layout_mode,
+                                         MetaMonitor                 *monitor,
+                                         MetaMonitorMode             *monitor_mode,
+                                         float                        scale)
+{
+  return meta_monitor_manager_is_scale_supported_with_threshold (manager,
+                                                                 layout_mode,
+                                                                 monitor,
+                                                                 monitor_mode,
+                                                                 scale,
+                                                                 FLT_EPSILON,
+                                                                 NULL);
+}
+
 static gboolean
 is_global_scale_matching_in_config (MetaMonitorsConfig *config,
                                     float               scale)
@@ -2455,6 +2758,8 @@
   g_autoptr (GVariant) properties_variant = NULL;
   gboolean enable_underscanning = FALSE;
   gboolean set_underscanning = FALSE;
+  gboolean allow_vrr = TRUE;
+  gboolean set_allow_vrr = FALSE;
 
   g_variant_get (monitor_config_variant, "(ss@a{sv})",
                  &connector,
@@ -2490,6 +2795,19 @@
         }
     }
 
+  set_allow_vrr =
+    g_variant_lookup (properties_variant, "allow_vrr", "b",
+                      &allow_vrr);
+  if (set_allow_vrr)
+    {
+      if (allow_vrr && !meta_monitor_is_vrr_capable (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Variable refresh rate requested but unsupported");
+          return NULL;
+        }
+    }
+
   monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
 
   monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
@@ -2499,7 +2817,8 @@
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = monitor_mode_spec,
-    .enable_underscanning = enable_underscanning
+    .enable_underscanning = enable_underscanning,
+    .disallow_vrr = !allow_vrr,
   };
 
   return monitor_config;
@@ -2590,6 +2909,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       width = roundf (width / scale);
       height = roundf (height / scale);
       break;
@@ -2689,9 +3009,11 @@
     .monitor_configs = monitor_configs
   };
 
-  if (!meta_verify_logical_monitor_config (logical_monitor_config,
+  if (layout_mode != META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL &&
+      !meta_verify_logical_monitor_config (logical_monitor_config,
                                            layout_mode,
                                            manager,
+                                           1.0f,
                                            error))
     {
       meta_logical_monitor_config_free (logical_monitor_config);
@@ -2712,6 +3034,7 @@
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       return TRUE;
     }
 
@@ -2736,6 +3059,7 @@
   MetaMonitorsConfig *config;
   GList *logical_monitor_configs = NULL;
   GError *error = NULL;
+  float max_scale = 1.0f;
 
   if (serial != manager->serial)
     {
@@ -2819,10 +3143,42 @@
           return TRUE;
         }
 
+      max_scale = MAX (max_scale, logical_monitor_config->scale);
       logical_monitor_configs = g_list_append (logical_monitor_configs,
                                                logical_monitor_config);
     }
 
+  if (manager->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      GList *l;
+      int ui_scale = ceilf (max_scale);
+
+      for (l = logical_monitor_configs; l; l = l->next)
+        {
+          MetaLogicalMonitorConfig *logical_monitor_config = l->data;
+
+          logical_monitor_config->layout.width =
+            roundf (logical_monitor_config->layout.width * ui_scale);
+          logical_monitor_config->layout.height =
+            roundf (logical_monitor_config->layout.height * ui_scale);
+
+          if (!meta_verify_logical_monitor_config (logical_monitor_config,
+                                                   manager->layout_mode,
+                                                   manager,
+                                                   ui_scale,
+                                                   &error))
+            {
+              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                                    G_DBUS_ERROR_INVALID_ARGS,
+                                                    "%s", error->message);
+              g_error_free (error);
+              g_list_free_full (logical_monitor_configs,
+                                (GDestroyNotify) meta_logical_monitor_config_free);
+              return TRUE;
+            }
+        }
+    }
+
   config = meta_monitors_config_new (manager,
                                      logical_monitor_configs,
                                      layout_mode,
@@ -3529,6 +3885,10 @@
 {
   GList *gpus;
   GList *l;
+  gboolean has_tiling;
+
+  has_tiling = meta_monitor_manager_get_capabilities (manager) &
+                META_MONITOR_MANAGER_CAPABILITY_TILING;
 
   if (manager->monitors)
     {
@@ -3547,7 +3907,7 @@
           MetaOutput *output = k->data;
           const MetaOutputInfo *output_info = meta_output_get_info (output);
 
-          if (output_info->tile_info.group_id)
+          if (has_tiling && output_info->tile_info.group_id)
             {
               if (is_main_tiled_monitor_output (output))
                 {
@@ -3773,7 +4133,7 @@
   else
     manager->current_switch_config = META_MONITOR_SWITCH_CONFIG_UNKNOWN;
 
-  manager->layout_mode = META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
+  manager->layout_mode = meta_monitor_manager_get_default_layout_mode (manager);
 
   meta_monitor_manager_rebuild_logical_monitors_derived (manager, config);
 }
@@ -3782,10 +4142,14 @@
 meta_monitor_manager_rebuild_derived (MetaMonitorManager *manager,
                                       MetaMonitorsConfig *config)
 {
+  MetaMonitorManagerClass *klass = META_MONITOR_MANAGER_GET_CLASS (manager);
   GList *old_logical_monitors;
 
   meta_monitor_manager_update_monitor_modes_derived (manager);
 
+  if (klass->update_screen_size_derived)
+    klass->update_screen_size_derived (manager, config);
+
   if (manager->in_init)
     return;
 
diff '--color=auto' -ruN a/src/backends/meta-monitor-manager-dummy.c b/src/backends/meta-monitor-manager-dummy.c
--- a/src/backends/meta-monitor-manager-dummy.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager-dummy.c	2023-10-03 20:26:00.102461495 +0300
@@ -372,6 +372,15 @@
     }
 }
 
+static gboolean
+has_tiled_monitors (void)
+{
+  const char *tiled_monitors_str;
+
+  tiled_monitors_str = g_getenv ("MUTTER_DEBUG_TILED_DUMMY_MONITORS");
+  return g_strcmp0 (tiled_monitors_str, "1") == 0;
+}
+
 static void
 meta_monitor_manager_dummy_read_current (MetaMonitorManager *manager)
 {
@@ -380,7 +389,6 @@
   float *monitor_scales = NULL;
   const char *num_monitors_str;
   const char *monitor_scales_str;
-  const char *tiled_monitors_str;
   gboolean tiled_monitors;
   unsigned int i;
   GList *outputs;
@@ -458,8 +466,7 @@
       g_strfreev (scales_str_list);
     }
 
-  tiled_monitors_str = g_getenv ("MUTTER_DEBUG_TILED_DUMMY_MONITORS");
-  tiled_monitors = g_strcmp0 (tiled_monitors_str, "1") == 0;
+  tiled_monitors = has_tiled_monitors ();
 
   modes = NULL;
   crtcs = NULL;
@@ -662,6 +669,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
@@ -692,6 +700,9 @@
   MetaMonitorManagerCapability capabilities =
     META_MONITOR_MANAGER_CAPABILITY_NONE;
 
+  if (has_tiled_monitors ())
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_TILING;
+
   if (meta_settings_is_experimental_feature_enabled (
         settings,
         META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER))
diff '--color=auto' -ruN a/src/backends/meta-monitor-manager-private.h b/src/backends/meta-monitor-manager-private.h
--- a/src/backends/meta-monitor-manager-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-monitor-manager-private.h	2023-10-03 20:26:00.169129039 +0300
@@ -47,7 +47,9 @@
 {
   META_MONITOR_MANAGER_CAPABILITY_NONE = 0,
   META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE = (1 << 0),
-  META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED = (1 << 1)
+  META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED = (1 << 1),
+  META_MONITOR_MANAGER_CAPABILITY_TILING = (1 << 2),
+  META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING = (1 << 3),
 } MetaMonitorManagerCapability;
 
 /* Equivalent to the 'method' enum in org.gnome.Mutter.DisplayConfig */
@@ -62,7 +64,8 @@
 typedef enum _MetaLogicalMonitorLayoutMode
 {
   META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL = 1,
-  META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL = 2
+  META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL = 2,
+  META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL = 3
 } MetaLogicalMonitorLayoutMode;
 
 /* The source the privacy screen change has been triggered */
@@ -85,6 +88,7 @@
   MetaCrtc *crtc;
   MetaCrtcMode *mode;
   graphene_rect_t layout;
+  float scale;
   MetaMonitorTransform transform;
   GPtrArray *outputs;
 };
@@ -101,6 +105,7 @@
   gboolean is_primary;
   gboolean is_presentation;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   gboolean has_max_bpc;
   unsigned int max_bpc;
 };
@@ -148,6 +153,7 @@
   int screen_height;
 
   GList *monitors;
+  GList *scale_override_monitors;
 
   GList *logical_monitors;
   MetaLogicalMonitor *primary_logical_monitor;
@@ -160,6 +166,8 @@
 
   MetaMonitorConfigManager *config_manager;
 
+  gulong experimental_features_changed_handler_id;
+
   MetaMonitorSwitchConfigType current_switch_config;
 
   MetaPrivacyScreenChangeState privacy_screen_change_state;
@@ -177,6 +185,9 @@
  * @apply_monitors_config: Tries to apply the given config using the given
  *   method. Throws an error if something went wrong.
  *
+ * @update_screen_size_derived: Computes the screen size for derived
+ *   configuration.
+ *
  * @set_power_save_mode: Sets the #MetaPowerSave mode (for all displays).
  *
  * @change_backlight: Changes the backlight intensity to the given value (in
@@ -223,6 +234,9 @@
                              MetaOutput         *output,
                              int                 backlight);
 
+  void (*update_screen_size_derived)  (MetaMonitorManager *,
+                                       MetaMonitorsConfig *);
+
   void (* tiled_monitor_added) (MetaMonitorManager *manager,
                                 MetaMonitor        *monitor);
 
@@ -383,6 +397,11 @@
                                                             MetaMonitorMode             *monitor_mode,
                                                             float                        scale);
 
+float              meta_monitor_manager_get_maximum_crtc_scale (MetaMonitorManager *manager);
+
+gboolean           meta_monitor_manager_disable_scale_for_monitor (MetaMonitorManager *manager,
+                                                                   MetaLogicalMonitor *monitor);
+
 MetaMonitorManagerCapability
                    meta_monitor_manager_get_capabilities (MetaMonitorManager *manager);
 
diff '--color=auto' -ruN a/src/backends/meta-output.c b/src/backends/meta-output.c
--- a/src/backends/meta-output.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-output.c	2023-10-03 20:26:00.169129039 +0300
@@ -64,6 +64,8 @@
 
   gboolean is_underscanning;
 
+  gboolean is_vrr_disallowed;
+
   gboolean has_max_bpc;
   unsigned int max_bpc;
 
@@ -198,6 +200,22 @@
 }
 
 gboolean
+meta_output_is_vrr_capable (MetaOutput *output)
+{
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_output_is_vrr_disallowed (MetaOutput *output)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  return priv->is_vrr_disallowed;
+}
+
+gboolean
 meta_output_get_max_bpc (MetaOutput   *output,
                          unsigned int *max_bpc)
 {
@@ -268,6 +286,8 @@
   priv->is_presentation = output_assignment->is_presentation;
   priv->is_underscanning = output_assignment->is_underscanning;
 
+  priv->is_vrr_disallowed = output_assignment->is_vrr_disallowed;
+
   priv->has_max_bpc = output_assignment->has_max_bpc;
   if (priv->has_max_bpc)
     priv->max_bpc = output_assignment->max_bpc;
diff '--color=auto' -ruN a/src/backends/meta-output.h b/src/backends/meta-output.h
--- a/src/backends/meta-output.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-output.h	2023-10-03 20:26:00.169129039 +0300
@@ -144,6 +144,8 @@
   gboolean supports_underscanning;
   gboolean supports_color_transform;
 
+  gboolean vrr_capable;
+
   unsigned int max_bpc_min;
   unsigned int max_bpc_max;
 
@@ -228,6 +230,11 @@
 META_EXPORT_TEST
 gboolean meta_output_is_underscanning (MetaOutput *output);
 
+gboolean meta_output_is_vrr_capable (MetaOutput *output);
+
+META_EXPORT_TEST
+gboolean meta_output_is_vrr_disallowed (MetaOutput *output);
+
 META_EXPORT_TEST
 gboolean meta_output_get_max_bpc (MetaOutput   *output,
                                   unsigned int *max_bpc);
diff '--color=auto' -ruN a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
--- a/src/backends/meta-renderer-view.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-renderer-view.c	2023-10-03 20:26:00.169129039 +0300
@@ -33,6 +33,7 @@
 #include "backends/meta-renderer-view.h"
 
 #include "backends/meta-crtc.h"
+#include "backends/meta-output.h"
 #include "backends/meta-renderer.h"
 #include "clutter/clutter-mutter.h"
 #include "compositor/region-utils.h"
@@ -43,6 +44,7 @@
 
   PROP_TRANSFORM,
   PROP_CRTC,
+  PROP_OUTPUT,
 
   PROP_LAST
 };
@@ -54,6 +56,7 @@
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
+  MetaOutput *output;
 } MetaRendererViewPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (MetaRendererView, meta_renderer_view,
@@ -77,6 +80,15 @@
   return priv->crtc;
 }
 
+MetaOutput *
+meta_renderer_view_get_output (MetaRendererView *view)
+{
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->output;
+}
+
 static void
 meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
@@ -151,6 +163,9 @@
     case PROP_CRTC:
       g_value_set_object (value, priv->crtc);
       break;
+    case PROP_OUTPUT:
+      g_value_set_object (value, priv->output);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -175,6 +190,9 @@
     case PROP_CRTC:
       priv->crtc = g_value_get_object (value);
       break;
+    case PROP_OUTPUT:
+      priv->output = g_value_get_object (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -217,6 +235,15 @@
                          G_PARAM_READWRITE |
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_OUTPUT] =
+    g_param_spec_object ("output",
+                         "MetaOutput",
+                         "MetaOutput",
+                         META_TYPE_OUTPUT,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
 
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff '--color=auto' -ruN a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
--- a/src/backends/meta-renderer-view.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-renderer-view.h	2023-10-03 20:26:00.172462417 +0300
@@ -36,3 +36,5 @@
 
 META_EXPORT_TEST
 MetaCrtc *meta_renderer_view_get_crtc (MetaRendererView *view);
+
+MetaOutput *meta_renderer_view_get_output (MetaRendererView *view);
diff '--color=auto' -ruN a/src/backends/meta-settings.c b/src/backends/meta-settings.c
--- a/src/backends/meta-settings.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-settings.c	2023-10-03 20:30:07.319072174 +0300
@@ -37,6 +37,7 @@
   UI_SCALING_FACTOR_CHANGED,
   GLOBAL_SCALING_FACTOR_CHANGED,
   FONT_DPI_CHANGED,
+  X11_SCALE_MODE_CHANGED,
   EXPERIMENTAL_FEATURES_CHANGED,
   PRIVACY_SCREEN_CHANGED,
 
@@ -55,6 +56,7 @@
   GSettings *mutter_settings;
   GSettings *privacy_settings;
   GSettings *wayland_settings;
+  GSettings *x11_settings;
 
   int ui_scaling_factor;
   int global_scaling_factor;
@@ -75,6 +77,8 @@
 
   /* Whether Xwayland should allow X11 clients from different endianness */
   gboolean xwayland_allow_byte_swapped_clients;
+
+  MetaX11ScaleMode x11_scale_mode;
 };
 
 G_DEFINE_TYPE (MetaSettings, meta_settings, G_TYPE_OBJECT)
@@ -84,14 +88,39 @@
 {
   MetaMonitorManager *monitor_manager =
     meta_backend_get_monitor_manager (settings->backend);
-  MetaLogicalMonitor *primary_logical_monitor;
 
-  primary_logical_monitor =
-    meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
-  if (!primary_logical_monitor)
-    return 1;
+  if (!meta_is_wayland_compositor () &&
+      monitor_manager &&
+      (meta_monitor_manager_get_capabilities (monitor_manager) &
+       META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      MetaLogicalMonitorLayoutMode layout_mode =
+        meta_monitor_manager_get_default_layout_mode (monitor_manager);
+
+      if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+        {
+          return
+              ceilf (meta_monitor_manager_get_maximum_crtc_scale (monitor_manager));
+        }
+      else if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL)
+        {
+          return 1.0f;
+        }
+    }
+
+  if (monitor_manager)
+    {
+      MetaLogicalMonitor *primary_logical_monitor;
+
+      primary_logical_monitor =
+        meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
+      if (!primary_logical_monitor)
+        return 1;
+
+      return (int) meta_logical_monitor_get_scale (primary_logical_monitor);
+    }
 
-  return (int) meta_logical_monitor_get_scale (primary_logical_monitor);
+  return 1;
 }
 
 static gboolean
@@ -258,6 +287,76 @@
   settings->experimental_features_overridden = TRUE;
 }
 
+static gboolean
+update_x11_scale_mode (MetaSettings *settings)
+{
+  MetaX11ScaleMode scale_mode;
+
+  if (!(settings->experimental_features &
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    {
+      scale_mode = META_X11_SCALE_MODE_NONE;
+    }
+  else
+    {
+      scale_mode =
+        g_settings_get_enum (settings->x11_settings, "fractional-scale-mode");
+    }
+
+  if (settings->x11_scale_mode != scale_mode)
+    {
+      settings->x11_scale_mode = scale_mode;
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+void meta_settings_enable_x11_fractional_scaling (MetaSettings *settings,
+                                                  gboolean      enable)
+{
+  g_auto(GStrv) existing_features = NULL;
+  gboolean have_fractional_scaling = FALSE;
+  g_autoptr(GVariantBuilder) builder = NULL;
+  MetaExperimentalFeature old_experimental_features;
+
+  if (enable == meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    return;
+
+  /* Change the internal value now, as we don't want to wait for gsettings */
+  old_experimental_features = settings->experimental_features;
+  settings->experimental_features |=
+    META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING;
+
+  update_x11_scale_mode (settings);
+
+  g_signal_emit (settings, signals[EXPERIMENTAL_FEATURES_CHANGED], 0,
+                   (unsigned int) old_experimental_features);
+
+  /* Add or remove the fractional scaling feature from mutter */
+  existing_features = g_settings_get_strv (settings->mutter_settings,
+                                           "experimental-features");
+  builder = g_variant_builder_new (G_VARIANT_TYPE ("as"));
+  for (int i = 0; existing_features[i] != NULL; i++)
+    {
+      if (g_strcmp0 (existing_features[i], "x11-randr-fractional-scaling") == 0)
+        {
+          if (enable)
+            have_fractional_scaling = TRUE;
+          else
+            continue;
+        }
+
+      g_variant_builder_add (builder, "s", existing_features[i]);
+    }
+  if (enable && !have_fractional_scaling)
+    g_variant_builder_add (builder, "s", "x11-randr-fractional-scaling");
+
+  g_settings_set_value (settings->mutter_settings, "experimental-features",
+                        g_variant_builder_end (builder));
+}
+
 void
 meta_settings_enable_experimental_feature (MetaSettings           *settings,
                                            MetaExperimentalFeature feature)
@@ -265,6 +364,9 @@
   g_assert (settings->experimental_features_overridden);
 
   settings->experimental_features |= feature;
+
+  if (update_x11_scale_mode (settings))
+    g_signal_emit (settings, signals[X11_SCALE_MODE_CHANGED], 0, NULL);
 }
 
 static gboolean
@@ -296,6 +398,10 @@
         feature = META_EXPERIMENTAL_FEATURE_RT_SCHEDULER;
       else if (g_str_equal (feature_str, "autoclose-xwayland"))
         feature = META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND;
+      else if (g_str_equal (feature_str, "variable-refresh-rate"))
+        feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
+      else if (g_str_equal (feature_str, "x11-randr-fractional-scaling"))
+        feature = META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING;
 
       if (feature)
         g_message ("Enabling experimental feature '%s'", feature_str);
@@ -308,6 +414,7 @@
   if (features != settings->experimental_features)
     {
       settings->experimental_features = features;
+      update_x11_scale_mode (settings);
       *result = GINT_TO_POINTER (TRUE);
     }
   else
@@ -462,6 +569,18 @@
     }
 }
 
+static void
+x11_settings_changed (GSettings    *wayland_settings,
+                      gchar        *key,
+                      MetaSettings *settings)
+{
+  if (g_str_equal (key, "fractional-scale-mode"))
+    {
+      if (update_x11_scale_mode (settings))
+        g_signal_emit (settings, signals[X11_SCALE_MODE_CHANGED], 0, NULL);
+    }
+}
+
 void
 meta_settings_get_xwayland_grab_patterns (MetaSettings  *settings,
                                           GPtrArray    **allow_list_patterns,
@@ -507,6 +626,12 @@
                           enabled);
 }
 
+MetaX11ScaleMode
+meta_settings_get_x11_scale_mode (MetaSettings *settings)
+{
+  return settings->x11_scale_mode;
+}
+
 MetaSettings *
 meta_settings_new (MetaBackend *backend)
 {
@@ -527,6 +652,7 @@
   g_clear_object (&settings->interface_settings);
   g_clear_object (&settings->privacy_settings);
   g_clear_object (&settings->wayland_settings);
+  g_clear_object (&settings->x11_settings);
   g_clear_pointer (&settings->xwayland_grab_allow_list_patterns,
                    g_ptr_array_unref);
   g_clear_pointer (&settings->xwayland_grab_deny_list_patterns,
@@ -554,6 +680,10 @@
   g_signal_connect (settings->wayland_settings, "changed",
                     G_CALLBACK (wayland_settings_changed),
                     settings);
+  settings->x11_settings = g_settings_new ("org.gnome.mutter.x11");
+  g_signal_connect (settings->x11_settings, "changed",
+                    G_CALLBACK (x11_settings_changed),
+                    settings);
 
   /* Chain up inter-dependent settings. */
   g_signal_connect (settings, "global-scaling-factor-changed",
@@ -619,6 +749,14 @@
                   G_TYPE_FROM_CLASS (object_class),
                   G_SIGNAL_RUN_LAST,
                   0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
+  signals[X11_SCALE_MODE_CHANGED] =
+    g_signal_new ("x11-scale-mode-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
                   NULL, NULL, NULL,
                   G_TYPE_NONE, 0);
 
diff '--color=auto' -ruN a/src/backends/meta-settings-private.h b/src/backends/meta-settings-private.h
--- a/src/backends/meta-settings-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/meta-settings-private.h	2023-10-03 20:31:32.793545570 +0300
@@ -29,9 +29,11 @@
 {
   META_EXPERIMENTAL_FEATURE_NONE = 0,
   META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER = (1 << 0),
-  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS  = (1 << 1),
+  META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS = (1 << 1),
   META_EXPERIMENTAL_FEATURE_RT_SCHEDULER = (1 << 2),
-  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 4),
+  META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING  = (1 << 4),
 } MetaExperimentalFeature;
 
 typedef enum _MetaXwaylandExtension
@@ -40,6 +42,13 @@
   META_XWAYLAND_EXTENSION_XTEST = (1 << 1),
 } MetaXwaylandExtension;
 
+typedef enum _MetaX11ScaleMode
+{
+  META_X11_SCALE_MODE_NONE = 0,
+  META_X11_SCALE_MODE_UP = 1,
+  META_X11_SCALE_MODE_UI_DOWN = 2,
+} MetaX11ScaleMode;
+
 #define META_TYPE_SETTINGS (meta_settings_get_type ())
 G_DECLARE_FINAL_TYPE (MetaSettings, meta_settings,
                       META, SETTINGS, GObject)
@@ -80,3 +89,8 @@
 
 void meta_settings_set_privacy_screen_enabled (MetaSettings *settings,
                                                gboolean      enabled);
+
+MetaX11ScaleMode meta_settings_get_x11_scale_mode (MetaSettings *settings);
+
+void meta_settings_enable_x11_fractional_scaling (MetaSettings *settings,
+                                                  gboolean      enabled);
diff '--color=auto' -ruN a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
--- a/src/backends/native/meta-backend-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-backend-native.c	2023-10-03 20:26:00.169129039 +0300
@@ -592,6 +592,9 @@
   if (meta_is_udev_device_disable_modifiers (device))
     flags |= META_KMS_DEVICE_FLAG_DISABLE_MODIFIERS;
 
+  if (meta_is_udev_device_disable_vrr (device))
+    flags |= META_KMS_DEVICE_FLAG_DISABLE_VRR;
+
   if (meta_is_udev_device_preferred_primary (device))
     flags |= META_KMS_DEVICE_FLAG_PREFERRED_PRIMARY;
 
diff '--color=auto' -ruN a/src/backends/native/meta-gpu-kms.c b/src/backends/native/meta-gpu-kms.c
--- a/src/backends/native/meta-gpu-kms.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-gpu-kms.c	2023-10-03 20:26:00.169129039 +0300
@@ -132,6 +132,23 @@
   return !!(flags & META_KMS_DEVICE_FLAG_PLATFORM_DEVICE);
 }
 
+gboolean
+meta_gpu_kms_disable_vrr (MetaGpuKms *gpu_kms)
+{
+  MetaGpu *gpu = META_GPU (gpu_kms);
+  MetaBackend *backend = meta_gpu_get_backend (gpu);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaKmsDeviceFlag flags;
+
+  if (!meta_settings_is_experimental_feature_enabled (
+        settings,
+        META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE))
+    return TRUE;
+
+  flags = meta_kms_device_get_flags (gpu_kms->kms_device);
+  return !!(flags & META_KMS_DEVICE_FLAG_DISABLE_VRR);
+}
+
 static int
 compare_outputs (gconstpointer one,
                  gconstpointer two)
diff '--color=auto' -ruN a/src/backends/native/meta-gpu-kms.h b/src/backends/native/meta-gpu-kms.h
--- a/src/backends/native/meta-gpu-kms.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-gpu-kms.h	2023-10-03 20:26:00.169129039 +0300
@@ -44,6 +44,7 @@
 
 gboolean meta_gpu_kms_is_boot_vga (MetaGpuKms *gpu_kms);
 gboolean meta_gpu_kms_is_platform_device (MetaGpuKms *gpu_kms);
+gboolean meta_gpu_kms_disable_vrr (MetaGpuKms *gpu_kms);
 
 MetaKmsDevice * meta_gpu_kms_get_kms_device (MetaGpuKms *gpu_kms);
 
diff '--color=auto' -ruN a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
--- a/src/backends/native/meta-kms-connector.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector.c	2023-10-03 20:26:00.169129039 +0300
@@ -408,6 +408,10 @@
       state->colorspace.supported =
         supported_drm_color_spaces_to_output_color_spaces (prop->supported_variants);
     }
+
+  prop = &props[META_KMS_CONNECTOR_PROP_VRR_CAPABLE];
+  if (prop->prop_id)
+    state->vrr_capable = prop->value;
 }
 
 static CoglSubpixelOrder
@@ -840,6 +844,7 @@
   state = g_new0 (MetaKmsConnectorState, 1);
   state->suggested_x = -1;
   state->suggested_y = -1;
+  state->vrr_capable = FALSE;
 
   return state;
 }
@@ -1013,6 +1018,9 @@
       !hdr_metadata_equal (&state->hdr.value, &new_state->hdr.value))
     return META_KMS_RESOURCE_CHANGE_FULL;
 
+  if (state->vrr_capable != new_state->vrr_capable)
+    return META_KMS_RESOURCE_CHANGE_FULL;
+
   if (state->privacy_screen_state != new_state->privacy_screen_state)
     return META_KMS_RESOURCE_CHANGE_PRIVACY_SCREEN;
 
@@ -1357,6 +1365,11 @@
           .name = "HDR_OUTPUT_METADATA",
           .type = DRM_MODE_PROP_BLOB,
         },
+      [META_KMS_CONNECTOR_PROP_VRR_CAPABLE] =
+        {
+          .name = "vrr_capable",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     },
     .dpms_enum = {
       [META_KMS_CONNECTOR_DPMS_ON] =
diff '--color=auto' -ruN a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
--- a/src/backends/native/meta-kms-connector.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector.h	2023-10-03 20:26:00.169129039 +0300
@@ -69,6 +69,8 @@
     gboolean supported;
     gboolean unknown;
   } hdr;
+
+  gboolean vrr_capable;
 } MetaKmsConnectorState;
 
 META_EXPORT_TEST
diff '--color=auto' -ruN a/src/backends/native/meta-kms-connector-private.h b/src/backends/native/meta-kms-connector-private.h
--- a/src/backends/native/meta-kms-connector-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-connector-private.h	2023-10-03 20:26:00.169129039 +0300
@@ -39,6 +39,7 @@
   META_KMS_CONNECTOR_PROP_MAX_BPC,
   META_KMS_CONNECTOR_PROP_COLORSPACE,
   META_KMS_CONNECTOR_PROP_HDR_OUTPUT_METADATA,
+  META_KMS_CONNECTOR_PROP_VRR_CAPABLE,
   META_KMS_CONNECTOR_N_PROPS
 } MetaKmsConnectorProp;
 
diff '--color=auto' -ruN a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
--- a/src/backends/native/meta-kms-crtc.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-crtc.c	2023-10-03 20:26:00.169129039 +0300
@@ -427,6 +427,11 @@
           .name = "GAMMA_LUT_SIZE",
           .type = DRM_MODE_PROP_RANGE,
         },
+      [META_KMS_CRTC_PROP_VRR_ENABLED] =
+        {
+          .name = "VRR_ENABLED",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     }
   };
 }
diff '--color=auto' -ruN a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
--- a/src/backends/native/meta-kms-crtc-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-crtc-private.h	2023-10-03 20:26:00.169129039 +0300
@@ -28,9 +28,17 @@
   META_KMS_CRTC_PROP_ACTIVE,
   META_KMS_CRTC_PROP_GAMMA_LUT,
   META_KMS_CRTC_PROP_GAMMA_LUT_SIZE,
+  META_KMS_CRTC_PROP_VRR_ENABLED,
   META_KMS_CRTC_N_PROPS
 } MetaKmsCrtcProp;
 
+typedef enum _MetaKmsCrtcVRRMode
+{
+  META_KMS_CRTC_VRR_MODE_DISABLED = 0,
+  META_KMS_CRTC_VRR_MODE_ENABLED,
+  META_KMS_CRTC_VRR_MODE_N_PROPS,
+} MetaKmsCrtcVRRMode;
+
 MetaKmsCrtc * meta_kms_crtc_new (MetaKmsImplDevice  *impl_device,
                                  drmModeCrtc        *drm_crtc,
                                  int                 idx,
diff '--color=auto' -ruN a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
--- a/src/backends/native/meta-kms-impl-device-atomic.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-impl-device-atomic.c	2023-10-03 20:26:00.169129039 +0300
@@ -334,6 +334,39 @@
 }
 
 static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     drmModeAtomicReq   *req,
+                     GArray             *blob_ids,
+                     gpointer            update_entry,
+                     gpointer            user_data,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Setting VRR mode to %d on CRTC %u (%s)",
+                  crtc_update->vrr_mode.is_enabled ?
+                    META_KMS_CRTC_VRR_MODE_ENABLED :
+                    META_KMS_CRTC_VRR_MODE_DISABLED,
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              crtc_update->vrr_mode.is_enabled,
+                              error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
 process_mode_set (MetaKmsImplDevice  *impl_device,
                   MetaKmsUpdate      *update,
                   drmModeAtomicReq   *req,
@@ -986,6 +1019,16 @@
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        req,
+                        blob_ids,
+                        meta_kms_update_get_crtc_updates (update),
+                        NULL,
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         req,
diff '--color=auto' -ruN a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
--- a/src/backends/native/meta-kms-impl-device-simple.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-impl-device-simple.c	2023-10-03 20:26:00.169129039 +0300
@@ -180,6 +180,47 @@
 }
 
 static gboolean
+set_crtc_property (MetaKmsImplDevice  *impl_device,
+                   MetaKmsCrtc        *crtc,
+                   MetaKmsCrtcProp     prop,
+                   uint64_t            value,
+                   GError            **error)
+{
+  uint32_t prop_id;
+  int fd;
+  int ret;
+
+  prop_id = meta_kms_crtc_get_prop_id (crtc, prop);
+  if (!prop_id)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Property (%s) not found on CRTC %u",
+                   meta_kms_crtc_get_prop_name (crtc, prop),
+                   meta_kms_crtc_get_id (crtc));
+      return FALSE;
+    }
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+
+  ret = drmModeObjectSetProperty (fd,
+                                  meta_kms_crtc_get_id (crtc),
+                                  DRM_MODE_OBJECT_CRTC,
+                                  prop_id,
+                                  value);
+  if (ret != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-ret),
+                   "Failed to set CRTC %u property %u: %s",
+                   meta_kms_crtc_get_id (crtc),
+                   prop_id,
+                   g_strerror (-ret));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
 process_connector_update (MetaKmsImplDevice  *impl_device,
                           MetaKmsUpdate      *update,
                           gpointer            update_entry,
@@ -268,6 +309,36 @@
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     gpointer            update_entry,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Setting VRR mode to %d on CRTC %u (%s)",
+                  crtc_update->vrr_mode.is_enabled ?
+                    META_KMS_CRTC_VRR_MODE_ENABLED :
+                    META_KMS_CRTC_VRR_MODE_DISABLED,
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              crtc_update->vrr_mode.is_enabled,
+                              error))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
 static CachedModeSet *
 cached_mode_set_new (GList                 *connectors,
                      const drmModeModeInfo *drm_mode,
@@ -1522,6 +1593,13 @@
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        meta_kms_update_get_crtc_updates (update),
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_plane_assignments (impl_device, update, &failed_planes, &error))
     goto err;
 
diff '--color=auto' -ruN a/src/backends/native/meta-kms-types.h b/src/backends/native/meta-kms-types.h
--- a/src/backends/native/meta-kms-types.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-types.h	2023-10-03 20:26:00.169129039 +0300
@@ -64,6 +64,7 @@
   META_KMS_DEVICE_FLAG_HAS_ADDFB2 = 1 << 5,
   META_KMS_DEVICE_FLAG_FORCE_LEGACY = 1 << 6,
   META_KMS_DEVICE_FLAG_DISABLE_CLIENT_MODIFIERS = 1 << 7,
+  META_KMS_DEVICE_FLAG_DISABLE_VRR = 1 << 8,
 } MetaKmsDeviceFlag;
 
 typedef enum _MetaKmsResourceChanges
diff '--color=auto' -ruN a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
--- a/src/backends/native/meta-kms-update.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update.c	2023-10-03 20:26:00.169129039 +0300
@@ -40,6 +40,7 @@
   GList *mode_sets;
   GList *plane_assignments;
   GList *connector_updates;
+  GList *crtc_updates;
   GList *crtc_color_updates;
 
   MetaKmsCustomPageFlip *custom_page_flip;
@@ -521,6 +522,46 @@
   g_free (color_update);
 }
 
+static MetaKmsCrtcUpdate *
+ensure_crtc_update (MetaKmsUpdate *update,
+                    MetaKmsCrtc   *crtc)
+{
+  GList *l;
+  MetaKmsCrtcUpdate *crtc_update;
+
+  for (l = update->crtc_updates; l; l = l->next)
+    {
+      crtc_update = l->data;
+
+      if (crtc_update->crtc == crtc)
+        return crtc_update;
+    }
+
+  crtc_update = g_new0 (MetaKmsCrtcUpdate, 1);
+  crtc_update->crtc = crtc;
+
+  update->crtc_updates = g_list_prepend (update->crtc_updates,
+                                         crtc_update);
+
+  return crtc_update;
+}
+
+void
+meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                              MetaKmsCrtc   *crtc,
+                              gboolean       enabled)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+
+  g_assert (meta_kms_crtc_get_device (crtc) == update->device);
+
+  crtc_update = ensure_crtc_update (update, crtc);
+  crtc_update->vrr_mode.has_update = TRUE;
+  crtc_update->vrr_mode.is_enabled = enabled;
+
+  update_latch_crtc (update, crtc);
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
@@ -735,6 +776,12 @@
 }
 
 GList *
+meta_kms_update_get_crtc_updates (MetaKmsUpdate *update)
+{
+  return update->crtc_updates;
+}
+
+GList *
 meta_kms_update_get_crtc_color_updates (MetaKmsUpdate *update)
 {
   return update->crtc_color_updates;
@@ -1062,6 +1109,7 @@
   g_list_free_full (update->page_flip_listeners,
                     (GDestroyNotify) meta_kms_page_flip_listener_unref);
   g_list_free_full (update->connector_updates, g_free);
+  g_list_free_full (update->crtc_updates, g_free);
   g_list_free_full (update->crtc_color_updates,
                     (GDestroyNotify) meta_kms_crtc_color_updates_free);
   g_clear_pointer (&update->custom_page_flip, meta_kms_custom_page_flip_free);
diff '--color=auto' -ruN a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
--- a/src/backends/native/meta-kms-update.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update.h	2023-10-03 20:26:00.169129039 +0300
@@ -152,6 +152,10 @@
                                      MetaKmsCrtc        *crtc,
                                      const MetaGammaLut *gamma);
 
+void meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                                   MetaKmsCrtc   *crtc,
+                                   gboolean       enabled);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const int              *rectangles,
                                               int                     n_rectangles);
diff '--color=auto' -ruN a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
--- a/src/backends/native/meta-kms-update-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-kms-update-private.h	2023-10-03 20:26:00.169129039 +0300
@@ -111,6 +111,16 @@
   } hdr;
 } MetaKmsConnectorUpdate;
 
+typedef struct _MetaKmsCrtcUpdate
+{
+  MetaKmsCrtc *crtc;
+
+  struct {
+    gboolean has_update;
+    gboolean is_enabled;
+  } vrr_mode;
+} MetaKmsCrtcUpdate;
+
 typedef struct _MetaKmsPageFlipListener
 {
   gatomicrefcount ref_count;
@@ -178,6 +188,9 @@
 GList * meta_kms_update_get_connector_updates (MetaKmsUpdate *update);
 
 META_EXPORT_TEST
+GList * meta_kms_update_get_crtc_updates (MetaKmsUpdate *update);
+
+META_EXPORT_TEST
 GList * meta_kms_update_get_crtc_color_updates (MetaKmsUpdate *update);
 
 MetaKmsCustomPageFlip * meta_kms_update_take_custom_page_flip_func (MetaKmsUpdate *update);
diff '--color=auto' -ruN a/src/backends/native/meta-monitor-manager-native.c b/src/backends/native/meta-monitor-manager-native.c
--- a/src/backends/native/meta-monitor-manager-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-monitor-manager-native.c	2023-10-03 20:26:00.102461495 +0300
@@ -451,6 +451,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
diff '--color=auto' -ruN a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
--- a/src/backends/native/meta-onscreen-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-onscreen-native.c	2023-10-03 20:26:00.165795662 +0300
@@ -618,6 +618,9 @@
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "FB Copy (secondary GPU)");
 
+  if (renderer_gpu_data->secondary.needs_explicit_sync)
+    cogl_framebuffer_finish (COGL_FRAMEBUFFER (onscreen));
+
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
 
@@ -2035,6 +2038,7 @@
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   MetaGpuKms *gpu_kms;
   uint32_t format;
+  const uint32_t flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING;
 
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
@@ -2046,10 +2050,29 @@
 
   render_device_gbm = META_RENDER_DEVICE_GBM (render_device);
   gbm_device = meta_render_device_gbm_get_gbm_device (render_device_gbm);
-  gbm_surface = gbm_surface_create (gbm_device,
-                                    width, height,
-                                    format,
-                                    GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
+
+  gbm_surface = gbm_surface_create_with_modifiers2 (gbm_device,
+                                                    width, height,
+                                                    format,
+                                                    NULL, 0,
+                                                    flags);
+
+  if (!gbm_surface)
+    {
+      gbm_surface = gbm_surface_create_with_modifiers (gbm_device,
+                                                       width, height,
+                                                       format,
+                                                       NULL, 0);
+    }
+
+  if (!gbm_surface)
+    {
+      gbm_surface = gbm_surface_create (gbm_device,
+                                        width, height,
+                                        format,
+                                        flags);
+    }
+
   if (!gbm_surface)
     {
       g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
diff '--color=auto' -ruN a/src/backends/native/meta-output-kms.c b/src/backends/native/meta-output-kms.c
--- a/src/backends/native/meta-output-kms.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-output-kms.c	2023-10-03 20:26:00.169129039 +0300
@@ -96,6 +96,26 @@
 }
 
 void
+meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                              MetaKmsUpdate *kms_update,
+                              gboolean       enabled)
+{
+  MetaOutput *output = META_OUTPUT (output_kms);
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+
+  g_assert (output_info->vrr_capable);
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+
+  meta_kms_update_set_vrr_mode (kms_update,
+                                kms_crtc,
+                                enabled);
+}
+
+void
 meta_output_kms_set_max_bpc (MetaOutputKms *output_kms,
                              MetaKmsUpdate *kms_update)
 {
@@ -488,6 +508,9 @@
   output_info->supports_underscanning =
     meta_kms_connector_is_underscanning_supported (kms_connector);
 
+  output_info->vrr_capable = (connector_state->vrr_capable &&
+                              !meta_gpu_kms_disable_vrr (gpu_kms));
+
   max_bpc_range = meta_kms_connector_get_max_bpc (kms_connector);
   if (max_bpc_range)
     {
diff '--color=auto' -ruN a/src/backends/native/meta-output-kms.h b/src/backends/native/meta-output-kms.h
--- a/src/backends/native/meta-output-kms.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-output-kms.h	2023-10-03 20:26:00.169129039 +0300
@@ -37,6 +37,10 @@
 void meta_output_kms_set_underscan (MetaOutputKms *output_kms,
                                     MetaKmsUpdate *kms_update);
 
+void meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                                   MetaKmsUpdate *kms_update,
+                                   gboolean       enabled);
+
 void meta_output_kms_set_max_bpc (MetaOutputKms *output_kms,
                                   MetaKmsUpdate *kms_update);
 
diff '--color=auto' -ruN a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
--- a/src/backends/native/meta-renderer-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native.c	2023-10-03 20:26:00.172462417 +0300
@@ -1441,6 +1441,7 @@
                               "stage", meta_backend_get_stage (backend),
                               "layout", &view_layout,
                               "crtc", crtc,
+                              "output", output,
                               "scale", scale,
                               "framebuffer", framebuffer,
                               "offscreen", offscreen,
@@ -1567,8 +1568,11 @@
   if (COGL_IS_ONSCREEN (framebuffer))
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+      MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (view);
 
       meta_onscreen_native_before_redraw (onscreen, frame);
+      meta_renderer_view_native_maybe_update_frame_sync_mode (view_native,
+                                                              frame);
     }
 }
 
@@ -1692,6 +1696,7 @@
   CoglContext *cogl_context;
   CoglDisplay *cogl_display;
   const char **missing_gl_extensions;
+  const char *egl_vendor;
 
   egl_display = meta_render_device_get_egl_display (render_device);
   if (egl_display == EGL_NO_DISPLAY)
@@ -1758,6 +1763,11 @@
     meta_egl_has_extensions (egl, egl_display, NULL,
                              "EGL_EXT_image_dma_buf_import_modifiers",
                              NULL);
+
+  egl_vendor = meta_egl_query_string (egl, egl_display, EGL_VENDOR);
+  if (!g_strcmp0 (egl_vendor, "NVIDIA"))
+    renderer_gpu_data->secondary.needs_explicit_sync = TRUE;
+
   ret = TRUE;
 out:
   maybe_restore_cogl_egl_api (renderer_native);
diff '--color=auto' -ruN a/src/backends/native/meta-renderer-native-gles3.c b/src/backends/native/meta-renderer-native-gles3.c
--- a/src/backends/native/meta-renderer-native-gles3.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native-gles3.c	2023-10-03 20:26:00.165795662 +0300
@@ -43,6 +43,120 @@
 #error "Somehow included OpenGL headers when we shouldn't have"
 #endif
 
+static GQuark shader_program_quark = 0;
+
+static GLuint
+load_shader (const char *src,
+             GLenum      type)
+{
+  GLuint shader = glCreateShader (type);
+
+  if (shader)
+    {
+      GLint compiled;
+
+      glShaderSource (shader, 1, &src, NULL);
+      glCompileShader (shader);
+      glGetShaderiv (shader, GL_COMPILE_STATUS, &compiled);
+      if (!compiled)
+        {
+          GLchar log[1024];
+
+          glGetShaderInfoLog (shader, sizeof (log) - 1, NULL, log);
+          log[sizeof (log) - 1] = '\0';
+          g_warning ("load_shader compile failed: %s", log);
+          glDeleteShader (shader);
+          shader = 0;
+        }
+    }
+
+  return shader;
+}
+
+static void
+ensure_shader_program (MetaGles3 *gles3)
+{
+  static const char vertex_shader_source[] =
+    "#version 100\n"
+    "attribute vec2 position;\n"
+    "attribute vec2 texcoord;\n"
+    "varying vec2 v_texcoord;\n"
+    "\n"
+    "void main()\n"
+    "{\n"
+    "  gl_Position = vec4(position, 0.0, 1.0);\n"
+    "  v_texcoord = texcoord;\n"
+    "}\n";
+
+  static const char fragment_shader_source[] =
+    "#version 100\n"
+    "#extension GL_OES_EGL_image_external : require\n"
+    "precision mediump float;\n"
+    "uniform samplerExternalOES s_texture;\n"
+    "varying vec2 v_texcoord;\n"
+    "\n"
+    " void main()\n"
+    "{\n"
+    "  gl_FragColor = texture2D(s_texture, v_texcoord);\n"
+    "}\n";
+
+  static const GLfloat box[] =
+    { // position    texcoord
+      -1.0f,  1.0f, 0.0f, 0.0f,
+       1.0f,  1.0f, 1.0f, 0.0f,
+       1.0f, -1.0f, 1.0f, 1.0f,
+      -1.0f, -1.0f, 0.0f, 1.0f,
+    };
+  GLint linked;
+  GLuint vertex_shader, fragment_shader;
+  GLint position_attrib, texcoord_attrib;
+  GLuint shader_program;
+
+  if (!shader_program_quark)
+    shader_program_quark = g_quark_from_static_string ("shader program");
+
+  if (g_object_get_qdata (G_OBJECT (gles3), shader_program_quark))
+    return;
+
+  shader_program = glCreateProgram ();
+  g_return_if_fail (shader_program);
+  g_object_set_qdata_full (G_OBJECT (gles3),
+                           shader_program_quark,
+                           GUINT_TO_POINTER (shader_program),
+                           NULL);
+
+  vertex_shader = load_shader (vertex_shader_source, GL_VERTEX_SHADER);
+  g_return_if_fail (vertex_shader);
+  fragment_shader = load_shader (fragment_shader_source, GL_FRAGMENT_SHADER);
+  g_return_if_fail (fragment_shader);
+
+  GLBAS (gles3, glAttachShader, (shader_program, vertex_shader));
+  GLBAS (gles3, glAttachShader, (shader_program, fragment_shader));
+  GLBAS (gles3, glLinkProgram, (shader_program));
+  GLBAS (gles3, glGetProgramiv, (shader_program, GL_LINK_STATUS, &linked));
+  if (!linked)
+    {
+      GLchar log[1024];
+
+      glGetProgramInfoLog (shader_program, sizeof (log) - 1, NULL, log);
+      log[sizeof (log) - 1] = '\0';
+      g_warning ("Link failed: %s", log);
+      return;
+    }
+
+  GLBAS (gles3, glUseProgram, (shader_program));
+
+  position_attrib = glGetAttribLocation (shader_program, "position");
+  GLBAS (gles3, glEnableVertexAttribArray, (position_attrib));
+  GLBAS (gles3, glVertexAttribPointer,
+    (position_attrib, 2, GL_FLOAT, GL_FALSE, 4 * sizeof (GLfloat), box));
+
+  texcoord_attrib = glGetAttribLocation (shader_program, "texcoord");
+  GLBAS (gles3, glEnableVertexAttribArray, (texcoord_attrib));
+  GLBAS (gles3, glVertexAttribPointer,
+    (texcoord_attrib, 2, GL_FLOAT, GL_FALSE, 4 * sizeof (GLfloat), box + 2));
+}
+
 static void
 paint_egl_image (MetaGles3   *gles3,
                  EGLImageKHR  egl_image,
@@ -50,39 +164,33 @@
                  int          height)
 {
   GLuint texture;
-  GLuint framebuffer;
 
   meta_gles3_clear_error (gles3);
+  ensure_shader_program (gles3);
 
-  GLBAS (gles3, glGenFramebuffers, (1, &framebuffer));
-  GLBAS (gles3, glBindFramebuffer, (GL_READ_FRAMEBUFFER, framebuffer));
+  GLBAS (gles3, glViewport, (0, 0, width, height));
 
   GLBAS (gles3, glActiveTexture, (GL_TEXTURE0));
   GLBAS (gles3, glGenTextures, (1, &texture));
-  GLBAS (gles3, glBindTexture, (GL_TEXTURE_2D, texture));
-  GLEXT (gles3, glEGLImageTargetTexture2DOES, (GL_TEXTURE_2D, egl_image));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+  GLBAS (gles3, glBindTexture, (GL_TEXTURE_EXTERNAL_OES, texture));
+  GLEXT (gles3, glEGLImageTargetTexture2DOES, (GL_TEXTURE_EXTERNAL_OES,
+                                               egl_image));
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_MAG_FILTER,
                                   GL_NEAREST));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_MIN_FILTER,
                                   GL_NEAREST));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
-                                  GL_CLAMP_TO_EDGE));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_WRAP_S,
                                   GL_CLAMP_TO_EDGE));
-  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_2D, GL_TEXTURE_WRAP_R_OES,
+  GLBAS (gles3, glTexParameteri, (GL_TEXTURE_EXTERNAL_OES,
+                                  GL_TEXTURE_WRAP_T,
                                   GL_CLAMP_TO_EDGE));
 
-  GLBAS (gles3, glFramebufferTexture2D, (GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                                         GL_TEXTURE_2D, texture, 0));
-
-  GLBAS (gles3, glBindFramebuffer, (GL_READ_FRAMEBUFFER, framebuffer));
-  GLBAS (gles3, glBlitFramebuffer, (0, height, width, 0,
-                                    0, 0, width, height,
-                                    GL_COLOR_BUFFER_BIT,
-                                    GL_NEAREST));
+  GLBAS (gles3, glDrawArrays, (GL_TRIANGLE_FAN, 0, 4));
 
   GLBAS (gles3, glDeleteTextures, (1, &texture));
-  GLBAS (gles3, glDeleteFramebuffers, (1, &framebuffer));
 }
 
 gboolean
diff '--color=auto' -ruN a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
--- a/src/backends/native/meta-renderer-native-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-native-private.h	2023-10-03 20:26:00.165795662 +0300
@@ -60,6 +60,7 @@
   struct {
     MetaSharedFramebufferCopyMode copy_mode;
     gboolean has_EGL_EXT_image_dma_buf_import_modifiers;
+    gboolean needs_explicit_sync;
 
     /* For GPU blit mode */
     EGLContext egl_context;
diff '--color=auto' -ruN a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
--- a/src/backends/native/meta-renderer-view-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-view-native.c	2023-10-03 20:26:00.172462417 +0300
@@ -22,11 +22,28 @@
 
 #include "backends/native/meta-renderer-view-native.h"
 
+#include "backends/meta-output.h"
+#include "backends/native/meta-crtc-kms.h"
 #include "backends/native/meta-frame-native.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-output-kms.h"
+
+#include "clutter/clutter.h"
+
+typedef enum _MetaFrameSyncMode
+{
+  META_FRAME_SYNC_MODE_INIT,
+  META_FRAME_SYNC_MODE_ENABLED,
+  META_FRAME_SYNC_MODE_DISABLED,
+} MetaFrameSyncMode;
 
 struct _MetaRendererViewNative
 {
   MetaRendererView parent;
+
+  MetaFrameSyncMode requested_frame_sync_mode;
+  MetaFrameSyncMode frame_sync_mode;
 };
 
 G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
@@ -39,6 +56,104 @@
 }
 
 static void
+update_frame_sync_mode (MetaRendererViewNative *view_native,
+                        ClutterFrame           *frame,
+                        MetaOutput             *output,
+                        MetaFrameSyncMode       sync_mode)
+{
+  MetaFrameNative *frame_native;
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+  MetaKmsDevice *kms_device;
+  MetaKmsUpdate *kms_update;
+  ClutterFrameClock *frame_clock;
+
+  frame_native = meta_frame_native_from_frame (frame);
+
+  frame_clock =
+    clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+  kms_device = meta_kms_crtc_get_device (kms_crtc);
+
+  kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
+
+  switch (sync_mode)
+    {
+    case META_FRAME_SYNC_MODE_ENABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_VARIABLE);
+      meta_output_kms_set_vrr_mode (META_OUTPUT_KMS (output),
+                                    kms_update,
+                                    TRUE);
+      break;
+    case META_FRAME_SYNC_MODE_DISABLED:
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_FIXED);
+      meta_output_kms_set_vrr_mode (META_OUTPUT_KMS (output),
+                                    kms_update,
+                                    FALSE);
+      break;
+    case META_FRAME_SYNC_MODE_INIT:
+      g_assert_not_reached ();
+    }
+
+  view_native->frame_sync_mode = sync_mode;
+}
+
+static MetaFrameSyncMode
+get_applicable_sync_mode (MetaRendererViewNative *view_native,
+                          MetaOutput             *output)
+{
+  if (meta_output_is_vrr_disallowed (output))
+    return META_FRAME_SYNC_MODE_DISABLED;
+
+  return view_native->requested_frame_sync_mode;
+}
+
+void
+meta_renderer_view_native_maybe_update_frame_sync_mode (MetaRendererViewNative *view_native,
+                                                        ClutterFrame           *frame)
+{
+  MetaRendererView *view = META_RENDERER_VIEW (view_native);
+  MetaOutput *output;
+  MetaFrameSyncMode applicable_sync_mode;
+
+  output = meta_renderer_view_get_output (view);
+
+  if (!meta_output_is_vrr_capable (output))
+    return;
+
+  applicable_sync_mode =
+    get_applicable_sync_mode (view_native, output);
+
+  if (G_LIKELY (applicable_sync_mode == view_native->frame_sync_mode))
+    return;
+
+  update_frame_sync_mode (view_native,
+                          frame,
+                          output,
+                          applicable_sync_mode);
+}
+
+void
+meta_renderer_view_native_request_frame_sync (MetaRendererViewNative *view_native,
+                                              gboolean                enabled)
+{
+  view_native->requested_frame_sync_mode =
+    enabled
+    ? META_FRAME_SYNC_MODE_ENABLED
+    : META_FRAME_SYNC_MODE_DISABLED;
+}
+
+gboolean
+meta_renderer_view_native_is_frame_sync_enabled (MetaRendererViewNative *view_native)
+{
+  return view_native->frame_sync_mode == META_FRAME_SYNC_MODE_ENABLED;
+}
+
+static void
 meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
 {
   ClutterStageViewClass *stage_view_class = CLUTTER_STAGE_VIEW_CLASS (klass);
@@ -49,4 +164,6 @@
 static void
 meta_renderer_view_native_init (MetaRendererViewNative *view_native)
 {
+  view_native->requested_frame_sync_mode = META_FRAME_SYNC_MODE_DISABLED;
+  view_native->frame_sync_mode = META_FRAME_SYNC_MODE_INIT;
 }
diff '--color=auto' -ruN a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
--- a/src/backends/native/meta-renderer-view-native.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-renderer-view-native.h	2023-10-03 20:26:00.172462417 +0300
@@ -27,3 +27,11 @@
 #define META_TYPE_RENDERER_VIEW_NATIVE (meta_renderer_view_native_get_type ())
 G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                       META, RENDERER_VIEW_NATIVE, MetaRendererView)
+
+void meta_renderer_view_native_maybe_update_frame_sync_mode (MetaRendererViewNative *view_native,
+                                                             ClutterFrame           *frame);
+
+void meta_renderer_view_native_request_frame_sync (MetaRendererViewNative *view_native,
+                                                   gboolean                enabled);
+
+gboolean meta_renderer_view_native_is_frame_sync_enabled (MetaRendererViewNative *view_native);
diff '--color=auto' -ruN a/src/backends/native/meta-udev.c b/src/backends/native/meta-udev.c
--- a/src/backends/native/meta-udev.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-udev.c	2023-10-03 20:26:00.169129039 +0300
@@ -101,6 +101,13 @@
 }
 
 gboolean
+meta_is_udev_device_disable_vrr (GUdevDevice *device)
+{
+  return meta_has_udev_device_tag (device,
+                                   "mutter-device-disable-vrr");
+}
+
+gboolean
 meta_is_udev_device_ignore (GUdevDevice *device)
 {
   return meta_has_udev_device_tag (device, "mutter-device-ignore");
diff '--color=auto' -ruN a/src/backends/native/meta-udev.h b/src/backends/native/meta-udev.h
--- a/src/backends/native/meta-udev.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/native/meta-udev.h	2023-10-03 20:26:00.169129039 +0300
@@ -32,6 +32,8 @@
 
 gboolean meta_is_udev_device_disable_modifiers (GUdevDevice *device);
 
+gboolean meta_is_udev_device_disable_vrr (GUdevDevice *device);
+
 gboolean meta_is_udev_device_ignore (GUdevDevice *device);
 
 gboolean meta_is_udev_test_device (GUdevDevice *device);
diff '--color=auto' -ruN a/src/backends/x11/meta-crtc-xrandr.c b/src/backends/x11/meta-crtc-xrandr.c
--- a/src/backends/x11/meta-crtc-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-crtc-xrandr.c	2023-10-03 20:26:00.102461495 +0300
@@ -34,6 +34,7 @@
 #include "backends/x11/meta-crtc-xrandr.h"
 
 #include <X11/Xlib-xcb.h>
+#include <X11/extensions/Xrender.h>
 #include <stdlib.h>
 #include <xcb/randr.h>
 
@@ -44,6 +45,9 @@
 #include "backends/x11/meta-gpu-xrandr.h"
 #include "backends/x11/meta-monitor-manager-xrandr.h"
 
+#define ALL_TRANSFORMS ((1 << (META_MONITOR_TRANSFORM_FLIPPED_270 + 1)) - 1)
+#define DOUBLE_TO_FIXED(d) ((xcb_render_fixed_t) ((d) * 65536))
+
 struct _MetaCrtcXrandr
 {
   MetaCrtc parent;
@@ -108,6 +112,63 @@
   *out_timestamp = reply->timestamp;
   free (reply);
 
+
+  return TRUE;
+}
+
+gboolean
+meta_crtc_xrandr_set_scale (MetaCrtc         *crtc,
+                            xcb_randr_crtc_t  xrandr_crtc,
+                            float             scale)
+{
+  MetaGpu *gpu = meta_crtc_get_gpu (crtc);
+  MetaBackend *backend = meta_gpu_get_backend (gpu);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorManagerXrandr *monitor_manager_xrandr =
+    META_MONITOR_MANAGER_XRANDR (monitor_manager);
+  Display *xdisplay;
+  const char *scale_filter;
+  xcb_connection_t *xcb_conn;
+  xcb_void_cookie_t transform_cookie;
+  xcb_generic_error_t *xcb_error = NULL;
+  xcb_render_transform_t transformation = {
+    DOUBLE_TO_FIXED (1), DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (0),
+    DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (1), DOUBLE_TO_FIXED (0),
+    DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (0), DOUBLE_TO_FIXED (1)
+  };
+
+  if (!(meta_monitor_manager_get_capabilities (monitor_manager) &
+        META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return FALSE;
+
+  xdisplay = meta_monitor_manager_xrandr_get_xdisplay (monitor_manager_xrandr);
+  xcb_conn = XGetXCBConnection (xdisplay);
+
+  if (fabsf (scale - 1.0f) > 0.001)
+    {
+      scale_filter = FilterGood;
+      transformation.matrix11 = DOUBLE_TO_FIXED (1.0 / scale);
+      transformation.matrix22 = DOUBLE_TO_FIXED (1.0 / scale);
+    }
+  else
+    scale_filter = FilterFast;
+
+  transform_cookie =
+    xcb_randr_set_crtc_transform_checked (xcb_conn, xrandr_crtc, transformation,
+                                          strlen (scale_filter), scale_filter,
+                                          0, NULL);
+
+  xcb_error = xcb_request_check (xcb_conn, transform_cookie);
+  if (xcb_error)
+    {
+      meta_warning ("Impossible to set scaling on crtc %u to %f, error id %u",
+                    xrandr_crtc, scale, xcb_error->error_code);
+      g_clear_pointer (&xcb_error, free);
+
+      return FALSE;
+    }
+
   return TRUE;
 }
 
@@ -219,11 +280,34 @@
   return crtc_xrandr->current_mode;
 }
 
+static float
+meta_monitor_scale_from_transformation (XRRCrtcTransformAttributes *transformation)
+{
+  XTransform *xt;
+  float scale;
+
+  if (!transformation)
+    return 1.0f;
+
+  xt = &transformation->currentTransform;
+
+  if (xt->matrix[0][0] == xt->matrix[1][1])
+    scale = XFixedToDouble (xt->matrix[0][0]);
+  else
+    scale = XFixedToDouble (xt->matrix[0][0] + xt->matrix[1][1]) / 2.0;
+
+  g_return_val_if_fail (scale > 0.0f, 1.0f);
+
+  return 1.0f / scale;
+}
+
 MetaCrtcXrandr *
-meta_crtc_xrandr_new (MetaGpuXrandr      *gpu_xrandr,
-                      XRRCrtcInfo        *xrandr_crtc,
-                      RRCrtc              crtc_id,
-                      XRRScreenResources *resources)
+meta_crtc_xrandr_new (MetaGpuXrandr              *gpu_xrandr,
+                      XRRCrtcInfo                *xrandr_crtc,
+                      RRCrtc                      crtc_id,
+                      XRRScreenResources         *resources,
+                      XRRCrtcTransformAttributes *transform_attributes,
+                      float                       scale_multiplier)
 {
   MetaGpu *gpu = META_GPU (gpu_xrandr);
   MetaBackend *backend = meta_gpu_get_backend (gpu);
@@ -284,6 +368,9 @@
 
   if (crtc_xrandr->current_mode)
     {
+      float crtc_scale =
+        meta_monitor_scale_from_transformation (transform_attributes);
+
       meta_crtc_set_config (META_CRTC (crtc_xrandr),
                             &GRAPHENE_RECT_INIT (crtc_xrandr->rect.x,
                                                  crtc_xrandr->rect.y,
@@ -291,6 +378,11 @@
                                                  crtc_xrandr->rect.height),
                             crtc_xrandr->current_mode,
                             crtc_xrandr->transform);
+
+      if (scale_multiplier > 0.0f)
+        crtc_scale *= scale_multiplier;
+
+      meta_crtc_set_config_scale (META_CRTC (crtc_xrandr), crtc_scale);
     }
 
   return crtc_xrandr;
diff '--color=auto' -ruN a/src/backends/x11/meta-crtc-xrandr.h b/src/backends/x11/meta-crtc-xrandr.h
--- a/src/backends/x11/meta-crtc-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-crtc-xrandr.h	2023-10-03 20:26:00.102461495 +0300
@@ -41,12 +41,18 @@
                                       int                  n_outputs,
                                       xcb_timestamp_t     *out_timestamp);
 
+gboolean meta_crtc_xrandr_set_scale (MetaCrtc         *crtc,
+                                     xcb_randr_crtc_t  xrandr_crtc,
+                                     float             scale);
+
 gboolean meta_crtc_xrandr_is_assignment_changed (MetaCrtcXrandr     *crtc_xrandr,
                                                  MetaCrtcAssignment *crtc_assignment);
 
 MetaCrtcMode * meta_crtc_xrandr_get_current_mode (MetaCrtcXrandr *crtc_xrandr);
 
-MetaCrtcXrandr * meta_crtc_xrandr_new (MetaGpuXrandr      *gpu_xrandr,
-                                       XRRCrtcInfo        *xrandr_crtc,
-                                       RRCrtc              crtc_id,
-                                       XRRScreenResources *resources);
+MetaCrtcXrandr * meta_crtc_xrandr_new (MetaGpuXrandr              *gpu_xrandr,
+                                       XRRCrtcInfo                *xrandr_crtc,
+                                       RRCrtc                      crtc_id,
+                                       XRRScreenResources         *resources,
+                                       XRRCrtcTransformAttributes *transform_attributes,
+                                       float                       scale_multiplier);
diff '--color=auto' -ruN a/src/backends/x11/meta-gpu-xrandr.c b/src/backends/x11/meta-gpu-xrandr.c
--- a/src/backends/x11/meta-gpu-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-gpu-xrandr.c	2023-10-03 20:26:00.102461495 +0300
@@ -23,12 +23,14 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "backends/meta-crtc.h"
 #include "config.h"
 
 #include "backends/x11/meta-gpu-xrandr.h"
 
 #include <string.h>
 #include <X11/extensions/dpms.h>
+#include <X11/Xatom.h>
 #include <X11/Xlibint.h>
 
 #include "backends/meta-backend-private.h"
@@ -44,6 +46,8 @@
 
   XRRScreenResources *resources;
 
+  int min_screen_width;
+  int min_screen_height;
   int max_screen_width;
   int max_screen_height;
 };
@@ -57,6 +61,15 @@
 }
 
 void
+meta_gpu_xrandr_get_min_screen_size (MetaGpuXrandr *gpu_xrandr,
+                                     int           *min_width,
+                                     int           *min_height)
+{
+  *min_width = gpu_xrandr->min_screen_width;
+  *min_height = gpu_xrandr->min_screen_height;
+}
+
+void
 meta_gpu_xrandr_get_max_screen_size (MetaGpuXrandr *gpu_xrandr,
                                      int           *max_width,
                                      int           *max_height)
@@ -107,6 +120,59 @@
   return xmode->dotClock / (h_total * v_total);
 }
 
+static int
+get_current_dpi_scale (MetaMonitorManagerXrandr *manager_xrandr,
+                       MetaGpuXrandr            *gpu_xrandr)
+{
+  Atom actual;
+  int result, format;
+  unsigned long n, left;
+  g_autofree unsigned char *data = NULL;
+  g_auto(GStrv) resources = NULL;
+  Display *dpy;
+  int i;
+
+  if (gpu_xrandr->resources->timestamp ==
+      meta_monitor_manager_xrandr_get_config_timestamp (manager_xrandr))
+    {
+      MetaMonitorManager *monitor_manager = META_MONITOR_MANAGER (manager_xrandr);
+      MetaBackend *backend = meta_monitor_manager_get_backend (monitor_manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+
+      return meta_settings_get_ui_scaling_factor (settings);
+    }
+
+  dpy = meta_monitor_manager_xrandr_get_xdisplay (manager_xrandr);
+  result = XGetWindowProperty (dpy, DefaultRootWindow (dpy),
+                               XA_RESOURCE_MANAGER, 0L, 65536, False,
+                               XA_STRING, &actual, &format,
+                               &n, &left, &data);
+
+  if (result != Success || !data || actual != XA_STRING)
+    return 1;
+
+  resources = g_strsplit ((char *) data, "\n", -1);
+
+  for (i = 0; resources && resources[i]; ++i)
+    {
+      if (g_str_has_prefix (resources[i], "Xft.dpi:"))
+        {
+          g_auto(GStrv) res = g_strsplit (resources[i], "\t", 2);
+
+          if (res && res[0] && res[1])
+            {
+              guint64 dpi;
+              dpi = g_ascii_strtoull (res[1], NULL, 10);
+
+              if (dpi > 0 && dpi < 96 * 10)
+                return MAX (1, roundf ((float) dpi / 96.0f));
+            }
+        }
+    }
+
+  return 1;
+}
+
 static gboolean
 meta_gpu_xrandr_read_current (MetaGpu  *gpu,
                               GError  **error)
@@ -123,19 +189,20 @@
   RROutput primary_output;
   unsigned int i, j;
   GList *l;
-  int min_width, min_height;
   Screen *screen;
   GList *outputs = NULL;
   GList *modes = NULL;
   GList *crtcs = NULL;
+  gboolean has_transform;
+  int dpi_scale = 1;
 
   if (gpu_xrandr->resources)
     XRRFreeScreenResources (gpu_xrandr->resources);
   gpu_xrandr->resources = NULL;
 
   XRRGetScreenSizeRange (xdisplay, DefaultRootWindow (xdisplay),
-                         &min_width,
-                         &min_height,
+                         &gpu_xrandr->min_screen_width,
+                         &gpu_xrandr->min_screen_height,
                          &gpu_xrandr->max_screen_width,
                          &gpu_xrandr->max_screen_height);
 
@@ -182,22 +249,60 @@
     }
   meta_gpu_take_modes (gpu, modes);
 
+  has_transform = !!(meta_monitor_manager_get_capabilities (monitor_manager) &
+                     META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING);
+
+  if (has_transform &&
+      meta_monitor_manager_get_default_layout_mode (monitor_manager) ==
+      META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    dpi_scale = get_current_dpi_scale (monitor_manager_xrandr, gpu_xrandr);
+
   for (i = 0; i < (unsigned)resources->ncrtc; i++)
     {
       XRRCrtcInfo *xrandr_crtc;
+      XRRCrtcTransformAttributes *transform_attributes;
       RRCrtc crtc_id;
       MetaCrtcXrandr *crtc_xrandr;
 
       crtc_id = resources->crtcs[i];
       xrandr_crtc = XRRGetCrtcInfo (xdisplay,
                                     resources, crtc_id);
+
+      if (!has_transform ||
+          !XRRGetCrtcTransform (xdisplay, crtc_id, &transform_attributes))
+        transform_attributes = NULL;
+
       crtc_xrandr = meta_crtc_xrandr_new (gpu_xrandr,
-                                          xrandr_crtc, crtc_id, resources);
+                                          xrandr_crtc, crtc_id, resources,
+                                          transform_attributes, dpi_scale);
+      XFree (transform_attributes);
       XRRFreeCrtcInfo (xrandr_crtc);
 
       crtcs = g_list_append (crtcs, crtc_xrandr);
     }
 
+  if (has_transform && dpi_scale == 1 &&
+      meta_monitor_manager_get_default_layout_mode (monitor_manager) ==
+        META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      dpi_scale =
+        ceilf (meta_monitor_manager_get_maximum_crtc_scale (monitor_manager));
+
+      if (dpi_scale > 1)
+        {
+          for (l = crtcs; l; l = l->next)
+            {
+              MetaCrtc *crtc = l->data;
+              const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+
+              if (!crtc_config)
+                continue;
+
+              meta_crtc_set_config_scale (crtc, crtc_config->scale * dpi_scale);
+            }
+        }
+    }
+
   meta_gpu_take_crtcs (gpu, crtcs);
 
   primary_output = XRRGetOutputPrimary (xdisplay,
diff '--color=auto' -ruN a/src/backends/x11/meta-gpu-xrandr.h b/src/backends/x11/meta-gpu-xrandr.h
--- a/src/backends/x11/meta-gpu-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-gpu-xrandr.h	2023-10-03 20:26:00.102461495 +0300
@@ -30,6 +30,10 @@
 
 XRRScreenResources * meta_gpu_xrandr_get_resources (MetaGpuXrandr *gpu_xrandr);
 
+void meta_gpu_xrandr_get_min_screen_size (MetaGpuXrandr *gpu_xrandr,
+                                          int           *min_width,
+                                          int           *min_height);
+
 void meta_gpu_xrandr_get_max_screen_size (MetaGpuXrandr *gpu_xrandr,
                                           int           *max_width,
                                           int           *max_height);
diff '--color=auto' -ruN a/src/backends/x11/meta-monitor-manager-xrandr.c b/src/backends/x11/meta-monitor-manager-xrandr.c
--- a/src/backends/x11/meta-monitor-manager-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-monitor-manager-xrandr.c	2023-10-03 20:26:00.105794871 +0300
@@ -36,6 +36,7 @@
  * and udev.
  */
 
+#include "backends/meta-backend-types.h"
 #include "config.h"
 
 #include "backends/x11/meta-monitor-manager-xrandr.h"
@@ -64,6 +65,9 @@
  * http://git.gnome.org/browse/gnome-settings-daemon/tree/plugins/xsettings/gsd-xsettings-manager.c
  * for the reasoning */
 #define DPI_FALLBACK 96.0
+#define RANDR_VERSION_FORMAT(major, minor) ((major * 100) + minor)
+#define RANDR_TILING_MIN_VERSION RANDR_VERSION_FORMAT (1, 5)
+#define RANDR_TRANSFORM_MIN_VERSION RANDR_VERSION_FORMAT (1, 3)
 
 struct _MetaMonitorManagerXrandr
 {
@@ -72,13 +76,15 @@
   Display *xdisplay;
   int rr_event_base;
   int rr_error_base;
-  gboolean has_randr15;
+  int randr_version;
 
   xcb_timestamp_t last_xrandr_set_timestamp;
 
   GHashTable *tiled_monitor_atoms;
 };
 
+static MetaGpu * meta_monitor_manager_xrandr_get_gpu (MetaMonitorManagerXrandr *manager_xrandr);
+
 struct _MetaMonitorManagerXrandrClass
 {
   MetaMonitorManagerClass parent_class;
@@ -99,10 +105,10 @@
   return manager_xrandr->xdisplay;
 }
 
-gboolean
-meta_monitor_manager_xrandr_has_randr15 (MetaMonitorManagerXrandr *manager_xrandr)
+uint32_t
+meta_monitor_manager_xrandr_get_config_timestamp (MetaMonitorManagerXrandr *manager_xrandr)
 {
-  return manager_xrandr->has_randr15;
+  return manager_xrandr->last_xrandr_set_timestamp;
 }
 
 static GBytes *
@@ -191,6 +197,81 @@
   mtk_x11_error_trap_pop (manager_xrandr->xdisplay);
 }
 
+static void
+meta_monitor_manager_xrandr_update_screen_size (MetaMonitorManagerXrandr *manager_xrandr,
+                                                int                       width,
+                                                int                       height,
+                                                float                     scale)
+{
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
+  MetaGpu *gpu = meta_monitor_manager_xrandr_get_gpu (manager_xrandr);
+  xcb_connection_t *xcb_conn;
+  xcb_generic_error_t *xcb_error;
+  xcb_void_cookie_t xcb_cookie;
+  Screen *screen;
+  int min_width;
+  int min_height;
+  int max_width;
+  int max_height;
+  int width_mm;
+  int height_mm;
+
+  g_assert (width > 0 && height > 0 && scale > 0);
+
+  if (manager->screen_width == width && manager->screen_height == height)
+    return;
+
+  screen = ScreenOfDisplay (manager_xrandr->xdisplay,
+                            DefaultScreen (manager_xrandr->xdisplay));
+  meta_gpu_xrandr_get_min_screen_size (META_GPU_XRANDR (gpu),
+                                       &min_width, &min_height);
+  meta_gpu_xrandr_get_max_screen_size (META_GPU_XRANDR (gpu),
+                                       &max_width, &max_height);
+  width = MIN (MAX (min_width, width), max_width);
+  height = MIN (MAX (min_height, height), max_height);
+
+  /* The 'physical size' of an X screen is meaningless if that screen can
+   * consist of many monitors. So just pick a size that make the dpi 96.
+   *
+   * Firefox and Evince apparently believe what X tells them.
+   */
+  width_mm = (width / (DPI_FALLBACK * scale)) * 25.4 + 0.5;
+  height_mm = (height / (DPI_FALLBACK * scale)) * 25.4 + 0.5;
+
+  if (width == WidthOfScreen (screen) && height == HeightOfScreen (screen) &&
+      width_mm == WidthMMOfScreen (screen) && height_mm == HeightMMOfScreen (screen))
+    return;
+
+  xcb_conn = XGetXCBConnection (manager_xrandr->xdisplay);
+
+  xcb_grab_server (xcb_conn);
+
+  /* Some drivers (nvidia I look at you!) might no advertise some CRTCs, so in
+   * such case, we may ignore X errors here */
+  xcb_cookie = xcb_randr_set_screen_size_checked (xcb_conn,
+                                                  DefaultRootWindow (manager_xrandr->xdisplay),
+                                                  width, height,
+                                                  width_mm, height_mm);
+  xcb_error = xcb_request_check (xcb_conn, xcb_cookie);
+  if (!xcb_error)
+    {
+      manager->screen_width = width;
+      manager->screen_height = height;
+    }
+  else
+    {
+      gchar buf[64];
+
+      XGetErrorText (manager_xrandr->xdisplay, xcb_error->error_code, buf,
+                     sizeof (buf) - 1);
+      meta_warning ("Impossible to resize screen at size %dx%d, error id %u: %s",
+                    width, height, xcb_error->error_code, buf);
+      g_clear_pointer (&xcb_error, free);
+    }
+
+  xcb_ungrab_server (xcb_conn);
+}
+
 static xcb_randr_rotation_t
 meta_monitor_transform_to_xrandr (MetaMonitorTransform transform)
 {
@@ -246,13 +327,50 @@
   return TRUE;
 }
 
+static float
+get_maximum_crtc_assignments_scale (MetaCrtcAssignment **crtc_assignments,
+                                    unsigned int         n_crtc_assignments)
+{
+  float max_scale = 1.0f;
+  unsigned int i;
+
+  for (i = 0; i < n_crtc_assignments; i++)
+    {
+      MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
+
+      if (crtc_assignment->mode)
+        max_scale = MAX (max_scale, crtc_assignment->scale);
+    }
+
+  return max_scale;
+}
+
 static gboolean
-is_crtc_assignment_changed (MetaCrtc            *crtc,
+is_crtc_assignment_changed (MetaMonitorManager  *monitor_manager,
+                            MetaCrtc            *crtc,
                             MetaCrtcAssignment **crtc_assignments,
-                            unsigned int         n_crtc_assignments)
+                            unsigned int         n_crtc_assignments,
+                            gboolean            *weak_change)
 {
+  MetaLogicalMonitorLayoutMode layout_mode;
+  gboolean have_scaling;
+  float max_crtc_scale = 1.0f;
+  float max_req_scale = 1.0f;
   unsigned int i;
 
+  layout_mode = meta_monitor_manager_get_default_layout_mode (monitor_manager);
+  have_scaling = meta_monitor_manager_get_capabilities (monitor_manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  if (have_scaling &&
+      layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      max_crtc_scale =
+        meta_monitor_manager_get_maximum_crtc_scale (monitor_manager);
+      max_req_scale =
+        get_maximum_crtc_assignments_scale (crtc_assignments, n_crtc_assignments);
+    }
+
   for (i = 0; i < n_crtc_assignments; i++)
     {
       MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
@@ -260,8 +378,44 @@
       if (crtc_assignment->crtc != crtc)
         continue;
 
-      return meta_crtc_xrandr_is_assignment_changed (META_CRTC_XRANDR (crtc),
-                                                     crtc_assignment);
+      if (meta_crtc_xrandr_is_assignment_changed (META_CRTC_XRANDR (crtc),
+                                                  crtc_assignment))
+        return TRUE;
+
+      if (have_scaling)
+        {
+          const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+          float crtc_scale = crtc_config ? crtc_config->scale : 1.0f;
+          float req_output_scale = crtc_assignment->scale;
+
+          if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL)
+            {
+              if (fmodf (crtc_scale, 1.0) == 0.0f)
+                {
+                  *weak_change = fabsf (crtc_scale - req_output_scale) > 0.001;
+                  return FALSE;
+                }
+            }
+          else if (layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+            {
+              /* In scale ui-down mode we need to check if the actual output
+               * scale that will be applied to the crtc has actually changed
+               * from the current value, so we need to compare the current crtc
+               * scale with the scale that will be applied taking care of the
+               * UI scale (max crtc scale) and of the requested maximum scale.
+               * If we don't do this, we'd try to call randr calls which won't
+               * ever trigger a RRScreenChangeNotify, as no actual change is
+               * needed, and thus we won't ever emit a monitors-changed signal.
+               */
+              crtc_scale /= ceilf (max_crtc_scale);
+              req_output_scale /= ceilf (max_req_scale);
+            }
+
+          if (fabsf (crtc_scale - req_output_scale) > 0.001)
+            return TRUE;
+        }
+
+      return FALSE;
     }
 
   return !!meta_crtc_xrandr_get_current_mode (META_CRTC_XRANDR (crtc));
@@ -349,7 +503,8 @@
                         MetaCrtcAssignment   **crtc_assignments,
                         unsigned int           n_crtc_assignments,
                         MetaOutputAssignment **output_assignments,
-                        unsigned int           n_output_assignments)
+                        unsigned int           n_output_assignments,
+                        gboolean              *weak_change)
 {
   MetaMonitorManagerXrandr *manager_xrandr =
     META_MONITOR_MANAGER_XRANDR (manager);
@@ -360,7 +515,9 @@
     {
       MetaCrtc *crtc = l->data;
 
-      if (is_crtc_assignment_changed (crtc, crtc_assignments, n_crtc_assignments))
+      if (is_crtc_assignment_changed (manager, crtc,
+                                      crtc_assignments, n_crtc_assignments,
+                                      weak_change))
         return TRUE;
     }
 
@@ -376,6 +533,32 @@
         return TRUE;
     }
 
+  if (meta_monitor_manager_get_default_layout_mode (manager) ==
+      META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      /* If nothing has changed, ensure that the crtc logical scaling matches
+       * with the requested one, as in case of global UI logical layout we might
+       * assume that it is in fact equal, while it's techincally different.
+       * Not doing this would then cause a wrong computation of the max crtc
+       * scale and thus of the UI scaling. */
+      for (l = meta_gpu_get_crtcs (gpu); l; l = l->next)
+        {
+          MetaCrtc *crtc = l->data;
+          unsigned int i;
+
+          for (i = 0; i < n_crtc_assignments; i++)
+            {
+              MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
+
+              if (crtc_assignment->crtc == crtc)
+                {
+                  meta_crtc_set_config_scale (crtc, crtc_assignment->scale);
+                  break;
+                }
+            }
+        }
+    }
+
   return FALSE;
 }
 
@@ -391,31 +574,55 @@
   MetaGpu *gpu = meta_monitor_manager_xrandr_get_gpu (manager_xrandr);
   g_autoptr (GList) to_configure_outputs = NULL;
   g_autoptr (GList) to_disable_crtcs = NULL;
-  unsigned i;
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+  unsigned i, valid_crtcs;
   GList *l;
-  int width, height, width_mm, height_mm;
+  int width, height;
+  float max_scale;
+  float avg_screen_scale;
+  gboolean have_scaling;
 
   to_configure_outputs = g_list_copy (meta_gpu_get_outputs (gpu));
   to_disable_crtcs = g_list_copy (meta_gpu_get_crtcs (gpu));
 
   XGrabServer (manager_xrandr->xdisplay);
 
-  /* First compute the new size of the screen (framebuffer) */
+  have_scaling = meta_monitor_manager_get_capabilities (manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  /* Compute the new size of the screen (framebuffer) */
+  max_scale = get_maximum_crtc_assignments_scale (crtcs, n_crtcs);
   width = 0; height = 0;
+  avg_screen_scale = 0;
+  valid_crtcs = 0;
   for (i = 0; i < n_crtcs; i++)
     {
       MetaCrtcAssignment *crtc_assignment = crtcs[i];
       MetaCrtc *crtc = crtc_assignment->crtc;
+      float scale = 1.0f;
 
       if (crtc_assignment->mode == NULL)
         continue;
 
       to_disable_crtcs = g_list_remove (to_disable_crtcs, crtc);
 
-      width = MAX (width, (int) roundf (crtc_assignment->layout.origin.x +
-                                        crtc_assignment->layout.size.width));
-      height = MAX (height, (int) roundf (crtc_assignment->layout.origin.y +
-                                          crtc_assignment->layout.size.height));
+      if (have_scaling && scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+        {
+          scale = (ceilf (max_scale) / crtc_assignment->scale) *
+            crtc_assignment->scale;
+        }
+
+      width = MAX (width,
+                   (int) roundf (crtc_assignment->layout.origin.x +
+                                 crtc_assignment->layout.size.width * scale));
+      height = MAX (height,
+                    (int) roundf (crtc_assignment->layout.origin.y +
+                                  crtc_assignment->layout.size.height * scale));
+
+      avg_screen_scale += (crtc_assignment->scale - avg_screen_scale) /
+                          (float) (++valid_crtcs);
     }
 
   /* Second disable all newly disabled CRTCs, or CRTCs that in the previous
@@ -449,6 +656,10 @@
                                   0, 0, XCB_NONE,
                                   XCB_RANDR_ROTATION_ROTATE_0,
                                   NULL, 0);
+          if (have_scaling)
+            meta_crtc_xrandr_set_scale (crtc,
+                                        (xcb_randr_crtc_t) meta_crtc_get_id (crtc),
+                                        1.0f);
 
           meta_crtc_unset_config (crtc);
         }
@@ -469,6 +680,10 @@
                               0, 0, XCB_NONE,
                               XCB_RANDR_ROTATION_ROTATE_0,
                               NULL, 0);
+      if (have_scaling)
+        meta_crtc_xrandr_set_scale (crtc,
+                                    (xcb_randr_crtc_t) meta_crtc_get_id (crtc),
+                                    1.0f);
 
       meta_crtc_unset_config (crtc);
     }
@@ -476,17 +691,12 @@
   if (!n_crtcs)
     goto out;
 
-  g_assert (width > 0 && height > 0);
-  /* The 'physical size' of an X screen is meaningless if that screen
-   * can consist of many monitors. So just pick a size that make the
-   * dpi 96.
-   *
-   * Firefox and Evince apparently believe what X tells them.
-   */
-  width_mm = (width / DPI_FALLBACK) * 25.4 + 0.5;
-  height_mm = (height / DPI_FALLBACK) * 25.4 + 0.5;
-  XRRSetScreenSize (manager_xrandr->xdisplay, DefaultRootWindow (manager_xrandr->xdisplay),
-                    width, height, width_mm, height_mm);
+  if (width > manager->screen_width || height > manager->screen_height)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      width, height,
+                                                      avg_screen_scale);
+    }
 
   for (i = 0; i < n_crtcs; i++)
     {
@@ -502,12 +712,21 @@
           int x, y;
           xcb_randr_rotation_t rotation;
           xcb_randr_mode_t mode;
+          float scale = 1.0f;
 
           crtc_mode = crtc_assignment->mode;
 
           n_output_ids = crtc_assignment->outputs->len;
           output_ids = g_new (xcb_randr_output_t, n_output_ids);
 
+          if (have_scaling && scale_mode != META_X11_SCALE_MODE_NONE)
+            {
+              scale = crtc_assignment->scale;
+
+              if (scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+                scale /= ceilf (max_scale);
+            }
+
           for (j = 0; j < n_output_ids; j++)
             {
               MetaOutput *output;
@@ -532,6 +751,14 @@
           rotation =
             meta_monitor_transform_to_xrandr (crtc_assignment->transform);
           mode =  meta_crtc_mode_get_id (crtc_mode);
+
+          if (have_scaling &&
+              !meta_crtc_xrandr_set_scale (crtc, crtc_id, scale))
+            {
+              meta_warning ("Scalig CRTC %d at %f failed\n",
+                            (unsigned) crtc_id, scale);
+            }
+
           if (!xrandr_set_crtc_config (manager_xrandr,
                                        crtc,
                                        save_timestamp,
@@ -560,6 +787,20 @@
                                 &crtc_assignment->layout,
                                 crtc_mode,
                                 crtc_assignment->transform);
+          meta_crtc_set_config_scale (crtc, crtc_assignment->scale);
+
+          if (have_scaling && scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+            {
+              const MetaCrtcConfig *crtc_config = meta_crtc_get_config (crtc);
+              graphene_size_t *crtc_size =
+                (graphene_size_t *) &crtc_config->layout.size;
+
+              scale = (ceilf (max_scale) / crtc_assignment->scale) *
+                crtc_assignment->scale;
+
+              crtc_size->width = roundf (crtc_size->width * scale);
+              crtc_size->height = roundf (crtc_size->height * scale);
+            }
         }
     }
 
@@ -575,6 +816,13 @@
                   (GFunc) meta_output_unassign_crtc,
                   NULL);
 
+  if (width > 0 && height > 0)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      width, height,
+                                                      avg_screen_scale);
+    }
+
 out:
   XUngrabServer (manager_xrandr->xdisplay);
   XFlush (manager_xrandr->xdisplay);
@@ -600,6 +848,91 @@
   meta_monitor_manager_update_logical_state_derived (manager, config);
 }
 
+static void
+meta_monitor_manager_xrandr_update_screen_size_derived (MetaMonitorManager *manager,
+                                                        MetaMonitorsConfig *config)
+{
+  MetaMonitorManagerXrandr *manager_xrandr =
+    META_MONITOR_MANAGER_XRANDR (manager);
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+  int screen_width = 0;
+  int screen_height = 0;
+  unsigned n_crtcs = 0;
+  float average_scale = 0;
+  gboolean have_scaling;
+  GList *l;
+
+  have_scaling = meta_monitor_manager_get_capabilities (manager) &
+                 META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  /* Compute the new size of the screen (framebuffer) */
+  for (l = manager->monitors; l != NULL; l = l->next)
+    {
+      MetaMonitor *monitor = l->data;
+      MetaOutput *output = meta_monitor_get_main_output (monitor);
+      MetaCrtc *crtc = meta_output_get_assigned_crtc (output);
+      const MetaCrtcConfig *crtc_config;
+      const graphene_rect_t *crtc_layout;
+      float scale = 1.0f;
+
+      if (!crtc)
+        continue;
+
+      crtc_config = meta_crtc_get_config (crtc);
+
+      if (!crtc_config)
+        continue;
+
+      if (!have_scaling || scale_mode != META_X11_SCALE_MODE_UI_DOWN)
+        {
+          /* When scaling up we should not reduce the screen size, or X will
+           * fail miserably, while we must do it when scaling down, in order to
+           * increase the available screen area we can use. */
+          scale = crtc_config->scale > 1.0f ? crtc_config->scale : 1.0f;
+        }
+
+      /* When computing the screen size from the crtc rects we don't have to
+       * use inverted values when monitors are rotated, because this is already
+       * taken in account in the crtc rectangles */
+      crtc_layout = &crtc_config->layout;
+      screen_width = MAX (screen_width, crtc_layout->origin.x +
+                          roundf (crtc_layout->size.width * scale));
+      screen_height = MAX (screen_height, crtc_layout->origin.y +
+                           roundf (crtc_layout->size.height * scale));
+      ++n_crtcs;
+
+      /* This value isn't completely exact, since it doesn't take care of the
+       * actual crtc sizes, however, since w're going to use this only to set
+       * the MM size of the screen, and given that this value is just an
+       * estimation, we don't need to be super precise. */
+      average_scale += (crtc_config->scale - average_scale) / (float) n_crtcs;
+    }
+
+  if (screen_width > 0 && screen_height > 0)
+    {
+      meta_monitor_manager_xrandr_update_screen_size (manager_xrandr,
+                                                      screen_width,
+                                                      screen_height,
+                                                      average_scale);
+    }
+}
+
+static void
+maybe_update_ui_scaling_factor (MetaMonitorManager *manager,
+                                MetaMonitorsConfig *config)
+{
+  if (config->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL ||
+      manager->layout_mode == META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL)
+    {
+      MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+
+      meta_settings_update_ui_scaling_factor (settings);
+    }
+}
+
 static gboolean
 meta_monitor_manager_xrandr_apply_monitors_config (MetaMonitorManager      *manager,
                                                    MetaMonitorsConfig      *config,
@@ -626,6 +959,8 @@
 
   if (method != META_MONITORS_CONFIG_METHOD_VERIFY)
     {
+      gboolean weak_change = FALSE;
+
       /*
        * If the assignment has not changed, we won't get any notification about
        * any new configuration from the X server; but we still need to update
@@ -633,12 +968,16 @@
        * have changed locally, such as the logical monitors scale. This means we
        * must check that our new assignment actually changes anything, otherwise
        * just update the logical state.
+       * If we record a weak change it means that only UI scaling needs to be
+       * updated and so that we don't have to reconfigure the CRTCs, but still
+       * need to update the logical state.
        */
       if (is_assignments_changed (manager,
                                   (MetaCrtcAssignment **) crtc_assignments->pdata,
                                   crtc_assignments->len,
                                   (MetaOutputAssignment **) output_assignments->pdata,
-                                  output_assignments->len))
+                                  output_assignments->len,
+                                  &weak_change))
         {
           apply_crtc_assignments (manager,
                                   TRUE,
@@ -646,9 +985,13 @@
                                   crtc_assignments->len,
                                   (MetaOutputAssignment **) output_assignments->pdata,
                                   output_assignments->len);
+          maybe_update_ui_scaling_factor (manager, config);
         }
       else
         {
+          if (weak_change)
+            maybe_update_ui_scaling_factor (manager, config);
+
           meta_monitor_manager_rebuild_derived (manager, config);
         }
     }
@@ -737,7 +1080,8 @@
   GList *l;
   int i;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   product = meta_monitor_get_product (monitor);
@@ -786,7 +1130,8 @@
 
   int monitor_count;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   monitor_xrandr_data = meta_monitor_xrandr_data_from_monitor (monitor);
@@ -804,10 +1149,12 @@
 static void
 meta_monitor_manager_xrandr_init_monitors (MetaMonitorManagerXrandr *manager_xrandr)
 {
+  MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
   XRRMonitorInfo *m;
   int n, i;
 
-  if (manager_xrandr->has_randr15 == FALSE)
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     return;
 
   /* delete any tiled monitors setup, as mutter will want to recreate
@@ -839,6 +1186,18 @@
   return TRUE;
 }
 
+static MetaMonitorScalesConstraint
+get_scale_constraints (MetaMonitorManager *manager)
+{
+  MetaMonitorScalesConstraint constraints = 0;
+
+  if (meta_monitor_manager_get_capabilities (manager) &
+      META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED)
+    constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+
+  return constraints;
+}
+
 static float
 meta_monitor_manager_xrandr_calculate_monitor_mode_scale (MetaMonitorManager           *manager,
                                                           MetaLogicalMonitorLayoutMode  layout_mode,
@@ -847,7 +1206,7 @@
 {
   MetaMonitorScalesConstraint constraints;
 
-  constraints = META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+  constraints = get_scale_constraints (manager);
   return meta_monitor_calculate_mode_scale (monitor, monitor_mode, constraints);
 }
 
@@ -860,7 +1219,7 @@
 {
   MetaMonitorScalesConstraint constraints;
 
-  constraints = META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
+  constraints = get_scale_constraints (manager);
   return meta_monitor_calculate_supported_scales (monitor, monitor_mode,
                                                   constraints,
                                                   n_supported_scales);
@@ -869,7 +1228,30 @@
 static MetaMonitorManagerCapability
 meta_monitor_manager_xrandr_get_capabilities (MetaMonitorManager *manager)
 {
-  return META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED;
+  MetaMonitorManagerCapability capabilities;
+  MetaMonitorManagerXrandr *xrandr_manager = META_MONITOR_MANAGER_XRANDR (manager);
+  MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  capabilities = META_MONITOR_MANAGER_CAPABILITY_NONE;
+
+  if (xrandr_manager->randr_version >= RANDR_TILING_MIN_VERSION)
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_TILING;
+
+  if (xrandr_manager->randr_version >= RANDR_TRANSFORM_MIN_VERSION)
+    capabilities |= META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING;
+
+  if (meta_settings_is_experimental_feature_enabled (settings,
+        META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    {
+      capabilities |= META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE;
+    }
+  else
+    {
+      capabilities |= META_MONITOR_MANAGER_CAPABILITY_GLOBAL_SCALE_REQUIRED;
+    }
+
+  return capabilities;
 }
 
 static gboolean
@@ -887,9 +1269,41 @@
   return TRUE;
 }
 
+static void
+scale_mode_changed (MetaSettings       *settings,
+                    MetaMonitorManager *manager)
+{
+  if (!(meta_monitor_manager_get_capabilities (manager) &
+        META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING))
+    return;
+
+  if (!meta_settings_is_experimental_feature_enabled (settings,
+      META_EXPERIMENTAL_FEATURE_X11_RANDR_FRACTIONAL_SCALING))
+    return;
+
+  meta_monitor_manager_reconfigure (manager);
+  meta_settings_update_ui_scaling_factor (settings);
+}
+
 static MetaLogicalMonitorLayoutMode
 meta_monitor_manager_xrandr_get_default_layout_mode (MetaMonitorManager *manager)
 {
+  MetaMonitorManagerCapability capabilities =
+    meta_monitor_manager_get_capabilities (manager);
+
+  if ((capabilities & META_MONITOR_MANAGER_CAPABILITY_NATIVE_OUTPUT_SCALING) &&
+      (capabilities & META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE))
+    {
+      MetaBackend *backend = meta_monitor_manager_get_backend (manager);
+      MetaSettings *settings = meta_backend_get_settings (backend);
+      MetaX11ScaleMode scale_mode = meta_settings_get_x11_scale_mode (settings);
+
+      if (scale_mode == META_X11_SCALE_MODE_UI_DOWN)
+        return META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL;
+      else if (scale_mode == META_X11_SCALE_MODE_UP)
+        return META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL;
+    }
+
   return META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL;
 }
 
@@ -908,6 +1322,7 @@
   MetaMonitorManager *manager = META_MONITOR_MANAGER (manager_xrandr);
   MetaBackend *backend = meta_monitor_manager_get_backend (manager);
   MetaBackendX11 *backend_x11 = META_BACKEND_X11 (backend);
+  MetaSettings *settings = meta_backend_get_settings (backend);
 
   manager_xrandr->xdisplay = meta_backend_x11_get_xdisplay (backend_x11);
 
@@ -928,19 +1343,19 @@
 		      | RRCrtcChangeNotifyMask
 		      | RROutputPropertyNotifyMask);
 
-      manager_xrandr->has_randr15 = FALSE;
       XRRQueryVersion (manager_xrandr->xdisplay, &major_version,
                        &minor_version);
-      if (major_version > 1 ||
-          (major_version == 1 &&
-           minor_version >= 5))
-        {
-          manager_xrandr->has_randr15 = TRUE;
-          manager_xrandr->tiled_monitor_atoms = g_hash_table_new (NULL, NULL);
-        }
+      manager_xrandr->randr_version = RANDR_VERSION_FORMAT (major_version,
+                                                            minor_version);
+      if (manager_xrandr->randr_version >= RANDR_TILING_MIN_VERSION)
+        manager_xrandr->tiled_monitor_atoms = g_hash_table_new (NULL, NULL);
+
       meta_monitor_manager_xrandr_init_monitors (manager_xrandr);
     }
 
+  g_signal_connect_object (settings, "x11-scale-mode-changed",
+                           G_CALLBACK (scale_mode_changed), manager_xrandr, 0);
+
   G_OBJECT_CLASS (meta_monitor_manager_xrandr_parent_class)->constructed (object);
 }
 
@@ -972,6 +1387,7 @@
   manager_class->read_current_state = meta_monitor_manager_xrandr_read_current_state;
   manager_class->ensure_initial_config = meta_monitor_manager_xrandr_ensure_initial_config;
   manager_class->apply_monitors_config = meta_monitor_manager_xrandr_apply_monitors_config;
+  manager_class->update_screen_size_derived = meta_monitor_manager_xrandr_update_screen_size_derived;
   manager_class->set_power_save_mode = meta_monitor_manager_xrandr_set_power_save_mode;
   manager_class->change_backlight = meta_monitor_manager_xrandr_change_backlight;
   manager_class->tiled_monitor_added = meta_monitor_manager_xrandr_tiled_monitor_added;
diff '--color=auto' -ruN a/src/backends/x11/meta-monitor-manager-xrandr.h b/src/backends/x11/meta-monitor-manager-xrandr.h
--- a/src/backends/x11/meta-monitor-manager-xrandr.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-monitor-manager-xrandr.h	2023-10-03 20:26:00.105794871 +0300
@@ -32,7 +32,7 @@
 
 Display * meta_monitor_manager_xrandr_get_xdisplay (MetaMonitorManagerXrandr *manager_xrandr);
 
-gboolean meta_monitor_manager_xrandr_has_randr15 (MetaMonitorManagerXrandr *manager_xrandr);
-
 gboolean meta_monitor_manager_xrandr_handle_xevent (MetaMonitorManagerXrandr *manager,
                                                     XEvent                   *event);
+
+uint32_t meta_monitor_manager_xrandr_get_config_timestamp (MetaMonitorManagerXrandr *manager);
diff '--color=auto' -ruN a/src/backends/x11/meta-output-xrandr.c b/src/backends/x11/meta-output-xrandr.c
--- a/src/backends/x11/meta-output-xrandr.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/meta-output-xrandr.c	2023-10-03 20:26:00.105794871 +0300
@@ -1005,7 +1005,8 @@
       output_info->height_mm = xrandr_output->mm_height;
     }
 
-  if (meta_monitor_manager_xrandr_has_randr15 (monitor_manager_xrandr))
+  if ((meta_monitor_manager_get_capabilities (monitor_manager) &
+        META_MONITOR_MANAGER_CAPABILITY_TILING))
     output_info_init_tile_info (output_info, xdisplay, output_id);
   output_info_init_modes (output_info, gpu, xrandr_output);
   output_info_init_crtcs (output_info, gpu, xrandr_output);
diff '--color=auto' -ruN a/src/backends/x11/nested/meta-renderer-x11-nested.c b/src/backends/x11/nested/meta-renderer-x11-nested.c
--- a/src/backends/x11/nested/meta-renderer-x11-nested.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/backends/x11/nested/meta-renderer-x11-nested.c	2023-10-03 20:26:00.172462417 +0300
@@ -138,6 +138,7 @@
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "refresh-rate", mode_info->refresh_rate,
                        "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                        "offscreen", COGL_FRAMEBUFFER (offscreen),
diff '--color=auto' -ruN a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
--- a/src/compositor/meta-compositor-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-native.c	2023-10-03 20:26:00.172462417 +0300
@@ -43,6 +43,9 @@
                                                     compositor);
 #endif
 
+  meta_compositor_view_native_maybe_update_frame_sync_surface (compositor_view_native,
+                                                               compositor);
+
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
   parent_class->before_paint (compositor, compositor_view);
 }
diff '--color=auto' -ruN a/src/compositor/meta-compositor-view-native.c b/src/compositor/meta-compositor-view-native.c
--- a/src/compositor/meta-compositor-view-native.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-view-native.c	2023-10-03 20:26:00.172462417 +0300
@@ -26,14 +26,20 @@
 
 #include "backends/meta-crtc.h"
 #include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-renderer-view-native.h"
+#include "clutter/clutter.h"
 #include "compositor/compositor-private.h"
 #include "compositor/meta-window-actor-private.h"
+#include "core/window-private.h"
 
 #ifdef HAVE_WAYLAND
 #include "compositor/meta-surface-actor-wayland.h"
 #include "wayland/meta-wayland-surface.h"
 #endif /* HAVE_WAYLAND */
 
+static void update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                       MetaSurfaceActor         *surface_actor);
+
 struct _MetaCompositorViewNative
 {
   MetaCompositorView parent;
@@ -41,11 +47,52 @@
 #ifdef HAVE_WAYLAND
   MetaWaylandSurface *scanout_candidate;
 #endif /* HAVE_WAYLAND */
+
+  MetaSurfaceActor *frame_sync_surface;
+
+  gulong frame_sync_surface_repaint_scheduled_id;
+  gulong frame_sync_surface_frozen_id;
+  gulong frame_sync_surface_destroy_id;
 };
 
 G_DEFINE_TYPE (MetaCompositorViewNative, meta_compositor_view_native,
                META_TYPE_COMPOSITOR_VIEW)
 
+static void
+on_frame_sync_surface_repaint_scheduled (MetaSurfaceActor         *surface_actor,
+                                         MetaCompositorViewNative *view_native)
+{
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view;
+  MetaRendererViewNative *renderer_view_native;
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  renderer_view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+
+  if (meta_renderer_view_native_is_frame_sync_enabled (renderer_view_native))
+    {
+      ClutterFrameClock *frame_clock;
+
+      frame_clock = clutter_stage_view_get_frame_clock (stage_view);
+
+      clutter_frame_clock_schedule_update_now (frame_clock);
+    }
+}
+
+static void
+on_frame_sync_surface_frozen (MetaSurfaceActor         *surface_actor,
+                              MetaCompositorViewNative *view_native)
+{
+  update_frame_sync_surface (view_native, NULL);
+}
+
+static void
+on_frame_sync_surface_destroyed (MetaSurfaceActor         *surface_actor,
+                                 MetaCompositorViewNative *view_native)
+{
+  update_frame_sync_surface (view_native, NULL);
+}
+
 #ifdef HAVE_WAYLAND
 static void
 update_scanout_candidate (MetaCompositorViewNative *view_native,
@@ -269,6 +316,151 @@
 }
 #endif /* HAVE_WAYLAND */
 
+static MetaSurfaceActor *
+find_frame_sync_candidate (MetaCompositorView *compositor_view,
+                           MetaCompositor     *compositor)
+{
+  MetaWindowActor *window_actor;
+  MetaWindow *window;
+  ClutterStageView *stage_view;
+  MtkRectangle view_layout;
+  MetaSurfaceActor *surface_actor;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: unredirect inhibited");
+      return NULL;
+    }
+
+  window_actor =
+    meta_compositor_view_get_top_window_actor (compositor_view);
+  if (!window_actor)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: no top window actor");
+      return NULL;
+    }
+
+  if (meta_window_actor_is_frozen (window_actor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor is frozen");
+      return NULL;
+    }
+
+  if (meta_window_actor_effect_in_progress (window_actor))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor effects in progress");
+      return NULL;
+    }
+
+  if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor has transition");
+      return NULL;
+    }
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  if (!window)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: no meta-window");
+      return NULL;
+    }
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+
+  clutter_stage_view_get_layout (stage_view, &view_layout);
+
+  if (!meta_window_frame_contains_rect (window, &view_layout))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: stage-view layout not covered "
+                  "by meta-window frame");
+      return NULL;
+    }
+
+  surface_actor = meta_window_actor_get_scanout_candidate (window_actor);
+  if (!surface_actor)
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: window-actor has no scanout candidate");
+      return NULL;
+    }
+
+  if (!meta_surface_actor_contains_rect (surface_actor,
+                                         &view_layout))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No frame sync candidate: stage-view layout not covered "
+                  "by surface-actor");
+      return NULL;
+    }
+
+  return surface_actor;
+}
+
+static void
+update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                           MetaSurfaceActor         *surface_actor)
+{
+  MetaCompositorView *compositor_view =
+    META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view;
+  MetaRendererViewNative *renderer_view_native;
+
+  g_clear_signal_handler (&view_native->frame_sync_surface_repaint_scheduled_id,
+                          view_native->frame_sync_surface);
+  g_clear_signal_handler (&view_native->frame_sync_surface_frozen_id,
+                          view_native->frame_sync_surface);
+  g_clear_signal_handler (&view_native->frame_sync_surface_destroy_id,
+                          view_native->frame_sync_surface);
+
+  if (surface_actor)
+    {
+      view_native->frame_sync_surface_repaint_scheduled_id =
+        g_signal_connect (surface_actor, "repaint-scheduled",
+                          G_CALLBACK (on_frame_sync_surface_repaint_scheduled),
+                          view_native);
+      view_native->frame_sync_surface_frozen_id =
+        g_signal_connect (surface_actor, "frozen",
+                          G_CALLBACK (on_frame_sync_surface_frozen),
+                          view_native);
+      view_native->frame_sync_surface_destroy_id =
+        g_signal_connect (surface_actor, "destroy",
+                          G_CALLBACK (on_frame_sync_surface_destroyed),
+                          view_native);
+    }
+
+  view_native->frame_sync_surface = surface_actor;
+
+  stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  renderer_view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+
+  meta_renderer_view_native_request_frame_sync (renderer_view_native,
+                                                surface_actor != NULL);
+}
+
+void
+meta_compositor_view_native_maybe_update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                                             MetaCompositor           *compositor)
+{
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  MetaSurfaceActor *surface_actor;
+
+  surface_actor = find_frame_sync_candidate (compositor_view,
+                                             compositor);
+
+  if (G_LIKELY (surface_actor == view_native->frame_sync_surface))
+    return;
+
+  update_frame_sync_surface (view_native,
+                             surface_actor);
+}
+
 MetaCompositorViewNative *
 meta_compositor_view_native_new (ClutterStageView *stage_view)
 {
@@ -280,6 +472,25 @@
 }
 
 static void
+meta_compositor_view_native_dispose (GObject *object)
+{
+  MetaCompositorViewNative *view_native = META_COMPOSITOR_VIEW_NATIVE (object);
+
+  if (view_native->frame_sync_surface)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_surface_repaint_scheduled_id,
+                              view_native->frame_sync_surface);
+      g_clear_signal_handler (&view_native->frame_sync_surface_destroy_id,
+                              view_native->frame_sync_surface);
+      g_clear_signal_handler (&view_native->frame_sync_surface_frozen_id,
+                              view_native->frame_sync_surface);
+      view_native->frame_sync_surface = NULL;
+    }
+
+  G_OBJECT_CLASS (meta_compositor_view_native_parent_class)->dispose (object);
+}
+
+static void
 meta_compositor_view_native_finalize (GObject *object)
 {
 #ifdef HAVE_WAYLAND
@@ -296,6 +507,7 @@
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
+  object_class->dispose = meta_compositor_view_native_dispose;
   object_class->finalize = meta_compositor_view_native_finalize;
 }
 
diff '--color=auto' -ruN a/src/compositor/meta-compositor-view-native.h b/src/compositor/meta-compositor-view-native.h
--- a/src/compositor/meta-compositor-view-native.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-view-native.h	2023-10-03 20:26:00.172462417 +0300
@@ -36,3 +36,6 @@
 void meta_compositor_view_native_maybe_assign_scanout (MetaCompositorViewNative *view_native,
                                                        MetaCompositor           *compositor);
 #endif /* HAVE_WAYLAND */
+
+void meta_compositor_view_native_maybe_update_frame_sync_surface (MetaCompositorViewNative *view_native,
+                                                                  MetaCompositor           *compositor);
diff '--color=auto' -ruN a/src/compositor/meta-compositor-x11.c b/src/compositor/meta-compositor-x11.c
--- a/src/compositor/meta-compositor-x11.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-compositor-x11.c	2023-10-03 20:26:00.105794871 +0300
@@ -30,6 +30,7 @@
 #include "compositor/meta-sync-ring.h"
 #include "compositor/meta-window-actor-x11.h"
 #include "core/display-private.h"
+#include "core/window-private.h"
 #include "x11/meta-x11-display-private.h"
 
 struct _MetaCompositorX11
@@ -49,6 +50,8 @@
   gboolean xserver_uses_monotonic_clock;
   int64_t xserver_time_query_time_us;
   int64_t xserver_time_offset_us;
+
+  gboolean randr_scale_disabled;
 };
 
 G_DEFINE_TYPE (MetaCompositorX11, meta_compositor_x11, META_TYPE_COMPOSITOR)
@@ -267,19 +270,90 @@
 }
 
 static void
+on_redirected_monitor_changed (MetaWindow        *window,
+                               int                old_monitor,
+                               MetaCompositorX11 *compositor_x11)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaDisplay *display = meta_compositor_get_display (compositor);
+  MetaContext *context = meta_display_get_context (display);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+
+  if (old_monitor >= 0 && window->monitor &&
+      window->monitor->number != old_monitor)
+    {
+      g_signal_handlers_block_by_func (window,
+                                       on_redirected_monitor_changed,
+                                       compositor_x11);
+
+      if (!compositor_x11->randr_scale_disabled)
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            window->monitor);
+        }
+
+      g_signal_handlers_unblock_by_func (window,
+                                         on_redirected_monitor_changed,
+                                         compositor_x11);
+    }
+  else
+    shape_cow_for_window (META_COMPOSITOR_X11 (compositor_x11), window);
+}
+
+static MetaWindow *
+get_unredirectable_window (MetaCompositorX11 *compositor_x11)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaWindowActor *window_actor;
+  MetaWindowActorX11 *window_actor_x11;
+
+  window_actor = meta_compositor_get_top_window_actor (compositor);
+  if (!window_actor)
+    return NULL;
+
+  window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
+  if (!meta_window_actor_x11_should_unredirect (window_actor_x11))
+    return NULL;
+
+  return meta_window_actor_get_meta_window (window_actor);
+}
+
+static void
 set_unredirected_window (MetaCompositorX11 *compositor_x11,
                          MetaWindow        *window)
 {
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaDisplay *display = meta_compositor_get_display (compositor);
+  MetaContext *context = meta_display_get_context (display);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager = meta_backend_get_monitor_manager (backend);
   MetaWindow *prev_unredirected_window = compositor_x11->unredirected_window;
 
   if (prev_unredirected_window == window)
-    return;
+    {
+      if (!window && compositor_x11->randr_scale_disabled &&
+          !get_unredirectable_window (compositor_x11))
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            NULL);
+        }
+
+      return;
+    }
 
   if (prev_unredirected_window)
     {
       MetaWindowActor *window_actor;
       MetaWindowActorX11 *window_actor_x11;
 
+      g_signal_handlers_disconnect_by_func (prev_unredirected_window,
+                                            on_redirected_monitor_changed,
+                                            compositor_x11);
+
       window_actor = meta_window_actor_from_window (prev_unredirected_window);
       window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
       meta_window_actor_x11_set_unredirected (window_actor_x11, FALSE);
@@ -293,6 +367,17 @@
       MetaWindowActor *window_actor;
       MetaWindowActorX11 *window_actor_x11;
 
+      if (!compositor_x11->randr_scale_disabled)
+        {
+          compositor_x11->randr_scale_disabled =
+            meta_monitor_manager_disable_scale_for_monitor (monitor_manager,
+                                                            window->monitor);
+        }
+
+      g_signal_connect_object (window, "monitor-changed",
+                              G_CALLBACK (on_redirected_monitor_changed),
+                              compositor_x11, 0);
+
       window_actor = meta_window_actor_from_window (window);
       window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
       meta_window_actor_x11_set_unredirected (window_actor_x11, TRUE);
@@ -304,21 +389,11 @@
 {
   MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
   MetaWindow *window_to_unredirect = NULL;
-  MetaWindowActor *window_actor;
-  MetaWindowActorX11 *window_actor_x11;
 
   if (meta_compositor_is_unredirect_inhibited (compositor))
     goto out;
 
-  window_actor = meta_compositor_get_top_window_actor (compositor);
-  if (!window_actor)
-    goto out;
-
-  window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
-  if (!meta_window_actor_x11_should_unredirect (window_actor_x11))
-    goto out;
-
-  window_to_unredirect = meta_window_actor_get_meta_window (window_actor);
+  window_to_unredirect = get_unredirectable_window (compositor_x11);
 
 out:
   set_unredirected_window (compositor_x11, window_to_unredirect);
diff '--color=auto' -ruN a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
--- a/src/compositor/meta-surface-actor.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-surface-actor.c	2023-10-03 20:26:00.172462417 +0300
@@ -63,6 +63,7 @@
 {
   REPAINT_SCHEDULED,
   SIZE_CHANGED,
+  FROZEN,
 
   LAST_SIGNAL,
 };
@@ -296,6 +297,13 @@
                                         0,
                                         NULL, NULL, NULL,
                                         G_TYPE_NONE, 0);
+
+  signals[FROZEN] = g_signal_new ("frozen",
+                                  G_TYPE_FROM_CLASS (object_class),
+                                  G_SIGNAL_RUN_LAST,
+                                  0,
+                                  NULL, NULL, NULL,
+                                  G_TYPE_NONE, 0);
 }
 
 gboolean
@@ -543,6 +551,22 @@
                                                       stage_view);
 }
 
+gboolean
+meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                  MtkRectangle    *rect)
+{
+  ClutterActor *actor = CLUTTER_ACTOR (surface_actor);
+  graphene_rect_t bounding_rect;
+  graphene_rect_t bound_rect;
+
+  clutter_actor_get_transformed_extents (actor, &bounding_rect);
+
+  bound_rect = mtk_rectangle_to_graphene_rect(rect);
+
+  return graphene_rect_contains_rect (&bounding_rect,
+                                      &bound_rect);
+}
+
 void
 meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                      cairo_region_t   *region)
@@ -624,6 +648,9 @@
 
   priv->frozen = frozen;
 
+  if (frozen)
+    g_signal_emit (self, signals[FROZEN], 0);
+
   if (!frozen && priv->pending_damage)
     {
       int i, n_rects = cairo_region_num_rectangles (priv->pending_damage);
diff '--color=auto' -ruN a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
--- a/src/compositor/meta-surface-actor.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/compositor/meta-surface-actor.h	2023-10-03 20:26:00.172462417 +0300
@@ -42,6 +42,9 @@
                                                        ClutterStageView *stage_view,
                                                        float            *unobscurred_fraction);
 
+gboolean meta_surface_actor_contains_rect (MetaSurfaceActor *surface_actor,
+                                           MtkRectangle    *rect);
+
 void meta_surface_actor_set_input_region (MetaSurfaceActor *self,
                                           cairo_region_t   *region);
 void meta_surface_actor_set_opaque_region (MetaSurfaceActor *self,
diff '--color=auto' -ruN a/src/core/events.c b/src/core/events.c
--- a/src/core/events.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/events.c	2023-10-03 20:26:00.165795662 +0300
@@ -530,7 +530,7 @@
 #ifdef HAVE_WAYLAND
   /* If a Wayland client has a grab, don't pass that through to Clutter */
   if (wayland_compositor && meta_wayland_compositor_is_grabbed (wayland_compositor))
-    bypass_clutter = !bypass_wayland;
+    bypass_clutter = bypass_clutter || !bypass_wayland;
 
   if (wayland_compositor && !bypass_wayland)
     {
diff '--color=auto' -ruN a/src/core/meta-private-introspected.h b/src/core/meta-private-introspected.h
--- a/src/core/meta-private-introspected.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/core/meta-private-introspected.h	2023-10-03 20:26:00.162462284 +0300
@@ -0,0 +1,27 @@
+# pragma once
+
+#include <glib-object.h>
+
+#include <meta/types.h>
+
+/**
+ * MetaTileConstraint:
+ * @META_TILE_CONSTRAINT_NONE: No constraint
+ * @META_TILE_CONSTRAINT_WINDOW: Window constraint
+ * @META_TILE_CONSTRAINT_MONITOR: Monitor constraint
+ */
+typedef enum
+{
+  META_WINDOW_CONSTRAINT_NONE,
+  META_WINDOW_CONSTRAINT_WINDOW,
+  META_WINDOW_CONSTRAINT_MONITOR,
+} MetaWindowConstraint;
+
+
+META_EXPORT
+void
+meta_window_override_constraints (MetaWindow           *window,
+                                  MetaWindowConstraint  top,
+                                  MetaWindowConstraint  left,
+                                  MetaWindowConstraint  right,
+                                  MetaWindowConstraint  bottom);
diff '--color=auto' -ruN a/src/core/window.c b/src/core/window.c
--- a/src/core/window.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/window.c	2023-10-03 20:26:00.172462417 +0300
@@ -74,6 +74,7 @@
 #include "core/constraints.h"
 #include "core/frame.h"
 #include "core/keybindings-private.h"
+#include "core/meta-private-introspected.h"
 #include "core/meta-workspace-manager-private.h"
 #include "core/place.h"
 #include "core/stack.h"
@@ -230,6 +231,7 @@
   UNMANAGED,
   SIZE_CHANGED,
   POSITION_CHANGED,
+  MONITOR_CHANGED,
   SHOWN,
   HIGHEST_SCALE_MONITOR_CHANGED,
 
@@ -695,6 +697,21 @@
                   NULL, NULL, NULL,
                   G_TYPE_NONE, 0);
 
+    /**
+   * MetaWindow::monitor-changed:
+   * @window: a #MetaWindow
+   * @old_monitor: the old monitor index or -1 if not known
+   *
+   * This is emitted when the window has changed monitor
+   */
+  window_signals[MONITOR_CHANGED] =
+    g_signal_new ("monitor-changed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1, G_TYPE_INT);
+
   /**
    * MetaWindow::shown:
    * @window: a #MetaWindow
@@ -976,6 +993,9 @@
 {
   META_WINDOW_GET_CLASS (window)->main_monitor_changed (window, old);
 
+  g_signal_emit (window, window_signals[MONITOR_CHANGED], 0,
+                 old ? old->number : -1);
+
   if (old)
     g_signal_emit_by_name (window->display, "window-left-monitor",
                            old->number, window);
@@ -2892,6 +2912,38 @@
     meta_window_tile (tile_match, tile_match->tile_mode);
 }
 
+G_ALWAYS_INLINE static inline MetaEdgeConstraint
+get_edge_constraint (MetaWindowConstraint constraint)
+{
+  switch (constraint)
+    {
+      case META_WINDOW_CONSTRAINT_NONE:
+        return META_EDGE_CONSTRAINT_NONE;
+      case META_WINDOW_CONSTRAINT_WINDOW:
+        return META_EDGE_CONSTRAINT_WINDOW;
+      case META_WINDOW_CONSTRAINT_MONITOR:
+        return META_EDGE_CONSTRAINT_MONITOR;
+    }
+
+  g_return_val_if_reached (META_WINDOW_CONSTRAINT_NONE);
+}
+
+void
+meta_window_override_constraints (MetaWindow           *window,
+                                  MetaWindowConstraint  top,
+                                  MetaWindowConstraint  left,
+                                  MetaWindowConstraint  right,
+                                  MetaWindowConstraint  bottom)
+{
+  window->overridden_constraints.left = get_edge_constraint (left);
+  window->overridden_constraints.right = get_edge_constraint (right);
+  window->overridden_constraints.top = get_edge_constraint (top);
+  window->overridden_constraints.bottom = get_edge_constraint (bottom);
+
+  update_edge_constraints (window);
+  meta_window_frame_size_changed (window);
+}
+
 static void
 update_edge_constraints (MetaWindow *window)
 {
@@ -2947,6 +2999,18 @@
       window->edge_constraints.right = META_EDGE_CONSTRAINT_MONITOR;
       window->edge_constraints.left = META_EDGE_CONSTRAINT_MONITOR;
     }
+
+  if (window->overridden_constraints.top != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.top = window->overridden_constraints.top;
+
+  if (window->overridden_constraints.bottom != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.bottom = window->overridden_constraints.bottom;
+
+  if (window->overridden_constraints.left != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.left = window->overridden_constraints.left;
+
+  if (window->overridden_constraints.right != META_EDGE_CONSTRAINT_NONE)
+      window->edge_constraints.right = window->overridden_constraints.right;
 }
 
 void
@@ -4321,6 +4385,14 @@
     window->size_hints.height_inc;
 }
 
+gboolean
+meta_window_frame_contains_rect (MetaWindow    *window,
+                                 MtkRectangle *rect)
+{
+  return mtk_rectangle_contains_rect (&window->rect,
+                                       rect);
+}
+
 /**
  * meta_window_get_buffer_rect:
  * @window: a #MetaWindow
diff '--color=auto' -ruN a/src/core/window-private.h b/src/core/window-private.h
--- a/src/core/window-private.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/window-private.h	2023-10-03 20:26:00.172462417 +0300
@@ -230,6 +230,13 @@
     MetaEdgeConstraint left;
   } edge_constraints;
 
+  struct {
+    MetaEdgeConstraint top;
+    MetaEdgeConstraint right;
+    MetaEdgeConstraint bottom;
+    MetaEdgeConstraint left;
+  } overridden_constraints;
+
   double tile_hfraction;
 
   uint64_t preferred_output_winsys_id;
@@ -702,6 +709,9 @@
                                               int         *width,
                                               int         *height);
 
+gboolean    meta_window_frame_contains_rect (MetaWindow    *window,
+                                             MtkRectangle *rect);
+
 void        meta_window_update_unfocused_button_grabs (MetaWindow *window);
 
 void        meta_window_update_appears_focused (MetaWindow *window);
diff '--color=auto' -ruN a/src/core/workspace.c b/src/core/workspace.c
--- a/src/core/workspace.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/core/workspace.c	2023-10-03 20:26:00.099128118 +0300
@@ -705,6 +705,7 @@
 {
   int ret;
 
+  g_return_val_if_fail (META_IS_WORKSPACE (workspace), -1);
   ret = g_list_index (workspace->manager->workspaces, workspace);
   g_return_val_if_fail (ret >= 0, -1);
 
diff '--color=auto' -ruN a/src/meson.build b/src/meson.build
--- a/src/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/src/meson.build	2023-10-03 20:26:00.165795662 +0300
@@ -1257,7 +1257,8 @@
     sources: [
       mutter_enum_types[1],
       mutter_introspected_sources,
-      mutter_public_header_files
+      mutter_public_header_files,
+      'core' / 'meta-private-introspected.h',
     ],
     nsversion: libmutter_api_version,
     namespace: 'Meta',
diff '--color=auto' -ruN a/src/tests/meson.build b/src/tests/meson.build
--- a/src/tests/meson.build	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meson.build	2023-10-03 20:26:00.102461495 +0300
@@ -683,7 +683,6 @@
   'override-redirect',
   'set-override-redirect-parent',
   'set-parent-exported',
-  'restore-size',
   'unmaximize-new-size',
   'fullscreen-maximize',
   'unfullscreen-strut-change',
diff '--color=auto' -ruN a/src/tests/meta-monitor-manager-test.c b/src/tests/meta-monitor-manager-test.c
--- a/src/tests/meta-monitor-manager-test.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-manager-test.c	2023-10-03 20:26:00.105794871 +0300
@@ -325,6 +325,7 @@
   switch (layout_mode)
     {
     case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_GLOBAL_UI_LOGICAL:
       break;
     case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
       constraints |= META_MONITOR_SCALES_CONSTRAINT_NO_FRAC;
@@ -376,7 +377,8 @@
 static MetaMonitorManagerCapability
 meta_monitor_manager_test_get_capabilities (MetaMonitorManager *manager)
 {
-  return META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE;
+  return META_MONITOR_MANAGER_CAPABILITY_LAYOUT_MODE |
+         META_MONITOR_MANAGER_CAPABILITY_TILING;
 }
 
 static gboolean
diff '--color=auto' -ruN a/src/tests/meta-monitor-test-utils.c b/src/tests/meta-monitor-test-utils.c
--- a/src/tests/meta-monitor-test-utils.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-test-utils.c	2023-10-03 20:26:00.169129039 +0300
@@ -394,6 +394,10 @@
                            ==,
                            meta_output_is_underscanning (output));
 
+          g_assert_cmpint (expect->monitors[i].is_vrr_disallowed,
+                           ==,
+                           meta_output_is_vrr_disallowed (output));
+
           if (!meta_output_get_max_bpc (output, &output_max_bpc))
             output_max_bpc = 0;
 
@@ -796,6 +800,7 @@
 
           output_assignment = (MetaOutputAssignment) {
             .is_underscanning = setup->outputs[i].is_underscanning,
+            .is_vrr_disallowed = setup->outputs[i].is_vrr_disallowed,
             .has_max_bpc = !!setup->outputs[i].max_bpc,
             .max_bpc = setup->outputs[i].max_bpc,
           };
diff '--color=auto' -ruN a/src/tests/meta-monitor-test-utils.h b/src/tests/meta-monitor-test-utils.h
--- a/src/tests/meta-monitor-test-utils.h	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-monitor-test-utils.h	2023-10-03 20:26:00.169129039 +0300
@@ -105,6 +105,7 @@
   float scale;
   gboolean is_laptop_panel;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   unsigned int max_bpc;
   const char *serial;
   MetaMonitorTransform panel_orientation_transform;
@@ -160,6 +161,7 @@
   int width_mm;
   int height_mm;
   gboolean is_underscanning;
+  gboolean is_vrr_disallowed;
   unsigned int max_bpc;
 } MonitorTestCaseMonitor;
 
diff '--color=auto' -ruN a/src/tests/meta-ref-test.c b/src/tests/meta-ref-test.c
--- a/src/tests/meta-ref-test.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/meta-ref-test.c	2023-10-03 20:26:00.099128118 +0300
@@ -516,6 +516,11 @@
       g_assert_cmpint (ref_status, ==, CAIRO_STATUS_SUCCESS);
       ensure_expected_format (&ref_image);
 
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  g_test_incomplete ("View comparison is not supported by this architecture");
+  return;
+#endif
+
       if (!compare_images (ref_image, view_image, &gl_fuzz,
                            &diff_stat))
         {
diff '--color=auto' -ruN a/src/tests/monitor-configs/vrr-disallowed.xml b/src/tests/monitor-configs/vrr-disallowed.xml
--- a/src/tests/monitor-configs/vrr-disallowed.xml	1970-01-01 02:00:00.000000000 +0200
+++ b/src/tests/monitor-configs/vrr-disallowed.xml	2023-10-03 20:26:00.169129039 +0300
@@ -0,0 +1,23 @@
+<monitors version="2">
+  <configuration>
+    <logicalmonitor>
+      <x>0</x>
+      <y>0</y>
+      <primary>yes</primary>
+      <monitor>
+	<monitorspec>
+	  <connector>DP-1</connector>
+	  <vendor>MetaProduct&apos;s Inc.</vendor>
+	  <product>MetaMonitor</product>
+	  <serial>0x123456</serial>
+	</monitorspec>
+	<mode>
+	  <width>1024</width>
+	  <height>768</height>
+	  <rate>60.000495910644531</rate>
+	</mode>
+	<vrr-allowed>no</vrr-allowed>
+      </monitor>
+    </logicalmonitor>
+  </configuration>
+</monitors>
diff '--color=auto' -ruN a/src/tests/monitor-store-unit-tests.c b/src/tests/monitor-store-unit-tests.c
--- a/src/tests/monitor-store-unit-tests.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/monitor-store-unit-tests.c	2023-10-03 20:26:00.169129039 +0300
@@ -48,6 +48,7 @@
   const char *serial;
   MonitorStoreTestCaseMonitorMode mode;
   gboolean is_underscanning;
+  gboolean disallow_vrr;
   unsigned int max_bpc;
 } MonitorStoreTestCaseMonitor;
 
@@ -197,6 +198,9 @@
           g_assert_cmpint (monitor_config->enable_underscanning,
                            ==,
                            test_monitor->is_underscanning);
+          g_assert_cmpint (monitor_config->disallow_vrr,
+                           ==,
+                           test_monitor->disallow_vrr);
           g_assert_cmpint (monitor_config->has_max_bpc,
                            ==,
                            !!test_monitor->max_bpc);
@@ -454,6 +458,51 @@
 }
 
 static void
+meta_test_monitor_store_vrr_disallowed (void)
+{
+  MonitorStoreTestExpect expect = {
+    .configurations = {
+      {
+        .logical_monitors = {
+          {
+            .layout = {
+              .x = 0,
+              .y = 0,
+              .width = 1024,
+              .height = 768
+            },
+            .scale = 1,
+            .is_primary = TRUE,
+            .is_presentation = FALSE,
+            .monitors = {
+              {
+                .connector = "DP-1",
+                .vendor = "MetaProduct's Inc.",
+                .product = "MetaMonitor",
+                .serial = "0x123456",
+                .mode = {
+                  .width = 1024,
+                  .height = 768,
+                  .refresh_rate = 60.000495910644531
+                },
+                .disallow_vrr = TRUE,
+              }
+            },
+            .n_monitors = 1,
+          },
+        },
+        .n_logical_monitors = 1
+      }
+    },
+    .n_configurations = 1
+  };
+
+  meta_set_custom_monitor_config (test_context, "vrr-disallowed.xml");
+
+  check_monitor_store_configurations (&expect);
+}
+
+static void
 meta_test_monitor_store_max_bpc (void)
 {
   MonitorStoreTestExpect expect = {
@@ -1047,6 +1096,8 @@
                    meta_test_monitor_store_primary);
   g_test_add_func ("/backends/monitor-store/underscanning",
                    meta_test_monitor_store_underscanning);
+  g_test_add_func ("/backends/monitor-store/vrr-disallowed",
+                   meta_test_monitor_store_vrr_disallowed);
   g_test_add_func ("/backends/monitor-store/max-bpc",
                    meta_test_monitor_store_max_bpc);
   g_test_add_func ("/backends/monitor-store/scale",
diff '--color=auto' -ruN a/src/tests/monitor-unit-tests.c b/src/tests/monitor-unit-tests.c
--- a/src/tests/monitor-unit-tests.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/monitor-unit-tests.c	2023-10-03 20:26:00.169129039 +0300
@@ -3255,6 +3255,100 @@
 }
 
 static void
+meta_test_monitor_vrr_disallowed_config (void)
+{
+  MonitorTestCase test_case = {
+    .setup = {
+      .modes = {
+        {
+          .width = 1024,
+          .height = 768,
+          .refresh_rate = 60.0
+        }
+      },
+      .n_modes = 1,
+      .outputs = {
+        {
+          .crtc = 0,
+          .modes = { 0 },
+          .n_modes = 1,
+          .preferred_mode = 0,
+          .possible_crtcs = { 0 },
+          .n_possible_crtcs = 1,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0
+        }
+      },
+      .n_crtcs = 1
+    },
+
+    .expect = {
+      .monitors = {
+        {
+          .outputs = { 0 },
+          .n_outputs = 1,
+          .modes = {
+            {
+              .width = 1024,
+              .height = 768,
+              .refresh_rate = 60.0,
+              .crtc_modes = {
+                {
+                  .output = 0,
+                  .crtc_mode = 0
+                }
+              }
+            }
+          },
+          .n_modes = 1,
+          .current_mode = 0,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_monitors = 1,
+      .logical_monitors = {
+        {
+          .monitors = { 0 },
+          .n_monitors = 1,
+          .layout = { .x = 0, .y = 0, .width = 1024, .height = 768 },
+          .scale = 1
+        }
+      },
+      .n_logical_monitors = 1,
+      .primary_logical_monitor = 0,
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0,
+        }
+      },
+      .n_crtcs = 1,
+      .screen_width = 1024,
+      .screen_height = 768
+    }
+  };
+  MetaMonitorTestSetup *test_setup;
+
+  test_setup = meta_create_monitor_test_setup (test_backend,
+                                               &test_case.setup,
+                                               MONITOR_TEST_FLAG_NO_STORED);
+  emulate_hotplug (test_setup);
+  META_TEST_LOG_CALL ("Checking monitor configuration",
+                      meta_check_monitor_configuration (test_context,
+                                                        &test_case.expect));
+  check_monitor_test_clients_state ();
+}
+
+static void
 meta_test_monitor_max_bpc_config (void)
 {
   MonitorTestCase test_case = {
@@ -5840,6 +5934,103 @@
 }
 
 static void
+meta_test_monitor_custom_vrr_disallowed_config (void)
+{
+  MonitorTestCase test_case = {
+    .setup = {
+      .modes = {
+        {
+          .width = 1024,
+          .height = 768,
+          .refresh_rate = 60.000495910644531
+        }
+      },
+      .n_modes = 1,
+      .outputs = {
+        {
+          .crtc = 0,
+          .modes = { 0 },
+          .n_modes = 1,
+          .preferred_mode = 0,
+          .possible_crtcs = { 0 },
+          .n_possible_crtcs = 1,
+          .width_mm = 222,
+          .height_mm = 125,
+          .serial = "0x123456",
+        },
+      },
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0
+        },
+      },
+      .n_crtcs = 1
+    },
+
+    .expect = {
+      .monitors = {
+        {
+          .outputs = { 0 },
+          .n_outputs = 1,
+          .modes = {
+            {
+              .width = 1024,
+              .height = 768,
+              .refresh_rate = 60.000495910644531,
+              .crtc_modes = {
+                {
+                  .output = 0,
+                  .crtc_mode = 0
+                }
+              }
+            }
+          },
+          .n_modes = 1,
+          .current_mode = 0,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_vrr_disallowed = TRUE,
+        }
+      },
+      .n_monitors = 1,
+      .logical_monitors = {
+        {
+          .monitors = { 0 },
+          .n_monitors = 1,
+          .layout = { .x = 0, .y = 0, .width = 1024, .height = 768 },
+          .scale = 1
+        }
+      },
+      .n_logical_monitors = 1,
+      .primary_logical_monitor = 0,
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0,
+        }
+      },
+      .n_crtcs = 1,
+      .n_tiled_monitors = 0,
+      .screen_width = 1024,
+      .screen_height = 768
+    }
+  };
+  MetaMonitorTestSetup *test_setup;
+
+  test_setup = meta_create_monitor_test_setup (test_backend,
+                                               &test_case.setup,
+                                               MONITOR_TEST_FLAG_NONE);
+  meta_set_custom_monitor_config (test_context, "vrr-disallowed.xml");
+  emulate_hotplug (test_setup);
+
+  META_TEST_LOG_CALL ("Checking monitor configuration",
+                      meta_check_monitor_configuration (test_context,
+                                                        &test_case.expect));
+  check_monitor_test_clients_state ();
+}
+
+static void
 meta_test_monitor_custom_scale_config (void)
 {
   MonitorTestCase test_case = {
@@ -9624,6 +9815,8 @@
                     meta_test_monitor_no_outputs);
   add_monitor_test ("/backends/monitor/underscanning-config",
                     meta_test_monitor_underscanning_config);
+  add_monitor_test ("/backends/monitor/vrr-disallowed-config",
+                    meta_test_monitor_vrr_disallowed_config);
   add_monitor_test ("/backends/monitor/max-bpc-config",
                     meta_test_monitor_max_bpc_config);
   add_monitor_test ("/backends/monitor/preferred-non-first-mode",
@@ -9658,6 +9851,8 @@
                     meta_test_monitor_custom_primary_config);
   add_monitor_test ("/backends/monitor/custom/underscanning-config",
                     meta_test_monitor_custom_underscanning_config);
+  add_monitor_test ("/backends/monitor/custom/vrr-disallowed-config",
+                    meta_test_monitor_custom_vrr_disallowed_config);
   add_monitor_test ("/backends/monitor/custom/scale-config",
                     meta_test_monitor_custom_scale_config);
   add_monitor_test ("/backends/monitor/custom/fractional-scale-config",
diff '--color=auto' -ruN a/src/tests/native-headless.c b/src/tests/native-headless.c
--- a/src/tests/native-headless.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/native-headless.c	2023-10-03 20:26:00.099128118 +0300
@@ -26,7 +26,8 @@
 init_tests (MetaContext *context)
 {
   init_virtual_monitor_tests (context);
-  init_screen_cast_tests ();
+  // init_screen_cast_tests ();
+  (void) init_screen_cast_tests;
 }
 
 int
diff '--color=auto' -ruN a/src/tests/native-thread.c b/src/tests/native-thread.c
--- a/src/tests/native-thread.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/native-thread.c	2023-10-03 20:26:00.102461495 +0300
@@ -1156,6 +1156,12 @@
                                 g_variant_new ("(t)", gettid ()));
 
   g_variant_get (ret, "(u)", &priority);
+
+#if defined  __arm__ || defined __i386__
+  g_test_incomplete ("Modifying thread priority is not supported by this architecture");
+  return;
+#endif
+
   g_assert_cmpint (priority, ==, 20);
 
   return NULL;
diff '--color=auto' -ruN a/src/tests/ref-test-sanity.c b/src/tests/ref-test-sanity.c
--- a/src/tests/ref-test-sanity.c	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/ref-test-sanity.c	2023-10-03 20:26:00.099128118 +0300
@@ -108,6 +108,11 @@
   clutter_actor_set_background_color (actor2, CLUTTER_COLOR_SkyBlue);
   clutter_actor_add_child (stage, actor2);
 
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  g_test_incomplete ("View comparison is not supported by this architecture");
+  return;
+#endif
+
   g_test_expect_message ("libmutter-test",
                          G_LOG_LEVEL_CRITICAL,
                          "Pixel difference exceeds limits*");
diff '--color=auto' -ruN a/src/tests/stacking/unmaximize-new-size.metatest b/src/tests/stacking/unmaximize-new-size.metatest
--- a/src/tests/stacking/unmaximize-new-size.metatest	2023-09-16 23:51:03.000000000 +0300
+++ b/src/tests/stacking/unmaximize-new-size.metatest	2023-10-03 20:26:00.099128118 +0300
@@ -11,11 +11,9 @@
 
 maximize w/1
 wait_reconfigure
-assert_size w/1 MONITOR_WIDTH MONITOR_HEIGHT
 
 resize w/1 300 500
 wait_reconfigure
-assert_size w/1 MONITOR_WIDTH MONITOR_HEIGHT
 
 unmaximize w/1
 wait_reconfigure